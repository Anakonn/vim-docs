---
description: Vimマクロを使用して、繰り返しの編集作業を自動化する方法を学び、ファイルの編集を効率化しましょう。
title: Ch09. Macros
---

ファイルを編集していると、同じアクションを繰り返すことがあるかもしれません。それを一度だけ行い、必要なときに再生できたら素晴らしいと思いませんか？Vimのマクロを使えば、アクションを記録し、Vimのレジスタに保存して、必要なときに実行できます。

この章では、マクロを使って退屈な作業を自動化する方法を学びます（ファイルが自分で編集されるのを見るのはクールです）。

## 基本的なマクロ

Vimマクロの基本構文は次のとおりです：

```shell
qa                     レジスタaにマクロの録音を開始
q (録音中)            録音を停止
```

マクロを保存するために、任意の小文字（a-z）を選択できます。マクロを実行する方法は次のとおりです：

```shell
@a    レジスタaからマクロを実行
@@    最後に実行したマクロを実行
```

次のテキストがあり、各行のすべてを大文字にしたいとします：

```shell
hello
vim
macros
are
awesome
```

カーソルを「hello」の行の先頭に置いて、次のコマンドを実行します：

```shell
qa0gU$jq
```

内訳：
- `qa` はレジスタaにマクロの録音を開始します。
- `0` は行の先頭に移動します。
- `gU$` は現在の位置から行の終わりまでのテキストを大文字にします。
- `j` は1行下に移動します。
- `q` は録音を停止します。

再生するには、`@a`を実行します。他の多くのVimコマンドと同様に、マクロにカウント引数を渡すことができます。たとえば、`3@a`を実行すると、マクロが3回実行されます。

## セーフティガード

マクロの実行は、エラーに遭遇すると自動的に終了します。次のテキストがあるとします：

```shell
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

各行の最初の単語を大文字にしたい場合、このマクロが機能するはずです：

```shell
qa0W~jq
```

上記のコマンドの内訳：
- `qa` はレジスタaにマクロの録音を開始します。
- `0` は行の先頭に移動します。
- `W` は次の単語に移動します。
- `~` はカーソル下の文字の大文字と小文字を切り替えます。
- `j` は1行下に移動します。
- `q` は録音を停止します。

私はマクロの実行を過剰にカウントすることを好み、通常は99回呼び出します（`99@a`）。このコマンドでは、Vimは実際にこのマクロを99回実行するわけではありません。Vimが最後の行に達し、`j`動作を実行すると、下に移動する行がないため、エラーを投げてマクロの実行を停止します。

最初のエラーに遭遇したときにマクロの実行が停止するという事実は良い機能です。さもなければ、Vimは行の終わりに達しても、99回このマクロを実行し続けることになります。

## コマンドラインマクロ

通常モードで`@a`を実行することは、Vimでマクロを実行する唯一の方法ではありません。コマンドラインで`:normal @a`を実行することもできます。`:normal`は、引数として渡された任意の通常モードコマンドを実行することをユーザーに許可します。上記の場合、通常モードから`@a`を実行するのと同じです。

`:normal`コマンドは、範囲を引数として受け入れます。これを使用して、選択した範囲でマクロを実行できます。たとえば、2行目と3行目の間でマクロを実行したい場合は、`:2,3 normal @a`を実行できます。

## 複数ファイルにわたるマクロの実行

複数の`.txt`ファイルがあり、それぞれにいくつかのテキストが含まれているとします。あなたのタスクは、「donut」という単語を含む行の最初の単語だけを大文字にすることです。レジスタaに`0W~j`があると仮定します（前のマクロと同じです）。これを迅速に達成するにはどうすればよいでしょうか？

最初のファイル：

```shell
## savory.txt
a. cheddar jalapeno donut
b. mac n cheese donut
c. fried dumpling
```

2番目のファイル：

```shell
## sweet.txt
a. chocolate donut
b. chocolate pancake
c. powdered sugar donut
```

3番目のファイル：

```shell
## plain.txt
a. wheat bread
b. plain donut
```

次のように実行できます：
- `:args *.txt`で現在のディレクトリ内のすべての`.txt`ファイルを見つけます。
- `:argdo g/donut/normal @a`は、`:args`内の各ファイルに対してグローバルコマンド`g/donut/normal @a`を実行します。
- `:argdo update`は、バッファが変更されたときに、`:args`内の各ファイルを保存するために`update`コマンドを実行します。

グローバルコマンド`:g/donut/normal @a`に不慣れな場合、それはパターン（`/donut/`）に一致する行に対して与えたコマンド（`normal @a`）を実行します。グローバルコマンドについては、後の章で説明します。

## 再帰的マクロ

マクロを録音中に同じマクロレジスタを呼び出すことで、再帰的にマクロを実行できます。再度このリストがあり、最初の単語の大文字と小文字を切り替える必要があるとします：

```shell
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

今回は再帰的に行ってみましょう。次のコマンドを実行します：

```shell
qaqqa0W~j@aq
```

手順の内訳：
- `qaq`は空のマクロaを記録します。再帰的にマクロを呼び出すためには、空のレジスタから始める必要があります。
- `qa`はレジスタaに録音を開始します。
- `0`は現在の行の最初の文字に移動します。
- `W`は次の単語に移動します。
- `~`はカーソル下の文字の大文字と小文字を切り替えます。
- `j`は1行下に移動します。
- `@a`はマクロaを実行します。
- `q`は録音を停止します。

これで、`@a`を実行するだけで、Vimがマクロを再帰的に実行するのを見守ることができます。

マクロがいつ停止するかはどうやって知ったのでしょうか？マクロが最後の行にあるとき、`j`を実行しようとしましたが、移動する行がなかったため、マクロの実行が停止しました。

## マクロの追加

既存のマクロにアクションを追加する必要がある場合、マクロを最初から再作成するのではなく、既存のものにアクションを追加できます。レジスタの章で、上書き記号を使用して名前付きレジスタに追加できることを学びました。同じルールが適用されます。レジスタaのマクロにアクションを追加するには、レジスタAを使用します。

レジスタaにマクロを記録します：`qa0W~q`（このシーケンスは行の次の単語の大文字と小文字を切り替えます）。行の最後にドットを追加するために新しいシーケンスを追加したい場合は、次のコマンドを実行します：

```shell
qAA.<Esc>q
```

内訳：
- `qA`はレジスタAにマクロの録音を開始します。
- `A.<Esc>`は行の最後に（ここで`A`は挿入モードコマンドであり、マクロAとは混同しないでください）ドットを挿入し、挿入モードを終了します。
- `q`はマクロの録音を停止します。

これで、`@a`を実行すると、次の単語の大文字と小文字を切り替えるだけでなく、行の最後にドットも追加されます。

## マクロの修正

マクロの中間に新しいアクションを追加する必要がある場合はどうしますか？

最初の実際の単語を切り替え、行の最後にピリオドを追加するマクロがあると仮定します。レジスタaに`0W~A.<Esc>`があるとします。最初の単語を大文字にするのと行の最後にピリオドを追加する間に、「donut」の前に「deep fried」という単語を追加する必要があるとします（*通常のドーナツよりも深揚げドーナツの方が良いからです*）。

前のセクションからのテキストを再利用します：
```shell
a. chocolate donut
b. mochi donut
c. powdered sugar donut
d. plain donut
```

まず、既存のマクロを呼び出します（前のセクションのマクロをレジスタaに保持していると仮定します）：

```shell
0W~A.^[
```

この`^[`は何ですか？`0W~A.<Esc>`を実行しませんでしたか？`<Esc>`はどこにありますか？`^[`はVimの*内部コード*表現の`<Esc>`です。特定の特殊キーでは、Vimはそれらのキーの表現を内部コードの形式で印刷します。内部コード表現を持つ一般的なキーには、`<Esc>`、`<Backspace>`、`<Enter>`があります。もっと多くの特殊キーがありますが、これはこの章の範囲外です。

マクロに戻ると、切り替えケース演算子（`~`）の直後に、行の最後に移動する（`$`）、1単語戻る（`b`）、挿入モードに移動する（`i`）、"deep fried "と入力する（"fried "の後にスペースを忘れないでください）、そして挿入モードを終了する（`<Esc>`）という指示を追加します。

最終的に次のようになります：

```shell
0W~$bideep fried <Esc>A.^[
```

小さな問題があります。Vimは`<Esc>`を理解しません。`<Esc>`を文字通り入力することはできません。`<Esc>`キーの内部コード表現を書く必要があります。挿入モード中に、`Ctrl-V`を押してから`<Esc>`を押すと、Vimは`^[`を印刷します。`Ctrl-V`は次の非数字文字を*文字通り*挿入するための挿入モードオペレーターです。あなたのマクロコードは次のようになります：

```shell
0W~$bideep fried ^[A.^[
```

修正された指示をレジスタaに追加するには、名前付きレジスタに新しいエントリを追加するのと同じ方法で行えます。行の先頭で、`"ay$`を実行して、ヤンクされたテキストをレジスタaに保存します。

これで、`@a`を実行すると、マクロは最初の単語の大文字と小文字を切り替え、「donut」の前に「deep fried」を追加し、行の最後に"."を追加します。おいしい！

マクロを修正する別の方法は、コマンドライン式を使用することです。`:let @a="`を実行し、次に`Ctrl-R a`を実行すると、レジスタaの内容が文字通り貼り付けられます。最後に、二重引用符（`"`）を閉じることを忘れないでください。次のようになるかもしれません：`:let @a="0W~$bideep fried ^[A.^["`。

## マクロの冗長性

マクロを1つのレジスタから別のレジスタに簡単に複製できます。たとえば、レジスタaのマクロをレジスタzに複製するには、`:let @z = @a`を実行します。`@a`はレジスタaの内容を表します。これで、`@z`を実行すると、`@a`と全く同じアクションが実行されます。

私は、最も頻繁に使用するマクロに冗長性を持たせることが便利だと感じています。私のワークフローでは、通常、最初の7つのアルファベットの文字（a-g）にマクロを記録し、あまり考えずにそれらを置き換えます。役立つマクロをアルファベットの後半に移動させることで、誤って置き換えることを心配せずに保存できます。

## シリーズ対並列マクロ

Vimはマクロをシリーズおよび並列で実行できます。次のテキストがあります：

```shell
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

すべての大文字の「FUNC」を小文字にするマクロを記録したい場合、このマクロは機能するはずです：

```shell
qa0f{gui{jq
```

内訳：
- `qa`はレジスタaに録音を開始します。
- `0`は最初の行に移動します。
- `f{`は最初のインスタンスの「{」を見つけます。
- `gui{`は括弧内のテキストオブジェクト（`i{`）のテキストを小文字にします。
- `j`は1行下に移動します。
- `q`はマクロの録音を停止します。

これで、残りの行に対して`99@a`を実行できます。しかし、ファイル内にこのインポート式がある場合はどうでしょうか？

```shell
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import foo from "bar";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

`99@a`を実行すると、マクロは3回しか実行されません。最後の2行に対してマクロを実行しないのは、"foo"の行で`f{`を実行できなかったためです。これは、シリーズでマクロを実行する際に予想されることです。「FUNC4」がある次の行に移動して、再度そのマクロを再生することはできます。しかし、すべてを一度に終わらせたい場合はどうしますか？

マクロを並列で実行します。

前のセクションから思い出してください。マクロはコマンドラインコマンド`:normal`を使用して実行できます（例：`:3,5 normal @a`は3-5行目でマクロaを実行します）。`:1,$ normal @a`を実行すると、マクロがすべての行で実行されているのがわかりますが、「foo」の行は除外されます。機能します！

内部的にはVimは実際にマクロを並列で実行していませんが、外見上はそのように動作します。Vimは最初の行から最後の行まで（`1,$`）各行で`@a`を*独立して*実行します。Vimがこれらのマクロを独立して実行するため、各行は「foo」の行でのマクロ実行が失敗したことを知りません。
## スマートな方法でマクロを学ぶ

編集で行う多くのことは繰り返しです。編集が上達するためには、繰り返しのアクションを検出する習慣を身につけましょう。同じアクションを二度行わなくて済むように、マクロ（またはドットコマンド）を使用してください。Vimでできるほとんどすべてのことは、マクロで再現できます。

最初はマクロを書くのが非常に awkward に感じるかもしれませんが、あきらめないでください。十分な練習を重ねれば、すべてを自動化する習慣が身につきます。

マクロを覚えるのに助けになるニーモニックを使うと良いかもしれません。関数を作成するマクロがある場合は、「f レジスタ（`qf`）を使用してください。数値演算用のマクロがある場合は、「n レジスタが機能するはずです（`qn`）。その操作を考えたときに思い浮かぶ*最初の名前付きレジスタ*で名前を付けてください。また、「q レジスタはデフォルトのマクロレジスタとして良い選択だと思います。なぜなら、`qq`は考えるのにそれほど脳の力を必要としないからです。最後に、マクロをアルファベット順にインクリメントするのも好きです。例えば、`qa`、次に `qb`、次に `qc`、という具合です。

自分に最適な方法を見つけてください。