---
description: Vimで外部コマンドを活用する方法を学び、Unixの小さなコマンドを組み合わせて複雑な問題を解決する方法を紹介します。
title: Ch14. External Commands
---

Unixシステム内には、1つのことを（そしてそれをうまく）行う多くの小さな、超専門化されたコマンドがあります。これらのコマンドを連結して、複雑な問題を解決するために協力させることができます。Vimの内部からこれらのコマンドを使用できたら素晴らしいと思いませんか？

確かに。 この章では、Vimを拡張して外部コマンドとシームレスに連携させる方法を学びます。

## バングコマンド

Vimには、3つのことができるバング（`!`）コマンドがあります：

1. 外部コマンドのSTDOUTを現在のバッファに読み込む。
2. バッファの内容を外部コマンドのSTDINとして書き込む。
3. Vimの内部から外部コマンドを実行する。

それぞれを見ていきましょう。

## VimにコマンドのSTDOUTを読み込む

外部コマンドのSTDOUTを現在のバッファに読み込むための構文は次のとおりです：

```shell
:r !cmd
```

`:r`はVimの読み込みコマンドです。`!`なしで使用すると、ファイルの内容を取得するために使用できます。現在のディレクトリに`file1.txt`というファイルがある場合、次のように実行します：

```shell
:r file1.txt
```

Vimは`file1.txt`の内容を現在のバッファに挿入します。

`!`と外部コマンドを続けて`:r`コマンドを実行すると、そのコマンドの出力が現在のバッファに挿入されます。`ls`コマンドの結果を取得するには、次のように実行します：

```shell
:r !ls
```

次のような結果が返されます：

```shell
file1.txt
file2.txt
file3.txt
```

`curl`コマンドからデータを読み込むこともできます：

```shell
:r !curl -s 'https://jsonplaceholder.typicode.com/todos/1'
```

`r`コマンドはアドレスも受け付けます：

```shell
:10r !cat file1.txt
```

これで、`cat file1.txt`を実行した結果が10行目の後に挿入されます。

## バッファの内容を外部コマンドに書き込む

`:w`コマンドは、ファイルを保存するだけでなく、現在のバッファ内のテキストを外部コマンドのSTDINとして渡すためにも使用できます。構文は次のとおりです：

```shell
:w !cmd
```

次のような式があるとします：

```shell
console.log("Hello Vim");
console.log("Vim is awesome");
```

マシンに[Node](https://nodejs.org/en/)がインストールされていることを確認し、次のように実行します：

```shell
:w !node
```

Vimは`node`を使用してJavaScriptの式を実行し、「Hello Vim」と「Vim is awesome」を印刷します。

`:w`コマンドを使用する際、Vimは現在のバッファ内のすべてのテキストを使用します。特定のアドレスを`:w`に渡すと：

```shell
:2w !node
```

Vimは2行目のテキストのみを`node`インタープリタに使用します。

`:w !node`と`:w! node`の間には微妙だが重要な違いがあります。`:w !node`では、現在のバッファ内のテキストを外部コマンド`node`に「書き込んで」います。`:w! node`では、ファイルを強制的に保存し、そのファイルの名前を「node」としています。

## 外部コマンドを実行する

バングコマンドを使用してVimの内部から外部コマンドを実行できます。構文は次のとおりです：

```shell
:!cmd
```

現在のディレクトリの内容を長い形式で表示するには、次のように実行します：

```shell
:!ls -ls
```

PID 3456で実行中のプロセスを終了するには、次のように実行します：

```shell
:!kill -9 3456
```

Vimを離れることなく、任意の外部コマンドを実行できるため、作業に集中できます。

## テキストのフィルタリング

`!`に範囲を指定すると、テキストをフィルタリングするために使用できます。次のテキストがあるとしましょう：

```shell
hello vim
hello vim
```

現在の行を大文字にするために、`tr`（変換）コマンドを使用します。次のように実行します：

```shell
:.!tr '[:lower:]' '[:upper:]'
```

結果：

```shell
HELLO VIM
hello vim
```

内訳：
- `.!`は現在の行にフィルタコマンドを実行します。
- `tr '[:lower:]' '[:upper:]'`は、すべての小文字を大文字に置き換えるために`tr`コマンドを呼び出します。

外部コマンドをフィルタとして実行するには、範囲を渡すことが不可欠です。`.`なしで上記のコマンドを実行しようとすると（`:!tr '[:lower:]' '[:upper:]'`）、エラーが表示されます。

両方の行の2列目を`awk`コマンドで削除する必要があると仮定しましょう：

```shell
:%!awk "{print $1}"
```

結果：

```shell
hello
hello
```

内訳：
- `:%!`はすべての行にフィルタコマンドを実行します（`%`）。
- `awk "{print $1}"`は一致する最初の列のみを印刷します。

ターミナルと同様に、チェーン演算子（`|`）を使用して複数のコマンドを連結できます。たとえば、次のような美味しい朝食アイテムのファイルがあるとします：

```shell
name price
chocolate pancake 10
buttermilk pancake 9
blueberry pancake 12
```

価格に基づいてそれらをソートし、均等な間隔でメニューのみを表示する必要がある場合、次のように実行します：

```shell
:%!awk 'NR > 1' | sort -nk 3 | column -t
```

結果：
```shell
buttermilk pancake 9
chocolate pancake 10
blueberry pancake 12
```

内訳：
- `:%!`はすべての行にフィルタを適用します（`%`）。
- `awk 'NR > 1'`は、2行目以降のテキストのみを表示します。
- `|`は次のコマンドを連結します。
- `sort -nk 3`は、3列目の値を使用して数値的にソートします（`n`）。
- `column -t`は、均等な間隔でテキストを整理します。

## ノーマルモードコマンド

Vimには、ノーマルモードにフィルタ演算子（`!`）があります。次のような挨拶があるとします：

```shell
hello vim
hola vim
bonjour vim
salve vim
```

現在の行とその下の行を大文字にするには、次のように実行します：
```shell
!jtr '[a-z]' '[A-Z]'
```

内訳：
- `!j`は、現在の行とその下の行を対象とするノーマルコマンドフィルタ演算子（`!`）を実行します。これはノーマルモードの演算子であるため、文法ルール`動詞 + 名詞`が適用されます。`!`は動詞で、`j`は名詞です。
- `tr '[a-z]' '[A-Z]'`は、小文字を大文字に置き換えます。

フィルタノーマルコマンドは、少なくとも1行以上の動作/テキストオブジェクトに対してのみ機能します。`!iwtr '[a-z]' '[A-Z]'`（内部単語に対して`tr`を実行）を実行しようとすると、カーソルがある単語ではなく、行全体に`tr`コマンドが適用されることがわかります。

## 外部コマンドを賢く学ぶ

VimはIDEではありません。それは設計上非常に拡張可能な軽量モーダルエディタです。この拡張性により、システム内の任意の外部コマンドに簡単にアクセスできます。これらの外部コマンドを駆使することで、VimはIDEに一歩近づきます。誰かがUnixシステムは初めてのIDEであると言いました。

バングコマンドは、知っている外部コマンドの数と同じくらい便利です。外部コマンドの知識が限られていても心配しないでください。私もまだ学ぶことがたくさんあります。これは継続的な学習のモチベーションとして受け取ってください。テキストを修正する必要があるときは、問題を解決できる外部コマンドがあるかどうかを確認してください。すべてをマスターすることを心配せず、現在のタスクを完了するために必要なものだけを学んでください。