---
description: この章では、検索と置換の概念を学び、正規表現を使用して効率的にテキストをターゲットにする方法を紹介します。
title: Ch12. Search and Substitute
---

この章では、検索と置換という2つの別々だが関連する概念について説明します。編集を行う際、最小公倍数パターンに基づいて複数のテキストを検索する必要があることがよくあります。リテラル文字列の代わりに正規表現を使用して検索と置換を行う方法を学ぶことで、任意のテキストを迅速にターゲットにすることができます。

ちなみに、この章では検索について話すときに `/` を使用します。`/` でできることはすべて `?` でもできます。

## スマートな大文字小文字の感度

検索語の大文字小文字を一致させるのは難しい場合があります。「Learn Vim」というテキストを検索しているときに、1文字の大文字小文字を間違えて入力すると、誤った検索結果が得られることがあります。どんな大文字小文字でも一致させることができれば、より簡単で安全ではないでしょうか？ここで `ignorecase` オプションが役立ちます。vimrc に `set ignorecase` を追加するだけで、すべての検索語が大文字小文字を区別しなくなります。これで、`/Learn Vim` を入力する必要はなくなり、`/learn vim` でも機能します。

ただし、特定の大文字小文字のフレーズを検索する必要がある場合もあります。その場合、`set noignorecase` を実行して `ignorecase` オプションをオフにすることができますが、大文字小文字を区別するフレーズを検索するたびにオンオフするのは手間がかかります。

`ignorecase` を切り替える手間を省くために、Vim には `smartcase` オプションがあります。これは、検索パターンに *少なくとも1つの大文字が含まれている場合* に大文字小文字を区別しない文字列を検索します。すべて小文字の文字を入力したときには大文字小文字を区別しない検索を行い、1つ以上の大文字を入力したときには大文字小文字を区別する検索を行うために、`ignorecase` と `smartcase` を組み合わせることができます。

vimrc に次のように追加します：

```shell
set ignorecase smartcase
```

次のテキストがあるとします：

```shell
hello
HELLO
Hello
```

- `/hello` は "hello"、"HELLO"、"Hello" に一致します。
- `/HELLO` は "HELLO" のみ一致します。
- `/Hello` は "Hello" のみ一致します。

一つの欠点があります。小文字の文字列のみを検索する必要がある場合はどうでしょうか？`/hello` を実行すると、Vim は大文字小文字を区別しない検索を行います。検索語のどこにでも `\C` パターンを使用して、次の検索語が大文字小文字を区別することを Vim に伝えることができます。`/\Chello` を実行すると、"hello" のみが厳密に一致し、"HELLO" や "Hello" とは一致しません。

## 行の最初と最後の文字

`^` を使用して行の最初の文字に一致させ、`$` を使用して行の最後の文字に一致させることができます。

次のテキストがあるとします：

```shell
hello hello
```

最初の "hello" をターゲットにするには `/^hello` を使用します。`^` の後に続く文字は、行の最初の文字でなければなりません。最後の "hello" をターゲットにするには、`/hello$` を実行します。`$` の前の文字は、行の最後の文字でなければなりません。

次のテキストがあるとします：

```shell
hello hello friend
```

`/hello$` を実行しても何も一致しません。なぜなら "friend" がその行の最後の単語であり、"hello" ではないからです。

## 検索の繰り返し

`//` を使用して前回の検索を繰り返すことができます。`/hello` を検索したばかりの場合、`//` を実行すると `/hello` を実行したのと同じことになります。このショートカットは、特に長い文字列を検索したばかりの場合に、いくつかのキー入力を節約できます。また、`n` と `N` を使用して、最後の検索を同じ方向と逆方向で繰り返すことができることを思い出してください。

* n * 個の最後の検索語をすばやく呼び出したい場合はどうでしょうか？最初に `/` を押し、その後 `up` / `down` 矢印キー（または `Ctrl-N` / `Ctrl-P`）を押して、必要な検索語が見つかるまで移動できます。すべての検索履歴を表示するには、`:history /` を実行します。

検索中にファイルの終わりに達すると、Vim はエラーを表示します：`"Search hit the BOTTOM without match for: {your-search}"`。これは過剰検索からの良い保護になることがありますが、他の時には再び検索をトップに戻したい場合もあります。`set wrapscan` オプションを使用すると、ファイルの終わりに達したときに Vim がファイルのトップで再検索するようにできます。この機能をオフにするには、`set nowrapscan` を実行します。

## 代替語の検索

複数の単語を同時に検索することは一般的です。「hello vim」または「hola vim」を検索する必要があるが、「salve vim」や「bonjour vim」は検索したくない場合、`|` パターンを使用できます。

次のテキストがあるとします：

```shell
hello vim
hola vim
salve vim
bonjour vim
```

"hello" と "hola" の両方に一致させるには、`/hello\|hola` を実行します。`|` 演算子はエスケープ（`\`）する必要があります。そうしないと、Vim はリテラル文字列 "|" を検索します。

毎回 `\|` を入力したくない場合は、検索の先頭に `magic` 構文（`\v`）を使用できます：`/\vhello|hola`。このガイドでは `magic` については説明しませんが、`\v` を使用すると、特別な文字をエスケープする必要がなくなります。`\v` について詳しく学びたい場合は、`:h \v` を確認してください。

## 一致の開始と終了を設定する

複合語の一部であるテキストを検索する必要があるかもしれません。次のテキストがあるとします：

```shell
11vim22
vim22
11vim
vim
```

"vim" を選択する必要があるが、"11" で始まり "22" で終わる場合、`\zs`（開始一致）と `\ze`（終了一致）演算子を使用できます。次のように実行します：

```shell
/11\zsvim\ze22
```

Vim はまだ "11vim22" の全体パターンに一致させる必要がありますが、` \zs ` と ` \ze ` の間に挟まれたパターンのみをハイライトします。別の例：

```shell
foobar
foobaz
```

"foobar" ではなく "foobaz" の "foo" に一致させる必要がある場合、次のように実行します：

```shell
/foo\zebaz
```

## 文字範囲の検索

これまでの検索語はすべてリテラル単語の検索でした。実際には、テキストを見つけるために一般的なパターンを使用する必要があるかもしれません。最も基本的なパターンは文字範囲 `[ ]` です。

任意の数字を検索する必要がある場合、毎回 `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0` と入力したくはないでしょう。代わりに、`/[0-9]` を使用して1桁の数字に一致させます。`0-9` の表現は、Vim が一致させようとする数字の範囲を表します。したがって、1から5の間の数字を探している場合は、`/[1-5]` を使用します。

数字だけでなく、Vim は他のデータ型も検索できます。小文字のアルファベットを検索するには `/[a-z]` を使用し、大文字のアルファベットを検索するには `/[A-Z]` を使用します。

これらの範囲を組み合わせることもできます。数字 0-9 と小文字および大文字のアルファベット "a" から "f" を検索する必要がある場合（16進数のように）、`/[0-9a-fA-F]` を使用できます。

否定検索を行うには、文字範囲のブラケット内に `^` を追加できます。非数字を検索するには、`/[^0-9]` を実行します。Vim は数字でない任意の文字に一致します。範囲ブラケット内のキャレット（`^`）は、行の先頭のキャレット（例：`/^hello`）とは異なることに注意してください。キャレットがブラケットのペアの外にあり、検索語の最初の文字である場合、それは「行の最初の文字」を意味します。キャレットがブラケットのペアの内側にあり、ブラケットの最初の文字である場合、それは否定検索演算子を意味します。`/^abc` は行の最初の "abc" に一致し、`/[^abc]` は "a"、"b"、または "c" 以外の任意の文字に一致します。

## 繰り返し文字の検索

次のテキストで二桁の数字を検索する必要がある場合：

```shell
1aa
11a
111
```

`/[0-9][0-9]` を使用して二桁の文字に一致させることができますが、この方法は拡張性がありません。20桁の数字に一致させる必要がある場合、`[0-9]` を20回入力するのは楽しい体験ではありません。だからこそ、`count` 引数が必要です。

検索に `count` を渡すことができます。以下の構文があります：

```shell
{n,m}
```

ちなみに、これらの `count` ブレースは、Vim で使用する際にエスケープする必要があります。`count` 演算子は、インクリメントしたい単一の文字の後に配置されます。

`count` 構文の4つの異なるバリエーションは次のとおりです：
- `{n}` は正確な一致です。`/[0-9]\{2\}` は二桁の数字 "11" と "111" の "11" に一致します。
- `{n,m}` は範囲一致です。`/[0-9]\{2,3\}` は2桁から3桁の数字に一致します："11" と "111"。
- `{,m}` は最大一致です。`/[0-9]\{,3\}` は最大3桁の数字に一致します："1"、"11"、"111"。
- `{n,}` は少なくとも一致です。`/[0-9]\{2,\}` は少なくとも2桁以上の数字に一致します："11" と "111"。

`count` 引数 `\{0,\}`（ゼロまたはそれ以上）と `\{1,\}`（1以上）は一般的な検索パターンであり、Vim にはそれらのための特別な演算子があります：`*` と `+`（`+` はエスケープが必要ですが、`*` はエスケープなしで問題ありません）。`/[0-9]*` を実行すると、`/[0-9]\{0,\}` と同じです。ゼロまたはそれ以上の数字を検索します。""、"1"、"123" に一致します。ちなみに、"a" の文字には技術的にゼロの数字が含まれているため、非数字にも一致します。`*` を使用する前に慎重に考えてください。`/[0-9]\+` を実行すると、`/[0-9]\{1,\}` と同じです。1つ以上の数字を検索します。"1" と "12" に一致します。

## 定義済みの文字範囲

Vim には、数字やアルファベットなどの一般的な文字のための定義済みの範囲があります。ここですべてを説明することはしませんが、完全なリストは `:h /character-classes` 内にあります。便利なものは次のとおりです：

```shell
\d    数字 [0-9]
\D    非数字 [^0-9]
\s    空白文字（スペースとタブ）
\S    非空白文字（スペースとタブ以外のすべて）
\w    単語文字 [0-9A-Za-z_]
\l    小文字アルファベット [a-z]
\u    大文字文字 [A-Z]
```

これらは文字範囲のように使用できます。任意の1桁の数字を検索するには、`/[0-9]` の代わりに `/\d` を使用できます。

## 検索例：類似した文字のペアで囲まれたテキストをキャプチャする

ダブルクォーテーションで囲まれたフレーズを検索したい場合：

```shell
"Vim is awesome!"
```

次のように実行します：

```shell
/"[^"]\+"
```

これを分解してみましょう：
- `"` はリテラルのダブルクォーテーションです。最初のダブルクォーテーションに一致します。
- `[^"]` はダブルクォーテーション以外の任意の文字を意味します。ダブルクォーテーションでない任意の英数字および空白文字に一致します。
- `\+` は1つ以上を意味します。`[^"]` に続くため、Vim はダブルクォーテーションでない1つ以上の文字を探します。
- `"` はリテラルのダブルクォーテーションです。閉じるダブルクォーテーションに一致します。

Vim が最初の `"` を見ると、パターンキャプチャが始まります。行の中で2番目のダブルクォーテーションを見ると、2番目の `"` パターンに一致し、パターンキャプチャを停止します。その間、ダブルクォーテーションでないすべての文字が `[^"]\+` パターンによってキャプチャされ、この場合、フレーズ `Vim is awesome!` になります。これは、類似した区切り文字で囲まれたフレーズをキャプチャするための一般的なパターンです。

- シングルクォーテーションで囲まれたフレーズをキャプチャするには、`/'[^']\+'` を使用できます。
- ゼロで囲まれたフレーズをキャプチャするには、`/0[^0]\+0` を使用できます。

## 検索例：電話番号をキャプチャする

ハイフン（`-`）で区切られた米国の電話番号（例：`123-456-7890`）に一致させたい場合、次のように使用できます：

```shell
/\d\{3\}-\d\{3\}-\d\{4\}
```

米国の電話番号は、3桁の数字のセット、次に別の3桁、最後に4桁の数字から構成されます。これを分解してみましょう：
- `\d\{3\}` は数字が正確に3回繰り返されることに一致します。
- `-` はリテラルのハイフンです。

エスケープを避けるために `\v` を使用できます：

```shell
/\v\d{3}-\d{3}-\d{4}
```

このパターンは、IP アドレスや郵便番号などの繰り返し数字をキャプチャするのにも便利です。

これで、この章の検索部分は終了です。次に置換に移りましょう。

## 基本的な置換

Vim の置換コマンドは、任意のパターンを迅速に見つけて置き換えるための便利なコマンドです。置換の構文は次のとおりです：

```shell
:s/{old-pattern}/{new-pattern}/
```

基本的な使用法から始めましょう。次のテキストがあるとします：

```shell
vim is
## 最後の置換を繰り返す

最後の置換コマンドを、通常のコマンド `&` または `:s` を実行することで繰り返すことができます。もし `:s/good/awesome/` を実行したばかりであれば、`&` または `:s` を実行することでそれを繰り返します。

また、この章の初めで、`//` を使って前の検索パターンを繰り返すことができると述べました。このトリックは置換コマンドでも機能します。もし `/good` が最近実行されていて、最初の置換パターン引数を空白にすると、`：s//awesome/` のように、`：s/good/awesome/` を実行するのと同じように機能します。

## 置換範囲

多くの Ex コマンドと同様に、置換コマンドに範囲引数を渡すことができます。構文は次の通りです：

```shell
:[range]s/old/new/
```

次の式があるとします：

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

行3から5の「let」を「const」に置換するには、次のようにします：

```shell
:3,5s/let/const/
```

渡すことができる範囲のバリエーションは以下の通りです：

- `:,3s/let/const/` - カンマの前に何も指定しない場合、現在の行を表します。現在の行から行3まで置換します。
- `:1,s/let/const/` - カンマの後に何も指定しない場合も、現在の行を表します。行1から現在の行まで置換します。
- `:3s/let/const/` - 範囲として1つの値のみが指定された場合（カンマなし）、その行のみで置換を行います。

Vimでは、`%` は通常ファイル全体を意味します。`:%s/let/const/` を実行すると、すべての行で置換が行われます。この範囲構文を覚えておいてください。今後の章で学ぶ多くのコマンドラインコマンドはこの形式に従います。

## パターンマッチング

次のセクションでは基本的な正規表現について説明します。強力なパターンの知識は、置換コマンドをマスターするために不可欠です。

次の式があるとします：

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

数字の周りにダブルクォーテーションを追加するには：

```shell
:%s/\d/"\0"/
```

結果は次の通りです：

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

コマンドを分解してみましょう：
- `:%s` はファイル全体を対象に置換を実行します。
- `\d` は数字のための Vim の事前定義された範囲です（`[0-9]` を使用するのと似ています）。
- `"\0"` ここでのダブルクォーテーションはリテラルのダブルクォーテーションです。`\0` は「完全に一致したパターン」を表す特別な文字です。ここで一致したパターンは単一の数字 `\d` です。

また、`&` も `\0` のように完全に一致したパターンを表します。`:s/\d/"&"/` も機能します。

別の例を考えてみましょう。次の式があり、すべての「let」を変数名と入れ替える必要があります。

```shell
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

それを行うには、次のように実行します：

```shell
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

上記のコマンドはバックスラッシュが多すぎて読みづらいです。この場合、`\v` 演算子を使用する方が便利です：

```shell
:%s/\v(\w+) (\w+)/\2 \1/
```

結果は次の通りです：

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

素晴らしい！そのコマンドを分解してみましょう：
- `:%s` はファイル内のすべての行を対象に置換を実行します。
- `(\w+) (\w+)` はグループマッチです。`\w` は Vim の事前定義された範囲の一つで、単語文字（`[0-9A-Za-z_]`）を表します。`( )` で囲まれた部分は、グループ内の単語文字の一致をキャプチャします。2つのグループの間のスペースに注意してください。`(\w+) (\w+)` は2つのグループをキャプチャします。最初のグループは「one」をキャプチャし、2番目のグループは「two」をキャプチャします。
- `\2 \1` はキャプチャされたグループを逆順で返します。`\2` はキャプチャされた文字列「let」を含み、`\1` は文字列「one」を含みます。` \2 \1` は「let one」という文字列を返します。

`\0` は完全に一致したパターンを表すことを思い出してください。マッチした文字列を小さなグループに分けることができます `( )` を使って。各グループは `\1`, `\2`, `\3` などで表されます。

このグループマッチの概念を固めるために、もう一つ例を見てみましょう。次の数字があるとします：

```shell
123
456
789
```

順序を逆にするには、次のように実行します：

```shell
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

結果は次の通りです：

```shell
321
654
987
```

各 `(\d)` は各数字にマッチし、グループを作成します。最初の行では、最初の `(\d)` の値は1、2番目の `(\d)` の値は2、3番目の `(\d)` の値は3です。これらは変数 `\1`, `\2`, `\3` に保存されます。置換の後半では、新しいパターン `\3\2\1` が1行目の「321」値を生成します。

もし次のように実行していたら：

```shell
:%s/\v(\d\d)(\d)/\2\1/
```
異なる結果が得られます：

```shell
312
645
978
```

これは、今や2つのグループしかないからです。最初のグループは `(\d\d)` でキャプチャされ、`\1` に保存され、値は12です。2番目のグループは `(\d)` でキャプチャされ、`\2` に保存され、値は3です。`\2\1` は312を返します。

## 置換フラグ

次の文があるとします：

```shell
chocolate pancake, strawberry pancake, blueberry pancake
```

すべてのパンケーキをドーナツに置換するには、次のように実行することはできません：

```shell
:s/pancake/donut
```

上記のコマンドは最初の一致のみを置換し、次のようになります：

```shell
chocolate donut, strawberry pancake, blueberry pancake
```

これを解決する方法は2つあります。置換コマンドをさらに2回実行するか、行内のすべての一致を置換するためにグローバル（`g`）フラグを渡すことができます。

グローバルフラグについて話しましょう。次のように実行します：

```shell
:s/pancake/donut/g
```

Vim はすべてのパンケーキをドーナツに一度のコマンドで置換します。グローバルコマンドは、置換コマンドが受け入れるいくつかのフラグの一つです。フラグは置換コマンドの末尾に渡します。以下は便利なフラグのリストです：

```shell
&    前の置換コマンドのフラグを再利用します。
g    行内のすべての一致を置換します。
c    置換確認を求めます。
e    置換が失敗したときにエラーメッセージを表示しないようにします。
i    大文字と小文字を区別しない置換を行います。
I    大文字と小文字を区別する置換を行います。
```

上記にリストされていないフラグもあります。すべてのフラグについては `:h s_flags` を確認してください。

ちなみに、繰り返し置換コマンド（`&` と `:s`）はフラグを保持しません。`&` を実行すると、`g` なしで `:s/pancake/donut/` を繰り返すだけです。すべてのフラグを持って最後の置換コマンドを迅速に繰り返すには、`:&&` を実行します。

## 区切り文字の変更

URLを長いパスで置き換える必要がある場合：

```shell
https://mysite.com/a/b/c/d/e
```

これを「hello」という単語に置換するには、次のように実行します：

```shell
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

しかし、どのスラッシュ（`/`）が置換パターンの一部で、どれが区切り文字であるかを判断するのは難しいです。任意の単一バイト文字（アルファベット、数字、`"`、`|`、および `\` を除く）で区切り文字を変更できます。これを `+` で置き換えましょう。上記の置換コマンドは次のように書き換えることができます：

```shell
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

これで、区切り文字がどこにあるかを見やすくなりました。

## 特殊置換

置換するテキストのケースを変更することもできます。次の式があり、変数「one」、「two」、「three」などを大文字にするタスクがあります。

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

次のように実行します：

```shell
:%s/\v(\w+) (\w+)/\1 \U\2/
```

次のようになります：

```shell
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

分解すると：
- `(\w+) (\w+)` は最初の2つの一致したグループをキャプチャします。「let」と「one」など。
- `\1` は最初のグループの値「let」を返します。
- `\U\2` は2番目のグループ（`\2`）を大文字にします。

このコマンドのトリックは、` \U\2` という表現です。`\U` は次の文字を大文字にするよう指示します。

もう一つ例を見てみましょう。Vimガイドを書いていて、行内の各単語の最初の文字を大文字にする必要があるとします。

```shell
vim is the greatest text editor in the whole galaxy
```

次のように実行できます：

```shell
:s/\<./\U&/g
```

結果は次の通りです：

```shell
Vim Is The Greatest Text Editor In The Whole Galaxy
```

分解すると：
- `:s` は現在の行を置換します。
- `\<.` は2つの部分で構成されています：`\<` は単語の開始を一致させ、`.` は任意の文字に一致します。`\<` 演算子は次の文字を単語の最初の文字にします。次の文字が `.` であるため、任意の単語の最初の文字に一致します。
- `\U&` は次の記号 `&` を大文字にします。`&`（または `\0`）は完全な一致を表します。任意の単語の最初の文字に一致します。
- `g` はグローバルフラグです。これがなければ、このコマンドは最初の一致のみを置換します。この行のすべての一致を置換する必要があります。

置換の特殊な置換シンボル（` \U` など）について詳しく学ぶには、`:h sub-replace-special` を確認してください。

## 代替パターン

時には、複数のパターンを同時に一致させる必要があります。次の挨拶があるとします：

```shell
hello vim
hola vim
salve vim
bonjour vim
```

「vim」を「friend」に置換する必要がありますが、「hello」または「hola」という単語を含む行のみです。この章の初めに述べたように、`|` を使用して複数の代替パターンを使用できます。

```shell
:%s/\v(hello|hola) vim/\1 friend/g
```

結果は次の通りです：

```shell
hello friend
hola friend
salve vim
bonjour vim
```

分解すると：
- `%s` はファイル内の各行で置換コマンドを実行します。
- `(hello|hola)` は「hello」または「hola」のいずれかに一致し、グループとして考慮します。
- `vim` はリテラルの単語「vim」です。
- `\1` は最初のグループで、テキスト「hello」または「hola」です。
- `friend` はリテラルの単語「friend」です。

## パターンの開始と終了を置換する

`\zs` と `\ze` を使用して一致の開始と終了を定義できることを思い出してください。このテクニックは置換でも機能します。次のような場合：

```shell
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

「hotcake」の「cake」を「dog」に置換して「hotdog」にするには：

```shell
:%s/hot\zscake/dog/g
```

結果：

```shell
chocolate pancake
strawberry sweetcake
blueberry hotdog
```
## 貪欲と非貪欲

行内のn番目の一致をこのトリックで置き換えることができます：

```shell
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

3番目の「Mississippi」を「Arkansas」に置き換えるには、次のコマンドを実行します：

```shell
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

内訳：
- `:s/` 置換コマンド。
- `\v` はマジックキーワードで、特殊キーワードをエスケープする必要がありません。
- `.` は任意の単一文字に一致します。
- `{-}` は前の原子の0個以上の非貪欲一致を行います。
- `\zsMississippi` は「Mississippi」を一致の開始点にします。
- `(...){3}` は3番目の一致を探します。

この章の前の部分で `{3}` 構文を見たことがあります。この場合、`{3}` は正確に3番目の一致に一致します。ここでの新しいトリックは `{-}` です。これは非貪欲一致です。与えられたパターンの最短一致を見つけます。この場合、`(.{-}Mississippi)` は任意の文字の前にある最小限の「Mississippi」に一致します。これを `(.*Mississippi)` と対比すると、与えられたパターンの最長一致を見つけます。

`(.{-}Mississippi)` を使用すると、5つの一致が得られます：「One Mississippi」、「Two Mississippi」など。`(.*Mississippi)` を使用すると、1つの一致が得られます：最後の「Mississippi」。`*` は貪欲マッチャーで、`{-}` は非貪欲マッチャーです。詳細を学ぶには `:h /\{-` と `:h non-greedy` を確認してください。

もっと簡単な例を見てみましょう。文字列が次のような場合：

```shell
abc1de1
```

「abc1de1」（貪欲）に一致させるには：

```shell
/a.*1
```

「abc1」（非貪欲）に一致させるには：

```shell
/a.\{-}1
```

最長一致（貪欲）を大文字にする必要がある場合は、次のコマンドを実行します：

```shell
:s/a.*1/\U&/g
```

次のようになります：

```shell
ABC1DEFG1
```

最短一致（非貪欲）を大文字にする必要がある場合は、次のコマンドを実行します：

```shell
:s/a.\{-}1/\U&/g
```

次のようになります：

```shell
ABC1defg1
```

貪欲対非貪欲の概念に不慣れな場合、理解するのが難しいことがあります。理解するまでさまざまな組み合わせで実験してみてください。

## 複数ファイルにわたる置換

最後に、複数のファイルにわたってフレーズを置き換える方法を学びましょう。このセクションでは、`food.txt` と `animal.txt` の2つのファイルがあると仮定します。

`food.txt` の中：

```shell
corndog
hotdog
chilidog
```

`animal.txt` の中：

```shell
large dog
medium dog
small dog
```

ディレクトリ構造は次のようになっていると仮定します：

```shell
- food.txt
- animal.txt
```

まず、`:args` 内に `food.txt` と `animal.txt` の両方をキャプチャします。以前の章から、`:args` はファイル名のリストを作成するために使用できることを思い出してください。Vim内からこれを実行する方法はいくつかありますが、その1つは次のように実行することです：

```shell
:args *.txt                  現在の場所のすべてのtxtファイルをキャプチャします
```

テストするために、`:args` を実行すると、次のように表示されるはずです：

```shell
[food.txt] animal.txt
```

関連するすべてのファイルが引数リストに保存されたので、`:argdo` コマンドを使用して複数ファイルの置換を実行できます。次のコマンドを実行します：

```shell
:argdo %s/dog/chicken/
```

これにより、`:args` リスト内のすべてのファイルに対して置換が行われます。最後に、変更されたファイルを次のコマンドで保存します：

```shell
:argdo update
```

`:args` と `:argdo` は、複数のファイルに対してコマンドラインコマンドを適用するための便利なツールです。他のコマンドでも試してみてください！

## マクロを使った複数ファイルにわたる置換

また、マクロを使用して複数のファイルにわたって置換コマンドを実行することもできます。次のコマンドを実行します：

```shell
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

内訳：
- `:args *.txt` はすべてのテキストファイルを `:args` リストに追加します。
- `qq` は「q」レジスタでマクロを開始します。
- `:%s/dog/chicken/g` は現在のファイルのすべての行で「dog」を「chicken」に置き換えます。
- `:wnext` はファイルを保存し、次のファイルに移動します。
- `q` はマクロの記録を停止します。
- `99@q` はマクロを99回実行します。Vimは最初のエラーに遭遇するとマクロの実行を停止するため、実際には99回マクロを実行しません。

## スマートな方法で検索と置換を学ぶ

検索をうまく行う能力は、編集において必要なスキルです。検索をマスターすることで、正規表現の柔軟性を利用してファイル内の任意のパターンを検索できます。これらを学ぶために時間をかけてください。正規表現に慣れるためには、積極的に正規表現を使用する必要があります。私は一度正規表現に関する本を読んだことがありますが、実際にやらなかったため、読んだことをほとんど忘れてしまいました。アクティブなコーディングがスキルをマスターする最良の方法です。

パターンマッチングスキルを向上させる良い方法は、パターンを検索する必要があるとき（例えば「hello 123」）、リテラル検索用語（`/hello 123`）をクエリする代わりに、それに対するパターンを考え出すことです（例えば `/\v(\l+) (\d+)` のように）。これらの正規表現の概念は、Vimを使用する際だけでなく、一般的なプログラミングにも適用可能です。

Vimでの高度な検索と置換について学んだので、最も多用途なコマンドの1つであるグローバルコマンドを学びましょう。