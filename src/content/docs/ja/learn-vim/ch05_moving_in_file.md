---
description: Vimの基本的な移動方法を学び、マウスよりも速くファイル内を効率的に移動できるようになるためのガイドです。
title: Ch05. Moving in a File
---

最初は、キーボードで移動するのは遅くて不器用に感じるかもしれませんが、あきらめないでください！慣れてしまえば、マウスを使うよりもファイル内を速く移動できます。

この章では、基本的な動作とそれを効率的に使う方法を学びます。これはVimが持つすべての動作ではないことを覚えておいてください。ここでの目標は、生産的になるために役立つ動作を紹介することです。もっと学びたい場合は、`:h motion.txt`をチェックしてください。

## 文字ナビゲーション

最も基本的な動作単位は、1文字左、下、上、右に移動することです。

```shell
h   左
j   下
k   上
l   右
gj  ソフトラップされた行で下
gk  ソフトラップされた行で上
```

方向キーを使って移動することもできます。始めたばかりの方は、自分が最も快適に感じる方法を自由に使ってください。

私は`hjkl`を好みます。右手がホームポジションに留まるからです。これにより、周囲のキーへの届きが短くなります。`hjkl`に慣れるために、実際に最初にこれを`~/.vimrc`に追加して矢印ボタンを無効にしました：

```shell
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

この悪い習慣を断つのを助けるプラグインもあります。その一つが [vim-hardtime](https://github.com/takac/vim-hardtime) です。驚いたことに、`hjkl`に慣れるのに1週間もかかりませんでした。

なぜVimが移動に`hjkl`を使うのか疑問に思うかもしれませんが、これはBill JoyがViを作成したLear-Siegler ADM-3A端末には矢印キーがなく、`hjkl`が左/下/上/右として使われていたからです。

## 相対番号

`number`と`relativenumber`を設定するのは便利だと思います。`.vimrc`にこれを追加することでできます：

```shell
set relativenumber number
```

これにより、現在の行番号と相対行番号が表示されます。

左の列に番号があることが便利なのは簡単に理解できますが、相対番号が左の列にあることがどのように便利か疑問に思う方もいるかもしれません。相対番号があることで、カーソルがターゲットテキストから何行離れているかをすぐに確認できます。これにより、ターゲットテキストが私の下に12行あることを簡単に見つけられるので、`d12j`で削除できます。そうでなければ、私が69行目にいてターゲットが81行目にある場合、私は計算をしなければなりません（81 - 69 = 12）。編集中に計算をするのは精神的リソースを多く消費します。どこに行く必要があるかを考える必要が少ないほど良いです。

これは100%個人的な好みです。`relativenumber` / `norelativenumber`、`number` / `nonumber`を試して、自分に最も役立つものを使ってください！

## 移動を数える

「カウント」引数について話しましょう。Vimの動作は前に数値引数を受け付けます。上で述べたように、`12j`で12行下に移動できます。`12j`の12がカウント数です。

カウントを動作に使うための構文は次の通りです：

```shell
[count] + motion
```

これはすべての動作に適用できます。右に9文字移動したい場合、`l`を9回押す代わりに、`9l`を使えます。

## 単語ナビゲーション

次は、より大きな動作単位である*単語*に移りましょう。次の単語の始まりに移動するには`w`、次の単語の終わりに移動するには`e`、前の単語の始まりに移動するには`b`、前の単語の終わりに移動するには`ge`を使用します。

さらに、*WORD*という単語とは異なるものがあります。次のWORDの始まりに移動するには`W`、次のWORDの終わりに移動するには`E`、前のWORDの始まりに移動するには`B`、前のWORDの終わりに移動するには`gE`を使用します。覚えやすくするために、WORDは単語と同じ文字を使用しますが、大文字です。

```shell
w     次の単語の始まりに前進する
W     次のWORDの始まりに前進する
e     次の単語の終わりに1単語前進する
E     次のWORDの終わりに1単語前進する
b     前の単語の始まりに後退する
B     前のWORDの始まりに後退する
ge    前の単語の終わりに後退する
gE    前のWORDの終わりに後退する
```

単語とWORDの類似点と相違点は何ですか？単語とWORDは空白文字で区切られています。単語は`a-zA-Z0-9_`のみを含む文字のシーケンスです。WORDは空白以外のすべての文字のシーケンスです（空白とはスペース、タブ、EOLを意味します）。詳細を学ぶには、`:h word`と`:h WORD`をチェックしてください。

例えば、次のようなコードがあるとします：

```shell
const hello = "world";
```

行の先頭にカーソルがある場合、`l`を使って行の終わりに移動すると、21回のキー操作が必要です。`w`を使うと6回で済みます。`W`を使うと4回で済みます。単語とWORDの両方は短距離を移動するのに良い選択肢です。

ただし、現在の行ナビゲーションを使えば、"c"から";"に1回のキー操作で移動できます。

## 現在の行ナビゲーション

編集中は、行内で水平に移動する必要がよくあります。現在の行の最初の文字にジャンプするには`0`を使用します。現在の行の最後の文字に移動するには`$`を使用します。さらに、`^`を使って現在の行の最初の非空白文字に移動し、`g_`を使って現在の行の最後の非空白文字に移動できます。現在の行の列`n`に移動したい場合は、`n|`を使えます。

```shell
0     現在の行の最初の文字に移動する
^     現在の行の最初の非空白文字に移動する
g_    現在の行の最後の非空白文字に移動する
$     現在の行の最後の文字に移動する
n|    現在の行の列nに移動する
```

`f`と`t`を使って現在の行を検索できます。`f`と`t`の違いは、`f`は一致の最初の文字に移動し、`t`は一致の最初の文字の手前まで移動します。したがって、"h"を検索して"h"に着地したい場合は`fh`を使用します。最初の"h"を検索して一致の手前に着地したい場合は`th`を使用します。最後の現在の行検索の*次の*出現に移動したい場合は`;`を使用します。最後の現在の行の一致の前の出現に移動したい場合は`,`を使用します。

`F`と`T`は`f`と`t`の後方対応です。"h"を後方に検索するには`Fh`を実行します。同じ方向で"h"を検索し続けるには`;`を使用します。`Fh`の後の`;`は後方検索を行い、`Fh`の後の`,`は前方検索を行います。

```shell
f    現在の行で一致を前方に検索する
F    現在の行で一致を後方に検索する
t    現在の行で一致を前方に検索し、一致の手前で止まる
T    現在の行で一致を後方に検索し、一致の手前で止まる
;    同じ方向で最後の検索を繰り返す
,    反対方向で最後の検索を繰り返す
```

前の例に戻ります：

```shell
const hello = "world";
```

行の先頭にカーソルがある場合、現在の行の最後の文字（";"）に1回のキー操作で移動できます：`$`。 "world"の"w"に移動したい場合は、`fw`を使用できます。行内のどこにでも移動するための良いヒントは、ターゲットの近くにある"j"、"x"、"z"のような最も一般的でない文字を探すことです。

## 文と段落のナビゲーション

次の2つのナビゲーション単位は文と段落です。

まず文とは何かについて話しましょう。文は、`.`、`!`、`?`のいずれかで終わり、その後にEOL、スペース、またはタブが続きます。次の文にジャンプするには`)`、前の文にジャンプするには`(`を使用します。

```shell
(    前の文にジャンプする
)    次の文にジャンプする
```

いくつかの例を見てみましょう。どのフレーズが文で、どれが文でないと思いますか？Vimで`(`と`)`を使ってナビゲーションしてみてください！

```shell
私は文です。私は別の文です。なぜなら、句点で終わるからです。感嘆符で終わるときもまだ文です！疑問符はどうですか？ハイフン - のため、私は文ではありません。また、セミコロン ; やコロン : もそうです。

私の上には空行があります。
```

ところで、`。`の後に単一行で区切られたフレーズをVimが文としてカウントしない問題がある場合、あなたは`'compatible'`モードにいるかもしれません。vimrcに`set nocompatible`を追加してください。Viでは、文は`.`の後に**2つ**のスペースが必要です。常に`nocompatible`を設定しておくべきです。

段落とは何かについて話しましょう。段落は各空行の後と、段落オプションで指定された文字のペアによって定義された段落マクロの各セットの後に始まります。

```shell
{    前の段落にジャンプする
}    次の段落にジャンプする
```

段落マクロが何か確信が持てない場合は心配しないでください。重要なのは、段落は空行の後に始まり、空行の後に終わるということです。これはほとんどの場合に当てはまります。

この例を見てみましょう。`}`と`{`を使ってナビゲーションしてみてください（また、文のナビゲーション`(`と`)`を使って移動してみてください！）

```shell
こんにちは。お元気ですか？私は元気です、ありがとう！
Vimは素晴らしいです。
最初は学ぶのが簡単ではないかもしれませんが、私たちは一緒にいます。頑張って！

再びこんにちは。

), (, }, {を使って移動してみてください。それらがどのように機能するか感じてみてください。
あなたはこれを成し遂げました。
```

詳細を学ぶには、`:h sentence`と`:h paragraph`をチェックしてください。

## マッチナビゲーション

プログラマーはコードを書き、編集します。コードは通常、括弧、波括弧、角括弧を使用します。それらの中で迷ってしまうことがあります。もしあなたがその中にいるなら、もう一方のペア（存在する場合）に`%`でジャンプできます。また、これを使って括弧、波括弧、角括弧が一致しているかどうかを確認できます。

```shell
%    別のマッチに移動する、通常は()、[]、{}
```

Schemeコードの例を見てみましょう。これは括弧を広範囲に使用します。異なる括弧の中で`%`を使って移動してみてください。

```shell
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

私は個人的に`%`を[vim-rainbow](https://github.com/frazrepo/vim-rainbow)のような視覚的インジケータプラグインで補完するのが好きです。詳細については、`:h %`をチェックしてください。

## 行番号ナビゲーション

行番号`n`にジャンプするには`nG`を使用します。例えば、7行目にジャンプしたい場合は`7G`を使用します。最初の行にジャンプするには、`1G`または`gg`を使用します。最後の行にジャンプするには`G`を使用します。

ターゲットが正確にどの行番号にあるかわからないことがよくありますが、全体のファイルの約70%にあることは知っています。この場合、`70%`を使用できます。ファイルの半分にジャンプするには`50%`を使用できます。

```shell
gg    最初の行に移動する
G     最後の行に移動する
nG    行nに移動する
n%    ファイルのn%に移動する
```

ところで、ファイル内の総行数を確認したい場合は、`Ctrl-g`を使用できます。

## ウィンドウナビゲーション

ウィンドウの*上部*、*中央*、または*下部*にすばやく移動するには、`H`、`M`、`L`を使用できます。

`H`と`L`にカウントを渡すこともできます。`10H`を使用すると、ウィンドウの上部から10行下に移動します。`3L`を使用すると、ウィンドウの最終行から3行上に移動します。

```shell
H     スクリーンの上部に移動する
M     スクリーンの中央に移動する
L     スクリーンの下部に移動する
nH    上からn行に移動する
nL    下からn行に移動する
```

## スクロール

スクロールするには、3つの速度の増分があります：フルスクリーン（`Ctrl-F/Ctrl-B`）、ハーフスクリーン（`Ctrl-D/Ctrl-U`）、および行（`Ctrl-E/Ctrl-Y`）。

```shell
Ctrl-E    1行下にスクロールする
Ctrl-D    半画面下にスクロールする
Ctrl-F    画面全体下にスクロールする
Ctrl-Y    1行上にスクロールする
Ctrl-U    半画面上にスクロールする
Ctrl-B    画面全体上にスクロールする
```

現在の行に対して相対的にスクロールすることもできます（画面をズームインする）：

```shell
zt    現在の行を画面の上部近くに持ってくる
zz    現在の行を画面の中央に持ってくる
zb    現在の行を画面の下部近くに持ってくる
```
## 検索ナビゲーション

ファイル内にフレーズが存在することがわかっている場合、検索ナビゲーションを使用して非常に迅速に目的地に到達できます。フレーズを検索するには、`/`を使用して前方に検索し、`?`を使用して後方に検索します。最後の検索を繰り返すには、`n`を使用します。最後の検索を反対方向に繰り返すには、`N`を使用します。

```shell
/    一致するものを前方に検索
?    一致するものを後方に検索
n    前回の検索と同じ方向で最後の検索を繰り返す
N    前回の検索の反対方向で最後の検索を繰り返す
```

次のテキストがあるとします：

```shell
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

"let"を検索する場合は、`/let`を実行します。再度"let"を迅速に検索するには、`n`を実行するだけです。反対方向に"let"を再度検索するには、`N`を実行します。`?let`を実行すると、"let"を後方に検索します。`n`を使用すると、今度は"let"を後方に検索します（`N`は今度は"let"を前方に検索します）。

`set hlsearch`を使用して検索ハイライトを有効にできます。これで、`/let`を検索すると、ファイル内の*すべての*一致するフレーズがハイライトされます。さらに、`set incsearch`を使用してインクリメンタル検索を設定できます。これにより、入力中にパターンがハイライトされます。デフォルトでは、一致するフレーズは別のフレーズを検索するまでハイライトされたままになります。これはすぐに煩わしさに変わる可能性があります。ハイライトを無効にするには、`:nohlsearch`または単に`:noh`を実行できます。このハイライトなし機能を頻繁に使用するため、vimrcにマップを作成しました：

```shell
nnoremap <esc><esc> :noh<return><esc>
```

カーソルの下のテキストを迅速に検索するには、`*`を使用して前方に検索し、`#`を使用して後方に検索します。カーソルが文字列"one"の上にある場合、`*`を押すと、`/\<one\>`を実行したのと同じになります。

`/\<one\>`の`\<`と`\>`は、単語全体の検索を意味します。より大きな単語の一部である場合、"one"とは一致しません。"one"という単語には一致しますが、"onetwo"には一致しません。カーソルが"one"の上にあり、"one"や"onetwo"のような単語全体または部分一致を前方に検索したい場合は、`*`の代わりに`g*`を使用する必要があります。

```shell
*     カーソルの下の単語を前方に検索
#     カーソルの下の単語を後方に検索
g*    カーソルの下の単語を前方に検索
g#    カーソルの下の単語を後方に検索
```

## 位置のマーク

マークを使用して現在の位置を保存し、後でその位置に戻ることができます。これはテキスト編集のためのブックマークのようなものです。`mx`を使用してマークを設定できます。ここで、`x`は任意のアルファベットの文字`a-zA-Z`です。マークに戻る方法は2つあります：正確（行と列）で` `x`、行単位で（`'x`）です。

```shell
ma    マーク"a"で位置をマーク
`a    行と列"a"にジャンプ
'a    行"a"にジャンプ
```

小文字（a-z）でのマークと大文字（A-Z）でのマークには違いがあります。小文字のアルファベットはローカルマークであり、大文字のアルファベットはグローバルマーク（時にはファイルマークとも呼ばれます）です。

ローカルマークについて話しましょう。各バッファには独自のローカルマークのセットを持つことができます。2つのファイルが開いている場合、最初のファイルでマーク"a"（`ma`）を設定し、2番目のファイルで別のマーク"a"（`ma`）を設定できます。

各バッファにマークのセットを持つことができるローカルマークとは異なり、グローバルマークは1セットしかありません。`myFile.txt`内で`mA`を設定すると、次回別のファイルで`mA`を実行すると、最初の"A"マークが上書きされます。グローバルマークの利点の1つは、完全に異なるプロジェクト内にいても、任意のグローバルマークにジャンプできることです。グローバルマークはファイルを越えて移動できます。

すべてのマークを表示するには、`:marks`を使用します。マークリストから、`a-zA-Z`以外のマークがあることに気付くかもしれません。それらのいくつかは：

```shell
''    ジャンプ前の現在のバッファ内の最後の行に戻る
``    ジャンプ前の現在のバッファ内の最後の位置に戻る
`[    以前に変更された/ヤンクされたテキストの先頭にジャンプ
`]    以前に変更された/ヤンクされたテキストの末尾にジャンプ
`<    最後の視覚選択の先頭にジャンプ
`>    最後の視覚選択の末尾にジャンプ
`0    vimを終了するときに最後に編集したファイルに戻る
```

上記にリストされているもの以外にもマークがあります。ここではあまり使用されないと思うのでカバーしませんが、興味がある場合は`:h marks`を確認してください。

## ジャンプ

Vimでは、いくつかの動作を使用して異なるファイルやファイルの異なる部分に「ジャンプ」できます。ただし、すべての動作がジャンプとしてカウントされるわけではありません。`j`で下に移動することはジャンプとしてカウントされません。`10G`で行10に移動することはジャンプとしてカウントされます。

Vimが「ジャンプ」コマンドと見なすコマンドは次のとおりです：

```shell
'       マークされた行に移動
`       マークされた位置に移動
G       行に移動
/       前方に検索
?       後方に検索
n       最後の検索を繰り返す、同じ方向
N       最後の検索を繰り返す、反対方向
%       一致を見つける
(       最後の文に移動
)       次の文に移動
{       最後の段落に移動
}       次の段落に移動
L       表示ウィンドウの最後の行に移動
M       表示ウィンドウの中央の行に移動
H       表示ウィンドウの最上行に移動
[[      前のセクションに移動
]]      次のセクションに移動
:s      置換
:tag    タグ定義にジャンプ
```

このリストを暗記することをお勧めしません。良いルールは、単語や現在の行のナビゲーションよりも遠くに移動する動作はおそらくジャンプであるということです。Vimは、移動中にどこにいたかを追跡し、`:jumps`内でこのリストを見ることができます。

詳細については、`:h jump-motions`を確認してください。

ジャンプはなぜ便利なのか？それは、`Ctrl-O`を使用してジャンプリストを上に移動し、`Ctrl-I`を使用してジャンプリストを下に移動できるからです。`hjkl`は「ジャンプ」コマンドではありませんが、移動の前に現在の位置をジャンプリストに手動で追加することができます。たとえば、`m'5j`は現在の位置をジャンプリストに追加し、5行下に移動し、`Ctrl-O`で戻ることができます。異なるファイル間でジャンプすることもでき、次の部分でさらに詳しく説明します。

## スマートな方法でナビゲーションを学ぶ

Vimに不慣れな場合、これは学ぶべきことが多いです。誰もがすぐにすべてを覚えることを期待していません。考えずに実行できるようになるまでには時間がかかります。

始める最良の方法は、いくつかの基本的な動作を暗記することだと思います。私は次の10の動作から始めることをお勧めします：`h, j, k, l, w, b, G, /, ?, n`。考えずに使用できるまで十分に繰り返してください。

ナビゲーションスキルを向上させるために、私の提案は次のとおりです：
1. 繰り返し行動に注意してください。`l`を繰り返し行っている自分に気づいたら、より早く前に進む動作を探してください。`w`を使用できることがわかります。`w`を繰り返し行っている自分に気づいたら、現在の行を迅速に横切る動作があるかどうかを確認してください。`f`を使用できることがわかります。必要を簡潔に説明できれば、Vimにはそれを行う方法がある可能性が高いです。
2. 新しい動作を学ぶたびに、考えずにできるまで時間をかけてください。

最後に、効果的であるためにすべてのVimコマンドを知る必要はないことを理解してください。ほとんどのVimユーザーはそうではありません。私もそうです。その時点でタスクを達成するのに役立つコマンドを学んでください。

時間をかけてください。ナビゲーションスキルはVimで非常に重要なスキルです。毎日1つの小さなことを学び、それをしっかり学んでください。