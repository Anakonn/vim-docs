---
description: این فصل به شما آموزش می‌دهد که چگونه فایل vimrc را سازماندهی و پیکربندی
  کنید و مکان‌های جستجوی Vim برای فایل vimrc را بررسی می‌کند.
title: Ch22. Vimrc
---

در فصل‌های قبلی، شما یاد گرفتید که چگونه از Vim استفاده کنید. در این فصل، شما یاد خواهید گرفت که چگونه vimrc را سازماندهی و پیکربندی کنید.

## Vim چگونه vimrc را پیدا می‌کند

حکمت متعارف برای vimrc این است که یک فایل dotfile با نام `.vimrc` در دایرکتوری خانگی `~/.vimrc` اضافه کنید (این ممکن است بسته به سیستم‌عامل شما متفاوت باشد).

در پس‌زمینه، Vim به چندین مکان برای فایل vimrc نگاه می‌کند. در اینجا مکان‌هایی که Vim بررسی می‌کند آورده شده است:
- `$VIMINIT`
- `$HOME/.vimrc`
- `$HOME/.vim/vimrc`
- `$EXINIT`
- `$HOME/.exrc`
- `$VIMRUNTIME/defaults.vim`

زمانی که شما Vim را شروع می‌کنید، آن به ترتیب بالا شش مکان را برای فایل vimrc بررسی می‌کند. اولین فایل vimrc پیدا شده استفاده خواهد شد و بقیه نادیده گرفته می‌شوند.

ابتدا Vim به دنبال `$VIMINIT` خواهد بود. اگر چیزی در آنجا نباشد، Vim به دنبال `$HOME/.vimrc` می‌گردد. اگر چیزی در آنجا نباشد، Vim به دنبال `$HOME/.vim/vimrc` می‌گردد. اگر Vim آن را پیدا کند، جستجو را متوقف کرده و از `$HOME/.vim/vimrc` استفاده خواهد کرد.

اولین مکان، `$VIMINIT`، یک متغیر محیطی است. به طور پیش‌فرض، تعریف نشده است. اگر می‌خواهید از `~/dotfiles/testvimrc` به عنوان مقدار `$VIMINIT` خود استفاده کنید، می‌توانید یک متغیر محیطی حاوی مسیر آن vimrc ایجاد کنید. پس از اجرای `export VIMINIT='let $MYVIMRC="$HOME/dotfiles/testvimrc" | source $MYVIMRC'`، Vim اکنون از `~/dotfiles/testvimrc` به عنوان فایل vimrc شما استفاده خواهد کرد.

دومین مکان، `$HOME/.vimrc`، مسیر متعارف برای بسیاری از کاربران Vim است. `$HOME` در بسیاری از موارد دایرکتوری خانگی شما (`~`) است. اگر شما یک فایل `~/.vimrc` دارید، Vim از این به عنوان فایل vimrc شما استفاده خواهد کرد.

سومین مکان، `$HOME/.vim/vimrc`، درون دایرکتوری `~/.vim` قرار دارد. شما ممکن است دایرکتوری `~/.vim` را برای پلاگین‌ها، اسکریپت‌های سفارشی یا فایل‌های View داشته باشید. توجه داشته باشید که در نام فایل vimrc نقطه‌ای وجود ندارد (`$HOME/.vim/.vimrc` کار نخواهد کرد، اما `$HOME/.vim/vimrc` کار خواهد کرد).

چهارمین مکان، `$EXINIT`، مشابه `$VIMINIT` عمل می‌کند.

پنجمین مکان، `$HOME/.exrc`، مشابه `$HOME/.vimrc` عمل می‌کند.

ششمین مکان، `$VIMRUNTIME/defaults.vim`، vimrc پیش‌فرضی است که با ساخت Vim شما همراه است. در مورد من، من Vim 8.2 را با استفاده از Homebrew نصب کرده‌ام، بنابراین مسیر من (`/usr/local/share/vim/vim82`) است. اگر Vim هیچ یک از شش فایل vimrc قبلی را پیدا نکند، از این فایل استفاده خواهد کرد.

برای بقیه این فصل، فرض می‌کنم که vimrc از مسیر `~/.vimrc` استفاده می‌کند.

## چه چیزی را در vimrc خود قرار دهم؟

سوالی که من زمانی که شروع کردم پرسیدم این بود: "چه چیزی باید در vimrc خود قرار دهم؟"

پاسخ این است: "هر چیزی که می‌خواهید". وسوسه کپی-پیست کردن vimrc دیگران واقعی است، اما شما باید در برابر آن مقاومت کنید. اگر اصرار دارید که از vimrc شخص دیگری استفاده کنید، مطمئن شوید که می‌دانید چه کاری انجام می‌دهد، چرا و چگونه او از آن استفاده می‌کند و مهم‌تر از همه، آیا برای شما مرتبط است یا خیر. فقط به این دلیل که کسی از آن استفاده می‌کند به این معنا نیست که شما هم از آن استفاده خواهید کرد.

## محتوای پایه vimrc

به طور خلاصه، یک vimrc مجموعه‌ای از:
- پلاگین‌ها
- تنظیمات
- توابع سفارشی
- دستورات سفارشی
- نگاشت‌ها

چیزهای دیگری نیز وجود دارد که در بالا ذکر نشده است، اما به طور کلی، این بیشتر موارد استفاده را پوشش می‌دهد.

### پلاگین‌ها

در فصل‌های قبلی، من پلاگین‌های مختلفی مانند [fzf.vim](https://github.com/junegunn/fzf.vim)، [vim-mundo](https://github.com/simnalamburt/vim-mundo) و [vim-fugitive](https://github.com/tpope/vim-fugitive) را ذکر کرده‌ام.

ده سال پیش، مدیریت پلاگین‌ها یک کابوس بود. با این حال، با ظهور مدیران پلاگین مدرن، نصب پلاگین‌ها اکنون می‌تواند در چند ثانیه انجام شود. من در حال حاضر از [vim-plug](https://github.com/junegunn/vim-plug) به عنوان مدیر پلاگین خود استفاده می‌کنم، بنابراین در این بخش از آن استفاده خواهم کرد. مفهوم باید با سایر مدیران پلاگین محبوب مشابه باشد. من به شدت توصیه می‌کنم که به بررسی دیگران بپردازید، مانند:
- [vundle.vim](https://github.com/VundleVim/Vundle.vim)
- [vim-pathogen](https://github.com/tpope/vim-pathogen)
- [dein.vim](https://github.com/Shougo/dein.vim)

مدیران پلاگین بیشتری نسبت به موارد ذکر شده در بالا وجود دارند، بنابراین احساس راحتی کنید و جستجو کنید. برای نصب vim-plug، اگر شما یک ماشین یونیکس دارید، دستور زیر را اجرا کنید:

```shell
curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```

برای افزودن پلاگین‌های جدید، نام‌های پلاگین خود را (`Plug 'github-username/repository-name'`) بین خطوط `call plug#begin()` و `call plug#end()` قرار دهید. بنابراین اگر می‌خواهید `emmet-vim` و `nerdtree` را نصب کنید، کد زیر را در vimrc خود قرار دهید:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

تغییرات را ذخیره کنید، آن را منبع‌سازی کنید (`:source %`)، و دستور `:PlugInstall` را برای نصب آن‌ها اجرا کنید.

در آینده اگر نیاز به حذف پلاگین‌های غیرقابل استفاده داشتید، فقط کافیست نام‌های پلاگین را از بلوک `call` حذف کنید، ذخیره کنید و منبع‌سازی کنید، و سپس دستور `:PlugClean` را برای حذف آن از ماشین خود اجرا کنید.

Vim 8 دارای مدیران بسته داخلی خود است. می‌توانید برای اطلاعات بیشتر به `:h packages` مراجعه کنید. در فصل بعد، به شما نشان می‌دهم که چگونه از آن استفاده کنید.

### تنظیمات

مشهور است که در هر vimrc تعداد زیادی گزینه `set` وجود دارد. اگر شما دستور set را از حالت خط فرمان اجرا کنید، این دائمی نیست. شما آن را زمانی که Vim را ببندید از دست خواهید داد. به عنوان مثال، به جای اجرای `:set relativenumber number` از حالت خط فرمان هر بار که Vim را اجرا می‌کنید، می‌توانید این‌ها را درون vimrc قرار دهید:

```shell
set relativenumber number
```

برخی از تنظیمات نیاز دارند که شما یک مقدار به آن‌ها بدهید، مانند `set tabstop=2`. به صفحه کمک برای هر تنظیم مراجعه کنید تا یاد بگیرید چه نوع مقادیری را می‌پذیرد.

شما همچنین می‌توانید از `let` به جای `set` استفاده کنید (مطمئن شوید که با `&` پیشوند دارد). با `let`، می‌توانید از یک عبارت به عنوان مقدار استفاده کنید. به عنوان مثال، برای تنظیم گزینه `'dictionary'` به یک مسیر فقط در صورتی که مسیر وجود داشته باشد:

```shell
let s:english_dict = "/usr/share/dict/words"

if filereadable(s:english_dict)
  let &dictionary=s:english_dict
endif
```

شما در فصل‌های بعدی با انتساب‌ها و شرط‌های Vimscript آشنا خواهید شد.

برای لیستی از تمام گزینه‌های ممکن در Vim، به `:h E355` مراجعه کنید.

### توابع سفارشی

vimrc مکان خوبی برای توابع سفارشی است. شما در فصل بعدی یاد خواهید گرفت که چگونه توابع Vimscript خود را بنویسید.

### دستورات سفارشی

شما می‌توانید یک دستور خط فرمان سفارشی با `command` ایجاد کنید.

برای ایجاد یک دستور پایه `GimmeDate` برای نمایش تاریخ امروز:

```shell
:command! GimmeDate echo call("strftime", ["%F"])
```

زمانی که شما `:GimmeDate` را اجرا می‌کنید، Vim تاریخی مانند "2021-01-1" نمایش خواهد داد.

برای ایجاد یک دستور پایه با ورودی، می‌توانید از `<args>` استفاده کنید. اگر می‌خواهید یک فرمت زمان/تاریخ خاص را به `GimmeDate` منتقل کنید:

```shell
:command! GimmeDate echo call("strftime", [<args>])

:GimmeDate "%F"
" 2020-01-01

:GimmeDate "%H:%M"
" 11:30
```

اگر می‌خواهید تعداد آرگومان‌ها را محدود کنید، می‌توانید از فلگ `-nargs` استفاده کنید. از `-nargs=0` برای عدم ارسال آرگومان، `-nargs=1` برای ارسال یک آرگومان، `-nargs=+` برای ارسال حداقل یک آرگومان، `-nargs=*` برای ارسال هر تعداد آرگومان و `-nargs=?` برای ارسال 0 یا یک آرگومان استفاده کنید. اگر می‌خواهید آرگومان nام را ارسال کنید، از `-nargs=n` استفاده کنید (که در آن `n` هر عدد صحیحی است).

`<args>` دو نوع دارد: `<f-args>` و `<q-args>`. نوع اول برای ارسال آرگومان‌ها به توابع Vimscript استفاده می‌شود. نوع دوم برای تبدیل خودکار ورودی کاربر به رشته‌ها استفاده می‌شود.

استفاده از `args`:

```shell
:command! -nargs=1 Hello echo "Hello " . <args>
:Hello "Iggy"
" returns 'Hello Iggy'

:Hello Iggy
" Undefined variable error
```

استفاده از `q-args`:

```shell
:command! -nargs=1 Hello echo "Hello " . <q-args>
:Hello Iggy
" returns 'Hello Iggy'
```

استفاده از `f-args`:

```shell
:function! PrintHello(person1, person2)
:  echo "Hello " . a:person1 . " and " . a:person2
:endfunction

:command! -nargs=* Hello call PrintHello(<f-args>)

:Hello Iggy1 Iggy2
" returns "Hello Iggy1 and Iggy2"
```

توابع بالا زمانی که به فصل توابع Vimscript برسید، بیشتر معنا پیدا خواهند کرد.

برای یادگیری بیشتر در مورد دستورات و args، به `:h command` و `:args` مراجعه کنید.
### نقشه‌ها

اگر متوجه شدید که به طور مکرر همان کار پیچیده را انجام می‌دهید، این یک نشانه خوب است که باید برای آن کار یک نقشه ایجاد کنید.

برای مثال، من این دو نقشه را در vimrc خود دارم:

```shell
nnoremap <silent> <C-f> :GFiles<CR>

nnoremap <Leader>tn :call ToggleNumber()<CR>
```

در اولی، من `Ctrl-F` را به فرمان `:Gfiles` از پلاگین [fzf.vim](https://github.com/junegunn/fzf.vim) متصل می‌کنم (برای جستجوی سریع فایل‌های Git). در دومی، من `<Leader>tn` را به فراخوانی یک تابع سفارشی `ToggleNumber` متصل می‌کنم (که گزینه‌های `norelativenumber` و `relativenumber` را تغییر می‌دهد). نقشه `Ctrl-F` عملکرد پیمایش صفحه اصلی Vim را بازنویسی می‌کند. نقشه شما در صورتی که با کنترل‌های Vim تداخل داشته باشد، آن‌ها را بازنویسی می‌کند. چون من تقریباً هرگز از آن ویژگی استفاده نکردم، تصمیم گرفتم که بازنویسی آن بی‌خطر است.

راستی، این کلید "لیدر" در `<Leader>tn` چیست؟

Vim یک کلید ليدر دارد تا به نقشه‌ها کمک کند. برای مثال، من `<Leader>tn` را برای اجرای تابع `ToggleNumber()` متصل کرده‌ام. بدون کلید ليدر، من باید از `tn` استفاده می‌کردم، اما Vim قبلاً `t` (برای جستجوی "تا") را دارد. با کلید ليدر، اکنون می‌توانم کلیدی که به عنوان ليدر تعیین شده است را فشار دهم، سپس `tn` را بدون تداخل با دستورات موجود فشار دهم. کلید ليدر کلیدی است که می‌توانید برای شروع ترکیب نقشه خود تنظیم کنید. به طور پیش‌فرض، Vim از بک‌اسلش به عنوان کلید ليدر استفاده می‌کند (بنابراین `<Leader>tn` به "بک‌اسلش-t-n" تبدیل می‌شود).

من شخصاً دوست دارم از `<Space>` به عنوان کلید ليدر به جای بک‌اسلش پیش‌فرض استفاده کنم. برای تغییر کلید ليدر خود، این را به vimrc خود اضافه کنید:

```shell
let mapleader = "\<space>"
```

فرمان `nnoremap` که در بالا استفاده شده است می‌تواند به سه بخش تقسیم شود:
- `n` نمایانگر حالت عادی است.
- `nore` به معنای غیر بازگشتی است.
- `map` فرمان نقشه است.

حداقل، می‌توانستید به جای `nnoremap` از `nmap` استفاده کنید (`nmap <silent> <C-f> :Gfiles<CR>`). با این حال، استفاده از نسخه غیر بازگشتی یک عمل خوب است تا از حلقه‌های بی‌نهایت احتمالی جلوگیری شود.

این ممکن است اتفاق بیفتد اگر شما غیر بازگشتی نقشه نزنید. فرض کنید می‌خواهید یک نقشه به `B` اضافه کنید تا یک نقطه‌ویرگول در انتهای خط اضافه کند و سپس به یک WORD برگردد (به یاد داشته باشید که `B` در Vim یک کلید ناوبری در حالت عادی برای بازگشت به یک WORD است).

```shell
nmap B A;<esc>B
```

وقتی `B` را فشار می‌دهید... اوه نه! Vim به طور غیرقابل کنترلی `;` را اضافه می‌کند (با `Ctrl-C` آن را متوقف کنید). چرا این اتفاق افتاد؟ زیرا در نقشه `A;<esc>B`، `B` به عملکرد بومی `B` در Vim (بازگشت به یک WORD) اشاره نمی‌کند، بلکه به تابع نقشه‌گذاری شده اشاره دارد. آنچه شما دارید در واقع این است:

```shell
A;<esc>A;<esc>A;<esc>A;esc>...
```

برای حل این مشکل، شما نیاز به اضافه کردن یک نقشه غیر بازگشتی دارید:

```shell
nnoremap B A;<esc>B
```

اکنون دوباره سعی کنید `B` را فراخوانی کنید. این بار به درستی یک `;` در انتهای خط اضافه می‌کند و به یک WORD برمی‌گردد. `B` در این نقشه نمایانگر عملکرد اصلی `B` در Vim است.

Vim نقشه‌های مختلفی برای حالت‌های مختلف دارد. اگر می‌خواهید یک نقشه برای حالت وارد کردن ایجاد کنید تا هنگام فشار دادن `jk` از حالت وارد کردن خارج شوید:

```shell
inoremap jk <esc>
```

سایر حالت‌های نقشه عبارتند از: `map` (عادی، بصری، انتخاب و در حال انتظار عملگر)، `vmap` (بصری و انتخاب)، `smap` (انتخاب)، `xmap` (بصری)، `omap` (در حال انتظار عملگر)، `map!` (وارد کردن و خط فرمان)، `lmap` (وارد کردن، خط فرمان، Lang-arg)، `cmap` (خط فرمان) و `tmap` (کار ترمینال). من آن‌ها را به تفصیل پوشش نمی‌دهم. برای یادگیری بیشتر، به `:h map.txt` مراجعه کنید.

نقشه‌ای ایجاد کنید که شهودی‌ترین، سازگارترین و به یاد ماندنی‌ترین باشد.

## سازماندهی Vimrc

با گذشت زمان، vimrc شما بزرگ می‌شود و پیچیده می‌شود. دو راه برای نگه‌داشتن vimrc شما به شکل تمیز وجود دارد:
- تقسیم vimrc خود به چندین فایل.
- تا کردن فایل vimrc خود.

### تقسیم Vimrc شما

شما می‌توانید vimrc خود را به چندین فایل با استفاده از فرمان `source` Vim تقسیم کنید. این فرمان دستورات خط فرمان را از آرگومان فایل داده شده می‌خواند.

بیایید یک فایل در دایرکتوری `~/.vim` ایجاد کنیم و آن را `/settings` نام‌گذاری کنیم (`~/.vim/settings`). نام خود به خود دلخواه است و می‌توانید آن را هر طور که می‌خواهید نام‌گذاری کنید.

شما قرار است آن را به چهار بخش تقسیم کنید:
- پلاگین‌های شخص ثالث (`~/.vim/settings/plugins.vim`).
- تنظیمات عمومی (`~/.vim/settings/configs.vim`).
- توابع سفارشی (`~/.vim/settings/functions.vim`).
- نقشه‌های کلید (`~/.vim/settings/mappings.vim`).

درون `~/.vimrc`:

```shell
source $HOME/.vim/settings/plugins.vim
source $HOME/.vim/settings/configs.vim
source $HOME/.vim/settings/functions.vim
source $HOME/.vim/settings/mappings.vim
```

شما می‌توانید این فایل‌ها را با قرار دادن نشانگر خود زیر مسیر و فشار دادن `gf` ویرایش کنید.

درون `~/.vim/settings/plugins.vim`:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

درون `~/.vim/settings/configs.vim`:

```shell
set nocompatible
set relativenumber
set number
```

درون `~/.vim/settings/functions.vim`:

```shell
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
```

درون `~/.vim/settings/mappings.vim`:

```shell
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
```

vimrc شما باید به طور معمول کار کند، اما اکنون فقط چهار خط طول دارد!

با این تنظیمات، شما به راحتی می‌دانید کجا بروید. اگر نیاز به اضافه کردن نقشه‌های بیشتری دارید، آن‌ها را به فایل `/mappings.vim` اضافه کنید. در آینده، شما همیشه می‌توانید دایرکتوری‌های بیشتری را به عنوان vimrc شما بزرگ می‌شود اضافه کنید. برای مثال، اگر نیاز به ایجاد یک تنظیم برای رنگ‌های خود دارید، می‌توانید یک `~/.vim/settings/themes.vim` اضافه کنید.

### نگه‌داشتن یک فایل Vimrc

اگر ترجیح می‌دهید یک فایل vimrc را برای نگه‌داشتن آن قابل حمل نگه دارید، می‌توانید از تا کردن علامت‌ها برای سازماندهی آن استفاده کنید. این را در بالای vimrc خود اضافه کنید:

```shell
" تنظیم تاها {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}
```

Vim می‌تواند تشخیص دهد که نوع فایل فعلی بافر چیست (`:set filetype?`). اگر نوع فایل `vim` باشد، می‌توانید از روش تا کردن علامت استفاده کنید. به یاد داشته باشید که یک تا کردن علامت از `{{{` و `}}}` برای نشان دادن شروع و پایان تاها استفاده می‌کند.

به بقیه vimrc خود `{{{` و `}}}` تاها را اضافه کنید (فراموش نکنید که آن‌ها را با `"` کامنت کنید):

```shell
" تنظیم تاها {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

" پلاگین‌ها {{{
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
" }}}

" تنظیمات {{{
set nocompatible
set relativenumber
set number
" }}}

" توابع {{{
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
" }}}

" نقشه‌ها {{{
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
" }}}
```

vimrc شما باید به این شکل باشد:

```shell
+-- 6 خط: تنظیم تاها -----

+-- 6 خط: پلاگین‌ها ---------

+-- 5 خط: تنظیمات ---------

+-- 9 خط: توابع -------

+-- 5 خط: نقشه‌ها --------
```

## اجرای Vim با یا بدون Vimrc و پلاگین‌ها

اگر نیاز به اجرای Vim بدون هر دو vimrc و پلاگین‌ها دارید، اجرا کنید:

```shell
vim -u NONE
```

اگر نیاز به راه‌اندازی Vim بدون vimrc اما با پلاگین‌ها دارید، اجرا کنید:

```shell
vim -u NORC
```

اگر نیاز به اجرای Vim با vimrc اما بدون پلاگین‌ها دارید، اجرا کنید:

```shell
vim --noplugin
```

اگر نیاز به اجرای Vim با یک vimrc *مختلف*، مثلاً `~/.vimrc-backup` دارید، اجرا کنید:

```shell
vim -u ~/.vimrc-backup
```

اگر نیاز به اجرای Vim با تنها `defaults.vim` و بدون پلاگین‌ها دارید، که برای تعمیر vimrc خراب مفید است، اجرا کنید:

```shell
vim --clean
```

## تنظیم Vimrc به روش هوشمند

Vimrc یک جزء مهم از سفارشی‌سازی Vim است. یک راه خوب برای شروع ساختن vimrc خود، خواندن vimrc‌های دیگران و به تدریج ساختن آن در طول زمان است. بهترین vimrc نه آن است که توسعه‌دهنده X از آن استفاده می‌کند، بلکه آن است که دقیقاً متناسب با چارچوب تفکر و سبک ویرایش شما طراحی شده است.