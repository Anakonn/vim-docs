---
description: این مستند به بررسی پلاگین `totitle-vim` می‌پردازد که برای تبدیل عناوین
  به حالت عنوانی در ویم طراحی شده است و روند ساخت آن را توضیح می‌دهد.
title: 'Ch29. Write a Plugin: Creating a Titlecase Operator'
---

وقتی که شروع به یادگیری Vim می‌کنید، ممکن است بخواهید پلاگین‌های خود را بنویسید. من به تازگی اولین پلاگین Vim خود را نوشتم، [totitle-vim](https://github.com/iggredible/totitle-vim). این یک پلاگین اپراتور برای عنوان‌گذاری است، مشابه اپراتورهای بزرگ‌نویسی `gU`، کوچک‌نویسی `gu` و تغییر حالت `g~` در Vim.

در این فصل، تجزیه و تحلیل پلاگین `totitle-vim` را ارائه می‌دهم. امیدوارم که بتوانم کمی روشنایی بر روی این فرآیند بیفکنم و شاید شما را به ایجاد پلاگین منحصر به فرد خودتان الهام بخشم!

## مشکل

من از Vim برای نوشتن مقالاتم، از جمله همین راهنما استفاده می‌کنم.

یکی از مشکلات اصلی ایجاد حالت عنوان مناسب برای سرعنوان‌ها بود. یکی از راه‌های خودکار کردن این کار، بزرگ‌نویسی هر کلمه در سرعنوان با استفاده از `g/^#/ s/\<./\u\0/g` است. برای استفاده‌ی پایه، این دستور کافی بود، اما هنوز به خوبی داشتن یک حالت عنوان واقعی نیست. کلمات "The" و "Of" در "Capitalize The First Letter Of Each Word" باید بزرگ‌نویسی شوند. بدون بزرگ‌نویسی مناسب، جمله کمی نادرست به نظر می‌رسد.

در ابتدا، برنامه‌ای برای نوشتن یک پلاگین نداشتم. همچنین مشخص شد که یک پلاگین عنوان‌گذاری وجود دارد: [vim-titlecase](https://github.com/christoomey/vim-titlecase). با این حال، چند چیز وجود داشت که به طرز دلخواه من عمل نمی‌کردند. اصلی‌ترین آن رفتار حالت بصری بلوکی بود. اگر عبارت زیر را داشته باشم:

```shell
test title one
test title two
test title three
```

اگر از هایلایت بصری بلوکی بر روی "tle" استفاده کنم:

```shell
test ti[tle] one
test ti[tle] two
test ti[tle] three
```

اگر `gt` را فشار دهم، پلاگین آن را بزرگ‌نویسی نمی‌کند. این رفتار با رفتارهای `gu`، `gU` و `g~` سازگار نیست. بنابراین تصمیم گرفتم از آن مخزن پلاگین عنوان‌گذاری استفاده کنم و خودم یک پلاگین عنوان‌گذاری بسازم که با `gu`، `gU` و `g~` سازگار باشد! دوباره، پلاگین vim-titlecase خود یک پلاگین عالی است و ارزش استفاده مستقل را دارد (واقعیت این است که شاید در عمق وجودم فقط می‌خواستم پلاگین Vim خودم را بنویسم. واقعاً نمی‌توانم ببینم که ویژگی عنوان‌گذاری بلوکی در زندگی واقعی به جز موارد خاص چقدر استفاده می‌شود).

### برنامه‌ریزی برای پلاگین

قبل از نوشتن اولین خط کد، باید تصمیم بگیرم که قوانین عنوان‌گذاری چیست. من یک جدول جالب از قوانین مختلف بزرگ‌نویسی از سایت [titlecaseconverter](https://titlecaseconverter.com/rules/) پیدا کردم. آیا می‌دانستید که حداقل 8 قانون بزرگ‌نویسی مختلف در زبان انگلیسی وجود دارد؟ *آه!*

در نهایت، من از کمترین مشترک‌های آن لیست برای ایجاد یک قانون پایه خوب برای پلاگین استفاده کردم. بعلاوه، شک دارم که مردم شکایت کنند، "هی مرد، تو از AMA استفاده می‌کنی، چرا از APA استفاده نمی‌کنی؟". اینجا قوانین پایه هستند:
- اولین کلمه همیشه بزرگ‌نویسی می‌شود.
- برخی قیدها، حرف‌های ربط و حروف اضافه کوچک‌نویسی می‌شوند.
- اگر کلمه ورودی کاملاً بزرگ‌نویسی شده باشد، پس هیچ کاری انجام ندهید (ممکن است یک اختصار باشد).

در مورد اینکه کدام کلمات کوچک‌نویسی می‌شوند، قوانین مختلف لیست‌های مختلفی دارند. من تصمیم گرفتم با `a an and at but by en for in nor of off on or out per so the to up yet vs via` بمانم.

### برنامه‌ریزی برای رابط کاربری

من می‌خواهم پلاگین به عنوان یک اپراتور باشد تا اپراتورهای موجود در Vim را تکمیل کند: `gu`، `gU` و `g~`. به عنوان یک اپراتور، باید یا یک حرکت یا یک شیء متنی را بپذیرد (`gtw` باید کلمه بعدی را عنوان‌گذاری کند، `gtiw` باید کلمه داخلی را عنوان‌گذاری کند، `gt$` باید کلمات را از مکان فعلی تا انتهای خط عنوان‌گذاری کند، `gtt` باید خط فعلی را عنوان‌گذاری کند، `gti(` باید کلمات داخل پرانتز را عنوان‌گذاری کند و غیره). همچنین می‌خواهم آن را به `gt` برای یادآوری آسان نگاشت کنم. علاوه بر این، باید با تمام حالت‌های بصری کار کند: `v`، `V` و `Ctrl-V`. باید بتوانم آن را در *هر* حالت بصری هایلایت کنم، `gt` را فشار دهم، سپس تمام متون هایلایت شده عنوان‌گذاری می‌شوند.

## زمان اجرای Vim

اولین چیزی که وقتی به مخزن نگاه می‌کنید می‌بینید این است که دو دایرکتوری دارد: `plugin/` و `doc/`. وقتی شما Vim را شروع می‌کنید، به دنبال فایل‌ها و دایرکتوری‌های خاصی در دایرکتوری `~/.vim` می‌گردد و تمام فایل‌های اسکریپت داخل آن دایرکتوری را اجرا می‌کند. برای اطلاعات بیشتر، فصل زمان اجرای Vim را بررسی کنید.

این پلاگین از دو دایرکتوری زمان اجرای Vim استفاده می‌کند: `doc/` و `plugin/`. `doc/` جایی برای قرار دادن مستندات کمک است (تا بتوانید بعداً برای کلمات کلیدی جستجو کنید، مانند `:h totitle`). بعداً در مورد نحوه ایجاد یک صفحه کمک صحبت می‌کنم. فعلاً بیایید بر روی `plugin/` تمرکز کنیم. دایرکتوری `plugin/` یک بار هنگام راه‌اندازی Vim اجرا می‌شود. یک فایل در این دایرکتوری وجود دارد: `totitle.vim`. نامگذاری مهم نیست (می‌توانستم آن را `whatever.vim` بنامم و هنوز هم کار می‌کند). تمام کدی که مسئول کارکرد پلاگین است در این فایل قرار دارد.

## نگاشت‌ها

بیایید به کد نگاهی بیندازیم!

در ابتدای فایل، شما دارید:

```shell
if !exists('g:totitle_default_keys')
  let g:totitle_default_keys = 1
endif
```

وقتی شما Vim را شروع می‌کنید، `g:totitle_default_keys` هنوز وجود ندارد، بنابراین `!exists(...)` درست برمی‌گردد. در این صورت، `g:totitle_default_keys` را برابر با 1 تعریف کنید. در Vim، 0 نادرست و غیر صفر درست است (از 1 برای نشان دادن درست بودن استفاده کنید).

بیایید به انتهای فایل برویم. شما این را خواهید دید:

```shell
if g:totitle_default_keys
  nnoremap <expr> gt ToTitle()
  xnoremap <expr> gt ToTitle()
  nnoremap <expr> gtt ToTitle() .. '_'
endif
```

اینجا جایی است که نگاشت اصلی `gt` تعریف می‌شود. در این حالت، تا زمانی که به شرایط `if` در انتهای فایل برسید، `if g:totitle_default_keys` برابر با 1 (درست) خواهد بود، بنابراین Vim نگاشت‌های زیر را انجام می‌دهد:
- `nnoremap <expr> gt ToTitle()` اپراتور حالت عادی را نگاشت می‌کند. این به شما اجازه می‌دهد اپراتور + حرکت/شیء متنی را مانند `gtw` برای عنوان‌گذاری کلمه بعدی یا `gtiw` برای عنوان‌گذاری کلمه داخلی اجرا کنید. بعداً جزئیات نحوه کارکرد نگاشت اپراتور را بررسی می‌کنم.
- `xnoremap <expr> gt ToTitle()` اپراتورهای حالت بصری را نگاشت می‌کند. این به شما اجازه می‌دهد متون هایلایت شده بصری را عنوان‌گذاری کنید.
- `nnoremap <expr> gtt ToTitle() .. '_'` اپراتور خطی حالت عادی را نگاشت می‌کند (معادل `guu` و `gUU`). ممکن است بپرسید `.. '_'` در انتها چه کاری انجام می‌دهد. `..` اپراتور تداخل رشته‌ای Vim است. `_` به عنوان یک حرکت با اپراتور استفاده می‌شود. اگر به `:help _` نگاه کنید، می‌گوید که زیرخط برای شمارش یک خط به سمت پایین استفاده می‌شود. این اپراتور را بر روی خط فعلی اجرا می‌کند (این را با اپراتورهای دیگر امتحان کنید، سعی کنید `gU_` یا `d_` را اجرا کنید، متوجه می‌شوید که همانند `gUU` یا `dd` عمل می‌کند).
- در نهایت، آرگومان `<expr>` به شما اجازه می‌دهد تا شمارش را مشخص کنید، بنابراین می‌توانید `3gtw` را برای تغییر حالت سه کلمه بعدی انجام دهید.

اگر نمی‌خواهید از نگاشت پیش‌فرض `gt` استفاده کنید چه؟ در نهایت، شما نگاشت پیش‌فرض `gt` (تب بعدی) Vim را بازنویسی می‌کنید. اگر بخواهید به جای `gt` از `gz` استفاده کنید چه؟ به یاد دارید که چگونه به زحمت بررسی کردید `if !exists('g:totitle_default_keys')` و `if g:totitle_default_keys`؟ اگر `let g:totitle_default_keys = 0` را در vimrc خود قرار دهید، آنگاه `g:totitle_default_keys` هنگام اجرای پلاگین از قبل وجود خواهد داشت (کدهای موجود در vimrc قبل از فایل‌های زمان اجرای `plugin/` اجرا می‌شوند)، بنابراین `!exists('g:totitle_default_keys')` نادرست برمی‌گردد. علاوه بر این، `if g:totitle_default_keys` نادرست خواهد بود (زیرا مقدار 0 خواهد داشت)، بنابراین همچنین نگاشت `gt` را انجام نخواهد داد! این به شما اجازه می‌دهد تا نگاشت سفارشی خود را در Vimrc تعریف کنید.

برای تعریف نگاشت عنوان‌گذاری خود به `gz`، این را در vimrc خود اضافه کنید:

```shell
let g:totitle_default_keys = 0

nnoremap <expr> gz ToTitle()
xnoremap <expr> gz ToTitle()
nnoremap <expr> gzz ToTitle() .. '_'
```

خیلی آسان است.

## تابع ToTitle

تابع `ToTitle()` به راحتی طولانی‌ترین تابع در این فایل است.

```shell
 function! ToTitle(type = '')
  if a:type ==# ''
    set opfunc=ToTitle
    return 'g@'
  endif

  " invoke this when calling the ToTitle() function
  if a:type != 'block' && a:type != 'line' && a:type != 'char'
    let l:words = a:type
    let l:wordsArr = trim(l:words)->split('\s\+')
    call map(l:wordsArr, 's:capitalize(v:val)')
    return l:wordsArr->join(' ')
  endif

  " save the current settings
  let l:sel_save = &selection
  let l:reg_save = getreginfo('"')
  let l:cb_save = &clipboard
  let l:visual_marks_save = [getpos("'<"), getpos("'>")]

  try
    set clipboard= selection=inclusive
    let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
    let l:selected_phrase = getreg('"')
    let l:WORD_PATTERN = '\<\k*\>'
    let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

    let l:startLine = line("'<")
    let l:startCol = virtcol(".")

    " when user calls a block operation
    if a:type ==# "block"
      sil! keepj norm! gv"ad
      keepj $
      keepj pu_

      let l:lastLine = line("$")

      sil! keepj norm "ap

      let l:curLine = line(".")

      sil! keepj norm! VGg@
      exe "keepj norm! 0\<c-v>G$h\"ad"
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
      exe "keepj " . l:lastLine
      sil! keepj norm! "_dG
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"

    " when user calls a char or line operation
    else
      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
      let l:titlecased = s:capitalizeFirstWord(l:titlecased)
      call setreg('"', l:titlecased)
      let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
      silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"
    endif
  finally

    " restore the settings
    call setreg('"', l:reg_save)
    call setpos("'<", l:visual_marks_save[0])
    call setpos("'>", l:visual_marks_save[1])
    let &clipboard = l:cb_save
    let &selection = l:sel_save
  endtry
  return
endfunction
```

این بسیار طولانی است، بنابراین بیایید آن را تجزیه کنیم.

*می‌توانستم این را به بخش‌های کوچکتر تقسیم کنم، اما به خاطر کامل کردن این فصل، من آن را به همین شکل رها کردم.*
## تابع اپراتور

این قسمت اول کد است:

```shell
if a:type ==# ''
  set opfunc=ToTitle
  return 'g@'
endif
```

خب `opfunc` چیست؟ چرا `g@` را برمی‌گرداند؟

ویم یک اپراتور خاص دارد، تابع اپراتور، `g@`. این اپراتور به شما اجازه می‌دهد از *هر* تابعی که به گزینه `opfunc` اختصاص داده شده استفاده کنید. اگر تابع `Foo()` به `opfunc` اختصاص داده شده باشد، وقتی که `g@w` را اجرا می‌کنم، در واقع `Foo()` را روی کلمه بعدی اجرا می‌کنم. اگر `g@i(` را اجرا کنم، در واقع `Foo()` را روی پرانتزهای داخلی اجرا می‌کنم. این تابع اپراتور برای ایجاد اپراتورهای سفارشی ویم حیاتی است.

خط زیر `opfunc` را به تابع `ToTitle` اختصاص می‌دهد.

```shell
set opfunc=ToTitle
```

خط بعدی به‌طور دقیق `g@` را برمی‌گرداند:

```shell
return g@
```

پس دقیقاً این دو خط چگونه کار می‌کنند و چرا `g@` را برمی‌گرداند؟

فرض کنید که شما نقشه زیر را دارید:

```shell
nnoremap <expr> gt ToTitle()`
```

سپس شما `gtw` (تبدیل کلمه بعدی به حروف بزرگ) را فشار می‌دهید. اولین باری که `gtw` را اجرا می‌کنید، ویم متد `ToTitle()` را فراخوانی می‌کند. اما در حال حاضر `opfunc` هنوز خالی است. شما همچنین هیچ آرگومانی به `ToTitle()` نمی‌دهید، بنابراین مقدار `a:type` برابر با `''` خواهد بود. این باعث می‌شود که عبارت شرطی آرگومان `a:type`، `if a:type ==# ''`، درست باشد. در داخل، شما `opfunc` را با `set opfunc=ToTitle` به تابع `ToTitle` اختصاص می‌دهید. حالا `opfunc` به `ToTitle` اختصاص داده شده است. در نهایت، پس از اینکه `opfunc` را به تابع `ToTitle` اختصاص دادید، `g@` را برمی‌گردانید. در ادامه توضیح می‌دهم که چرا `g@` را برمی‌گرداند.

شما هنوز تمام نشده‌اید. به یاد داشته باشید، شما فقط `gtw` را فشار داده‌اید. فشار دادن `gt` تمام کارهای بالا را انجام داد، اما هنوز `w` برای پردازش دارید. با برگرداندن `g@`، در این مرحله، شما به‌طور تکنیکی `g@w` دارید (این دلیل اینکه شما `return g@` دارید). از آنجا که `g@` تابع اپراتور است، شما `w` حرکت را به آن می‌دهید. بنابراین ویم، پس از دریافت `g@w`، تابع `ToTitle` را *یک بار دیگر* فراخوانی می‌کند (نگران نباشید، شما در یک حلقه بی‌نهایت نخواهید افتاد همانطور که در ادامه خواهید دید).

برای خلاصه، با فشار دادن `gtw`، ویم بررسی می‌کند که آیا `opfunc` خالی است یا نه. اگر خالی باشد، ویم آن را با `ToTitle` اختصاص می‌دهد. سپس `g@` را برمی‌گرداند، در واقع دوباره `ToTitle` را یک بار دیگر فراخوانی می‌کند تا شما بتوانید از آن به عنوان یک اپراتور استفاده کنید. این دشوارترین بخش ایجاد یک اپراتور سفارشی است و شما آن را انجام دادید! حالا شما باید منطق `ToTitle()` را بسازید تا ورودی را واقعاً به حروف بزرگ تبدیل کند.

## پردازش ورودی

شما اکنون `gt` را به عنوان یک اپراتور که `ToTitle()` را اجرا می‌کند، دارید. اما بعد از آن چه کار می‌کنید؟ چگونه واقعاً متن را به حروف بزرگ تبدیل می‌کنید؟

هر زمان که شما هر اپراتوری را در ویم اجرا می‌کنید، سه نوع حرکت عمل مختلف وجود دارد: کاراکتر، خط و بلوک. `g@w` (کلمه) یک مثال از یک عملیات کاراکتری است. `g@j` (یک خط پایین‌تر) یک مثال از یک عملیات خطی است. عملیات بلوکی نادر است، اما معمولاً وقتی شما عملیات `Ctrl-V` (بلوک بصری) را انجام می‌دهید، به عنوان یک عملیات بلوکی محسوب می‌شود. عملیات‌هایی که چند کاراکتر به جلو / عقب هدف قرار می‌دهند معمولاً به عنوان عملیات کاراکتری در نظر گرفته می‌شوند (`b`، `e`، `w`، `ge` و غیره). عملیات‌هایی که چند خط به پایین / بالا هدف قرار می‌دهند معمولاً به عنوان عملیات خطی در نظر گرفته می‌شوند (`j`، `k`). عملیات‌هایی که ستون‌ها را به جلو، عقب، بالا یا پایین هدف قرار می‌دهند معمولاً به عنوان عملیات بلوکی در نظر گرفته می‌شوند (آنها معمولاً یا یک حرکت اجباری ستونی یا یک حالت بصری بلوکی هستند؛ برای اطلاعات بیشتر: `:h forced-motion`).

این بدان معناست که اگر شما `g@w` را فشار دهید، `g@` یک رشته ادبی `"char"` را به عنوان آرگومان به `ToTitle()` می‌دهد. اگر `g@j` را انجام دهید، `g@` یک رشته ادبی `"line"` را به عنوان آرگومان به `ToTitle()` می‌دهد. این رشته چیزی است که به تابع `ToTitle` به عنوان آرگومان `type` منتقل می‌شود.

## ایجاد اپراتور تابع سفارشی خود

بیایید مکث کنیم و با `g@` بازی کنیم و یک تابع آزمایشی بنویسیم:

```shell
function! Test(some_arg)
  echom a:some_arg 
endfunction
```

حالا آن تابع را با اجرای زیر به `opfunc` اختصاص دهید:

```shell
:set opfunc=Test
```

اپراتور `g@` تابع `Test(some_arg)` را اجرا می‌کند و آن را با `"char"`، `"line"` یا `"block"` بسته به عملی که انجام می‌دهید، منتقل می‌کند. عملیات‌های مختلفی مانند `g@iw` (کلمه داخلی)، `g@j` (یک خط پایین‌تر)، `g@$` (به انتهای خط) و غیره را اجرا کنید. ببینید چه مقادیر مختلفی به نمایش در می‌آید. برای آزمایش عملیات بلوکی، می‌توانید از حرکت اجباری ویم برای عملیات بلوکی استفاده کنید: `g@Ctrl-Vj` (عملیات بلوکی یک ستون پایین‌تر).

شما همچنین می‌توانید از آن با حالت بصری استفاده کنید. از هایلایت‌های بصری مختلف مانند `v`، `V` و `Ctrl-V` استفاده کنید و سپس `g@` را فشار دهید (هشدار، خروجی به سرعت نمایش داده می‌شود، بنابراین شما باید چشمان تیزی داشته باشید - اما خروجی قطعاً وجود دارد. همچنین، از آنجا که شما از `echom` استفاده می‌کنید، می‌توانید پیام‌های خروجی ضبط شده را با `:messages` بررسی کنید).

خیلی جالب است، نیست؟ چیزهایی که می‌توانید با ویم برنامه‌نویسی کنید! چرا اینها را در مدرسه به شما یاد ندادند؟ بیایید با پلاگین خود ادامه دهیم.

## ToTitle به عنوان یک تابع

به خطوط بعدی برویم:

```shell
if a:type != 'block' && a:type != 'line' && a:type != 'char'
  let l:words = a:type
  let l:wordsArr = trim(l:words)->split('\s\+')
  call map(l:wordsArr, 's:capitalize(v:val)')
  return l:wordsArr->join(' ')
endif
```

این خط در واقع هیچ ارتباطی با رفتار `ToTitle()` به عنوان یک اپراتور ندارد، بلکه برای فعال کردن آن به عنوان یک تابع قابل فراخوانی TitleCase است (بله، می‌دانم که من اصل مسئولیت واحد را نقض می‌کنم). انگیزه این است که ویم توابع داخلی `toupper()` و `tolower()` دارد که هر رشته‌ای را به حروف بزرگ و کوچک تبدیل می‌کند. به عنوان مثال: `:echo toupper('hello')` `'HELLO'` را برمی‌گرداند و `:echo tolower('HELLO')` `'hello'` را برمی‌گرداند. من می‌خواهم این پلاگین قابلیت اجرای `ToTitle` را داشته باشد تا شما بتوانید `:echo ToTitle('once upon a time')` را اجرا کنید و مقدار `'Once Upon a Time'` را دریافت کنید.

تا به حال، شما می‌دانید که وقتی شما `ToTitle(type)` را با `g@` فراخوانی می‌کنید، آرگومان `type` دارای مقداری از `'block'`، `'line'` یا `'char'` خواهد بود. اگر آرگومان نه `'block'` باشد و نه `'line'` و نه `'char'`، می‌توانید به راحتی فرض کنید که `ToTitle()` خارج از `g@` فراخوانی می‌شود. در این صورت، شما آنها را با فاصله‌ها (`\s\+`) تقسیم می‌کنید:

```shell
let l:wordsArr = trim(l:words)->split('\s\+')
```

سپس هر عنصر را بزرگ می‌کنید:

```shell
call map(l:wordsArr, 's:capitalize(v:val)')
```

قبل از اینکه آنها را دوباره به هم بپیوندید:

```shell
l:wordsArr->join(' ')
```

تابع `capitalize()` بعداً پوشش داده خواهد شد.

## متغیرهای موقت

چند خط بعدی:

```shell
let l:sel_save = &selection
let l:reg_save = getreginfo('"')
let l:cb_save = &clipboard
let l:visual_marks_save = [getpos("'<"), getpos("'>")]
```

این خطوط وضعیت‌های مختلف فعلی را در متغیرهای موقت حفظ می‌کنند. در ادامه، شما از حالت‌های بصری، نشانه‌ها و ثبت‌ها استفاده خواهید کرد. انجام این کارها با چند وضعیت تداخل خواهد کرد. از آنجا که شما نمی‌خواهید تاریخچه را تغییر دهید، باید آنها را در متغیرهای موقت ذخیره کنید تا بتوانید وضعیت‌ها را بعداً بازیابی کنید.
## بزرگ کردن انتخاب‌ها

خطوط بعدی مهم هستند:

```shell
try
  set clipboard= selection=inclusive
  let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
  let l:selected_phrase = getreg('"')
  let l:WORD_PATTERN = '\<\k*\>'
  let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

  let l:startLine = line("'<")
  let l:startCol = virtcol(".")
```
بیایید آنها را در بخش‌های کوچک بررسی کنیم. این خط:

```shell
set clipboard= selection=inclusive
```

شما ابتدا گزینه `selection` را به صورت inclusive تنظیم می‌کنید و `clipboard` را خالی می‌گذارید. ویژگی انتخاب معمولاً با حالت بصری استفاده می‌شود و سه مقدار ممکن دارد: `old`، `inclusive` و `exclusive`. تنظیم آن به صورت inclusive به این معنی است که آخرین کاراکتر انتخاب شده شامل می‌شود. من در اینجا آنها را پوشش نمی‌دهم، اما نکته این است که انتخاب آن به صورت inclusive باعث می‌شود که در حالت بصری به طور مداوم رفتار کند. به طور پیش‌فرض، Vim آن را به صورت inclusive تنظیم می‌کند، اما شما در اینجا آن را به هر حال تنظیم می‌کنید تا در صورت تنظیم یکی از پلاگین‌های شما به مقدار دیگری، مشکلی پیش نیاید. اگر کنجکاو هستید که واقعاً چه کار می‌کنند، به `:h 'clipboard'` و `:h 'selection'` نگاهی بیندازید.

بعد شما این هش عجیب و غریب را دارید که با یک دستور اجرا می‌شود:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
```

اول، سینتکس `#{}` نوع داده دیکشنری Vim است. متغیر محلی `l:commands` یک هش با کلیدهای 'lines'، 'char' و 'block' است. دستور `silent exe '...'` هر دستوری را که درون رشته قرار دارد به صورت بی‌صدا اجرا می‌کند (در غیر این صورت، اعلان‌هایی در پایین صفحه شما نمایش داده می‌شود).

دوم، دستورات اجرا شده `'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')` هستند. اولی، `noautocmd`، دستور بعدی را بدون فعال کردن هیچ autocommandی اجرا می‌کند. دومی، `keepjumps`، برای ثبت نکردن حرکت نشانگر در حین حرکت است. در Vim، برخی حرکات به طور خودکار در لیست تغییرات، لیست پرش‌ها و لیست نشانه‌ها ثبت می‌شوند. این کار مانع از آن می‌شود. هدف از داشتن `noautocmd` و `keepjumps` جلوگیری از اثرات جانبی است. در نهایت، دستور `normal` رشته‌ها را به عنوان دستورات عادی اجرا می‌کند. `..` سینتکس بینابینی رشته‌های Vim است. `get()` یک متد گیرنده است که لیست، blob یا دیکشنری را می‌پذیرد. در این مورد، شما دیکشنری `l:commands` را به آن پاس می‌دهید. کلید `a:type` است. شما قبلاً یاد گرفته‌اید که `a:type` یکی از سه مقدار رشته‌ای: 'char'، 'line' یا 'block' است. بنابراین اگر `a:type` 'line' باشد، شما در حال اجرای `"noautocmd keepjumps normal! '[V']y"` هستید (برای اطلاعات بیشتر، به `:h silent`، `:h :exe`، `:h :noautocmd`، `:h :keepjumps`، `:h :normal` و `:h get()` مراجعه کنید).

بیایید ببینیم `'[V']y` چه کاری انجام می‌دهد. ابتدا فرض کنید که شما این متن را دارید:

```shell
صبحانه دوم
بهتر از صبحانه اول است
```
فرض کنید که نشانگر شما روی خط اول است. سپس شما `g@j` را فشار می‌دهید (عملکرد اپراتور، `g@`، یک خط پایین‌تر با `j`). `'[` نشانگر را به شروع متن تغییر یافته یا یانک شده قبلی منتقل می‌کند. اگرچه شما به طور فنی هیچ متنی را با `g@j` تغییر یا یانک نکرده‌اید، Vim مکان‌های شروع و پایان حرکات دستور `g@` را با `'[` و `']` به خاطر می‌سپارد (برای اطلاعات بیشتر، به `:h g@` مراجعه کنید). در مورد شما، فشار دادن `'[` نشانگر شما را به خط اول منتقل می‌کند زیرا اینجا جایی است که شما شروع کردید وقتی `g@` را اجرا کردید. `V` یک دستور حالت بصری خطی است. در نهایت، `']` نشانگر شما را به انتهای متن تغییر یافته یا یانک شده قبلی منتقل می‌کند، اما در این مورد، نشانگر شما را به انتهای آخرین عملیات `g@` منتقل می‌کند. در نهایت، `y` متن انتخاب شده را یانک می‌کند.

آنچه شما انجام دادید یانک کردن همان متن است که شما عملیات `g@` را روی آن انجام داده‌اید.

اگر به دو دستور دیگر در اینجا نگاه کنید:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
```

همه آنها اقداماتی مشابه انجام می‌دهند، به جز اینکه به جای استفاده از اقدامات خطی، شما از اقدامات کاراکتری یا بلوکی استفاده می‌کنید. من ممکن است تکراری به نظر برسم، اما در هر سه حالت شما در واقع همان متن را که عملیات `g@` را روی آن انجام داده‌اید یانک می‌کنید.

بیایید به خط بعدی نگاه کنیم:

```shell
let l:selected_phrase = getreg('"')
```

این خط محتوای ثبت‌نام نشده (`"`) را می‌گیرد و در متغیر `l:selected_phrase` ذخیره می‌کند. صبر کنید... آیا شما همین حالا یک متن را یانک نکردید؟ ثبت‌نام نشده در حال حاضر شامل متنی است که شما به تازگی یانک کرده‌اید. اینگونه است که این پلاگین می‌تواند کپی متن را به دست آورد.

خط بعدی یک الگوی عبارات منظم است:

```shell
let l:WORD_PATTERN = '\<\k*\>'
```

`\<` و `\>` الگوهای مرزی کلمه هستند. کاراکتر پس از `\<` شروع یک کلمه را مطابقت می‌دهد و کاراکتر پیش از `\>` پایان یک کلمه را مطابقت می‌دهد. `\k` الگوی کلمه کلیدی است. شما می‌توانید بررسی کنید که Vim چه کاراکترهایی را به عنوان کلمه کلیدی می‌پذیرد با `:set iskeyword?`. به یاد داشته باشید که حرکت `w` در Vim نشانگر شما را به صورت کلمه‌ای حرکت می‌دهد. Vim با یک مفهوم پیش‌ساخته از آنچه که "کلمه کلیدی" است می‌آید (شما حتی می‌توانید آنها را با تغییر گزینه `iskeyword` ویرایش کنید). به `:h /\<`، `:h /\>`، و `:h /\k`، و `:h 'iskeyword'` نگاهی بیندازید. در نهایت، `*` به معنای صفر یا بیشتر از الگوی بعدی است.

در تصویر بزرگتر، `'\<\k*\>'` یک کلمه را مطابقت می‌دهد. اگر شما یک رشته داشته باشید:

```shell
یک دو سه
```

مقایسه آن با الگو سه مطابقت خواهد داشت: "یک"، "دو"، و "سه".

در نهایت، شما یک الگوی دیگر دارید:

```shell
let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'
```

به یاد داشته باشید که دستور جایگزینی Vim می‌تواند با یک عبارت با `\={your-expression}` استفاده شود. به عنوان مثال، اگر شما بخواهید رشته "donut" را در خط جاری بزرگ کنید، می‌توانید از تابع `toupper()` Vim استفاده کنید. شما می‌توانید این کار را با اجرای `:%s/donut/\=toupper(submatch(0))/g` انجام دهید. `submatch(0)` یک عبارت خاص است که در دستور جایگزینی استفاده می‌شود. این متن کامل مطابقت یافته را برمی‌گرداند.

دو خط بعدی:

```shell
let l:startLine = line("'<")
let l:startCol = virtcol(".")
```

عبارت `line()` شماره خط را برمی‌گرداند. در اینجا شما آن را با علامت `'<`، که نمایانگر اولین خط ناحیه بصری انتخاب شده آخر است، پاس می‌دهید. به یاد داشته باشید که شما از حالت بصری برای یانک کردن متن استفاده کردید. `'<` شماره خط آغاز آن انتخاب ناحیه بصری را برمی‌گرداند. عبارت `virtcol()` شماره ستونی از نشانگر جاری را برمی‌گرداند. شما در حال حرکت نشانگر خود در همه جا در کمی بعد هستید، بنابراین شما نیاز دارید که مکان نشانگر خود را ذخیره کنید تا بتوانید بعداً به اینجا برگردید.

در اینجا یک استراحت کنید و همه چیز را تا اینجا مرور کنید. مطمئن شوید که هنوز در حال پیگیری هستید. وقتی آماده‌اید، بیایید ادامه دهیم.
## مدیریت عملیات بلوک

بیایید این بخش را مرور کنیم:

```shell
if a:type ==# "block"
  sil! keepj norm! gv"ad
  keepj $
  keepj pu_

  let l:lastLine = line("$")

  sil! keepj norm "ap

  let l:curLine = line(".")

  sil! keepj norm! VGg@
  exe "keepj norm! 0\<c-v>G$h\"ad" 
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
  exe "keepj " . l:lastLine
  sil! keepj norm! "_dG
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

وقت آن است که واقعاً متن خود را بزرگ کنید. به یاد داشته باشید که شما `a:type` را دارید که می‌تواند 'char'، 'line' یا 'block' باشد. در بیشتر موارد، احتمالاً 'char' و 'line' را دریافت خواهید کرد. اما گاهی ممکن است یک بلوک دریافت کنید. این نادر است، اما باید به آن پرداخته شود. متأسفانه، مدیریت یک بلوک به سادگی مدیریت کاراکتر و خط نیست. این کمی تلاش اضافی می‌طلبد، اما قابل انجام است.

قبل از شروع، بیایید یک مثال از نحوه دریافت یک بلوک را بررسی کنیم. فرض کنید این متن را دارید:

```shell
پانکیک برای صبحانه
پانکیک برای ناهار
پانکیک برای شام
```

فرض کنید که نشانگر شما روی "c" در "پانکیک" در خط اول است. سپس از بلوک بصری (`Ctrl-V`) استفاده می‌کنید تا به پایین و جلو بروید و "کیک" را در هر سه خط انتخاب کنید:

```shell
pan[cake] برای صبحانه
pan[cake] برای ناهار
pan[cake] برای شام
```

وقتی `gt` را فشار می‌دهید، می‌خواهید به این شکل برسید:

```shell
panCake برای صبحانه
panCake برای ناهار
panCake برای شام
```
اینجا فرضیات اصلی شما این است: وقتی سه "کیک" در "پانکیک‌ها" را هایلایت می‌کنید، به ویم می‌گویید که سه خط از کلمات را دارید که می‌خواهید هایلایت کنید. این کلمات "کیک"، "کیک" و "کیک" هستند. شما انتظار دارید "Cake"، "Cake" و "Cake" را دریافت کنید.

بیایید به جزئیات پیاده‌سازی برویم. چند خط بعدی شامل:

```shell
sil! keepj norm! gv"ad
keepj $
keepj pu_
let l:lastLine = line("$")
sil! keepj norm "ap
let l:curLine = line(".")
```

خط اول:

```shell
sil! keepj norm! gv"ad
```

به یاد داشته باشید که `sil!` به صورت بی‌صدا اجرا می‌شود و `keepj` تاریخچه پرش را هنگام حرکت حفظ می‌کند. سپس دستور نرمال `gv"ad` را اجرا می‌کنید. `gv` آخرین متن هایلایت شده بصری را انتخاب می‌کند (در مثال پانکیک، تمام سه 'کیک' را دوباره هایلایت می‌کند). `"ad` متون هایلایت شده بصری را حذف کرده و در رجیستر a ذخیره می‌کند. در نتیجه، اکنون دارید:

```shell
pan برای صبحانه
pan برای ناهار
pan برای شام
```

اکنون شما 3 *بلوک* (نه خط) از 'کیک' را در رجیستر a ذخیره کرده‌اید. این تمایز مهم است. یانک کردن متن با حالت بصری خطی با یانک کردن متن با حالت بصری بلوکی متفاوت است. این را در ذهن داشته باشید زیرا بعداً دوباره این را خواهید دید.

سپس شما دارید:

```shell
keepj $
keepj pu_
```

`$` شما را به آخرین خط در فایل می‌برد. `pu_` یک خط زیر جایی که نشانگر شما قرار دارد وارد می‌کند. شما می‌خواهید آنها را با `keepj` اجرا کنید تا تاریخچه پرش را تغییر ندهید.

سپس شماره خط آخرین خط خود (`line("$")`) را در متغیر محلی `lastLine` ذخیره می‌کنید.

```shell
let l:lastLine = line("$")
```

سپس محتوا را از رجیستر با `norm "ap` چسبانده‌اید.

```shell
sil! keepj norm "ap
```

به یاد داشته باشید که این در خط جدیدی که زیر آخرین خط فایل ایجاد کرده‌اید اتفاق می‌افتد - شما در حال حاضر در پایین فایل هستید. چسباندن این متون *بلوک* را به شما می‌دهد:

```shell
کیک
کیک
کیک
```

سپس، مکان خط جاری که نشانگر شما در آن قرار دارد را ذخیره می‌کنید.

```shell
let l:curLine = line(".")
```

حالا بیایید به چند خط بعدی برویم:

```shell
sil! keepj norm! VGg@
exe "keepj norm! 0\<c-v>G$h\"ad"
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

این خط:

```shell
sil! keepj norm! VGg@
```

`VG` آنها را با حالت بصری خطی از خط جاری تا انتهای فایل هایلایت می‌کند. بنابراین در اینجا شما سه بلوک از متون 'کیک' را با هایلایت خطی هایلایت می‌کنید (به تمایز بلوک در مقابل خط توجه کنید). توجه داشته باشید که اولین بار که سه متن "کیک" را چسباندید، آنها را به عنوان بلوک چسباندید. اکنون شما آنها را به عنوان خطوط هایلایت می‌کنید. آنها ممکن است از بیرون مشابه به نظر برسند، اما درون ویم تفاوت بین چسباندن بلوک‌های متنی و چسباندن خطوط متنی را می‌داند.

```shell
کیک
کیک
کیک
```

`g@` عملگر تابع است، بنابراین شما اساساً یک فراخوانی بازگشتی به خودتان انجام می‌دهید. اما چرا؟ این چه چیزی را به دست می‌آورد؟

شما یک فراخوانی بازگشتی به `g@` انجام می‌دهید و آن را با تمام 3 خط (پس از اجرای آن با `V`، اکنون خطوط دارید، نه بلوک‌ها) از متون 'کیک' ارسال می‌کنید تا توسط بخش دیگر کد مدیریت شود (بعداً این را بررسی خواهید کرد). نتیجه اجرای `g@` سه خط از متون به درستی عنوان‌گذاری شده است:

```shell
کیک
کیک
کیک
```

خط بعدی:

```shell
exe "keepj norm! 0\<c-v>G$h\"ad"
```

این دستور نرمال را برای رفتن به ابتدای خط (`0`) اجرا می‌کند، از هایلایت بصری بلوکی برای رفتن به آخرین خط و آخرین کاراکتر در آن خط (`<c-v>G$`) استفاده می‌کند. `h` برای تنظیم نشانگر است (وقتی `$` را انجام می‌دهید، ویم یک خط اضافی به سمت راست حرکت می‌کند). در نهایت، متن هایلایت شده را حذف کرده و در رجیستر a ذخیره می‌کند (`"ad`).

خط بعدی:

```shell
exe "keepj " . l:startLine
```

شما نشانگر خود را به جایی که `startLine` بود برمی‌گردانید.

بعد:

```shell
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
```

در مکان `startLine`، اکنون به ستونی که با `startCol` علامت‌گذاری شده‌اید می‌روید. `\<bar>\` حرکت نوار `|` است. حرکت نوار در ویم نشانگر شما را به ستون n ام می‌برد (فرض کنید `startCol` 4 بود. اجرای `4|` نشانگر شما را به موقعیت ستون 4 می‌برد). به یاد داشته باشید که `startCol` مکان جایی بود که موقعیت ستونی متنی که می‌خواستید عنوان‌گذاری کنید را ذخیره کرده‌اید. در نهایت، `"aP` متون ذخیره شده در رجیستر a را چسبانده و متن را به جایی که قبلاً حذف شده بود برمی‌گرداند.

بیایید به 4 خط بعدی نگاه کنیم:

```shell
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

`exe "keepj " . l:lastLine` نشانگر شما را به مکان `lastLine` از قبل برمی‌گرداند. `sil! keepj norm! "_dG` فضاهای اضافی که با استفاده از رجیستر سیاه‌چاله ایجاد شده‌اند را حذف می‌کند (`"_dG`) تا رجیستر نام‌گذاری نشده شما تمیز بماند. `exe "keepj " . l:startLine` نشانگر شما را به `startLine` برمی‌گرداند. در نهایت، `exe "sil! keepj norm! " . l:startCol . "\<bar>"` نشانگر شما را به ستون `startCol` منتقل می‌کند.

اینها تمام اقداماتی هستند که می‌توانستید به صورت دستی در ویم انجام دهید. با این حال، مزیت تبدیل این اقدامات به توابع قابل استفاده مجدد این است که شما را از اجرای 30+ خط دستورالعمل هر بار که نیاز به عنوان‌گذاری هر چیزی دارید، نجات می‌دهد. نکته این است که هر چیزی که می‌توانید به صورت دستی در ویم انجام دهید، می‌توانید آن را به یک تابع قابل استفاده مجدد تبدیل کنید، بنابراین یک پلاگین!

این چیزی است که به نظر می‌رسد.

با توجه به متنی:

```shell
پانکیک برای صبحانه
پانکیک برای ناهار
پانکیک برای شام

... برخی متن‌ها
```

اول، شما آن را به صورت بلوکی هایلایت می‌کنید:

```shell
pan[cake] برای صبحانه
pan[cake] برای ناهار
pan[cake] برای شام

... برخی متن‌ها
```

سپس آن را حذف کرده و آن متن را در رجیستر a ذخیره می‌کنید:

```shell
pan برای صبحانه
pan برای ناهار
pan برای شام

... برخی متن‌ها
```

سپس آن را در پایین فایل چسبانده‌اید:

```shell
pan برای صبحانه
pan برای ناهار
pan برای شام

... برخی متن‌ها
کیک
کیک
کیک
```

سپس آن را بزرگ می‌کنید:

```shell
pan برای صبحانه
pan برای ناهار
pan برای شام

... برخی متن‌ها
کیک
کیک
کیک
```

در نهایت، متن بزرگ شده را به عقب برمی‌گردانید:

```shell
panCake برای صبحانه
panCake برای ناهار
panCake برای شام

... برخی متن‌ها
```

## مدیریت عملیات خط و کاراکتر

شما هنوز کارتان تمام نشده است. شما فقط به حالت لبه‌ای پرداخته‌اید زمانی که `gt` را روی متون بلوکی اجرا می‌کنید. شما هنوز نیاز به مدیریت عملیات 'line' و 'char' دارید. بیایید به کد `else` نگاه کنیم تا ببینیم این چگونه انجام می‌شود.

اینجا کدها هستند:

```shell
if a:type ==# "block"
  # ... 
else
  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
  let l:titlecased = s:capitalizeFirstWord(l:titlecased)
  call setreg('"', l:titlecased)
  let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
  silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
endif
```

بیایید خط به خط آنها را مرور کنیم. راز این پلاگین در واقع در این خط نهفته است:

```shell
let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
```

`@@` حاوی متنی است که از رجیستر نام‌گذاری نشده برای عنوان‌گذاری استفاده می‌شود. `l:WORD_PATTERN` الگوی مطابقت با کلمات فردی است. `l:UPCASE_REPLACEMENT` فراخوانی به دستور `capitalize()` است (که بعداً آن را خواهید دید). `'g'` پرچم جهانی است که به دستور جایگزینی دستور می‌دهد تا تمام کلمات داده شده را جایگزین کند، نه فقط اولین کلمه.

خط بعدی:

```shell
let l:titlecased = s:capitalizeFirstWord(l:titlecased)
```

این تضمین می‌کند که اولین کلمه همیشه بزرگ نوشته می‌شود. اگر عبارتی مانند "یک سیب در روز پزشک را دور نگه می‌دارد" داشته باشید، از آنجا که اولین کلمه، "یک"، یک کلمه خاص است، دستور جایگزینی شما آن را بزرگ نمی‌کند. شما به یک روش نیاز دارید که همیشه اولین کاراکتر را بدون توجه به چه چیزی بزرگ کند. این تابع دقیقاً همین کار را انجام می‌دهد (جزئیات این تابع را بعداً خواهید دید). نتیجه این روش‌های بزرگ‌نویسی در متغیر محلی `l:titlecased` ذخیره می‌شود.

خط بعدی:

```shell
call setreg('"', l:titlecased)
```

این رشته بزرگ شده را در رجیستر نام‌گذاری نشده (`"`) قرار می‌دهد.

سپس، دو خط بعدی:

```shell
let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
```

هی، این آشنا به نظر می‌رسد! شما الگوی مشابهی را با `l:commands` قبلاً دیده‌اید. به جای یانک، در اینجا از چسباندن (`p`) استفاده می‌کنید. به بخش قبلی مراجعه کنید که در آن `l:commands` را بررسی کردم تا یک یادآوری داشته باشید.

در نهایت، این دو خط:

```shell
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

شما نشانگر خود را به خط و ستونی که شروع کرده‌اید برمی‌گردانید. همین است!

بیایید خلاصه کنیم. روش جایگزینی فوق به اندازه کافی هوشمند است تا متون داده شده را بزرگ کند و کلمات خاص را نادیده بگیرد (بیشتر در مورد این بعداً). پس از اینکه یک رشته بزرگ شده دارید، آنها را در رجیستر نام‌گذاری نشده ذخیره می‌کنید. سپس دقیقاً همان متنی را که روی آن `g@` عمل کرده‌اید، به صورت بصری هایلایت می‌کنید و سپس از رجیستر نام‌گذاری نشده چسبانده می‌شود (این به طور مؤثر متون غیر بزرگ شده را با نسخه بزرگ شده جایگزین می‌کند). در نهایت، شما نشانگر خود را به جایی که شروع کرده‌اید برمی‌گردانید.
## پاک‌سازی‌ها

شما به‌طور فنی کار خود را تمام کرده‌اید. متن‌ها اکنون به صورت عنوانی نوشته شده‌اند. تنها چیزی که باقی مانده، بازگرداندن رجیسترها و تنظیمات است.

```shell
call setreg('"', l:reg_save)
call setpos("'<", l:visual_marks_save[0])
call setpos("'>", l:visual_marks_save[1])
let &clipboard = l:cb_save
let &selection = l:sel_save
```

این‌ها را بازمی‌گردانند:
- رجیستر بدون نام.
- نشانه‌های `<` و `>`.
- گزینه‌های `'clipboard'` و `'selection'`.

اوه، شما کار خود را تمام کردید. این یک تابع طولانی بود. می‌توانستم تابع را کوتاه‌تر کنم و آن را به توابع کوچک‌تر تقسیم کنم، اما فعلاً همین کافی است. حالا بیایید به‌طور مختصر به توابع بزرگ‌نویسی بپردازیم.

## تابع بزرگ‌نویسی

در این بخش، بیایید به تابع `s:capitalize()` بپردازیم. این تابع به شکل زیر است:

```shell
function! s:capitalize(string)
    if(toupper(a:string) ==# a:string && a:string != 'A')
        return a:string
    endif

    let l:str = tolower(a:string)
    let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
      return l:str
    endif

    return toupper(l:str[0]) . l:str[1:]
endfunction
```

به یاد داشته باشید که آرگومان تابع `capitalize()`، `a:string`، کلمه فردی است که توسط اپراتور `g@` ارسال می‌شود. بنابراین اگر من روی متن "پان‌کیک برای صبحانه" `gt` را اجرا کنم، `ToTitle` تابع `capitalize(string)` را *سه* بار فراخوانی می‌کند، یک بار برای "پان‌کیک"، یک بار برای "برای" و یک بار برای "صبحانه".

قسمت اول تابع این است:

```shell
if(toupper(a:string) ==# a:string && a:string != 'A')
  return a:string
endif
```

شرط اول (`toupper(a:string) ==# a:string`) بررسی می‌کند که آیا نسخه بزرگ‌نویس آرگومان همانند رشته است و آیا خود رشته "A" نیست. اگر این‌ها درست باشد، آن رشته را برگردانید. این بر اساس فرضی است که اگر یک کلمه خاص به‌طور کامل بزرگ‌نویس باشد، پس یک اختصار است. به عنوان مثال، کلمه "CEO" در غیر این صورت به "Ceo" تبدیل می‌شود. هوم، مدیر عامل شما خوشحال نخواهد شد. بنابراین بهتر است هر کلمه کاملاً بزرگ‌نویس را دست نزنید. شرط دوم، `a:string != 'A'`، به یک حالت خاص برای حرف بزرگ "A" می‌پردازد. اگر `a:string` از قبل یک "A" بزرگ باشد، به‌طور تصادفی از آزمون `toupper(a:string) ==# a:string` عبور می‌کند. زیرا "a" یک مقاله نامعین در زبان انگلیسی است و باید به کوچک تبدیل شود.

قسمت بعدی رشته را به کوچک تبدیل می‌کند:

```shell
let l:str = tolower(a:string)
```

قسمت بعدی یک regex از لیست تمام کلمات استثنا است. من آن‌ها را از https://titlecaseconverter.com/rules/ گرفتم:

```shell
let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
```

قسمت بعدی:

```shell
if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
  return l:str
endif
```

اول، بررسی کنید که آیا رشته شما بخشی از لیست کلمات استثنا (`l:exclusions`) است. اگر این‌گونه باشد، آن را بزرگ‌نویس نکنید. سپس بررسی کنید که آیا رشته شما بخشی از لیست استثنا محلی (`s:local_exclusion_list`) است. این لیست استثنا یک لیست سفارشی است که کاربر می‌تواند در vimrc اضافه کند (در صورتی که کاربر نیازهای اضافی برای کلمات خاص داشته باشد).

قسمت آخر نسخه بزرگ‌نویس شده کلمه را برمی‌گرداند. اولین کاراکتر بزرگ‌نویس شده در حالی که بقیه همانطور که هستند باقی می‌مانند.

```shell
return toupper(l:str[0]) . l:str[1:]
```

بیایید به تابع بزرگ‌نویسی دوم بپردازیم. تابع به شکل زیر است:

```shell
function! s:capitalizeFirstWord(string)
  if (a:string =~ "\n")
    let l:lineArr = trim(a:string)->split('\n')
    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
    return l:lineArr->join("\n")
  endif
  return toupper(a:string[0]) . a:string[1:]
endfunction
```

این تابع برای مدیریت یک حالت خاص ایجاد شده است اگر شما جمله‌ای داشته باشید که با یک کلمه استثنا شروع می‌شود، مانند "یک سیب در روز پزشک را دور نگه می‌دارد". بر اساس قوانین بزرگ‌نویسی زبان انگلیسی، تمام کلمات اول در یک جمله، صرف‌نظر از اینکه کلمه خاصی باشد یا نه، باید بزرگ‌نویس شوند. با استفاده از دستور `substitute()` خود، "یک" در جمله شما به کوچک تبدیل می‌شود. شما باید اولین کاراکتر را به بزرگ تبدیل کنید.

در این تابع `capitalizeFirstWord`، آرگومان `a:string` یک کلمه فردی نیست مانند `a:string` در داخل تابع `capitalize`، بلکه متن کامل است. بنابراین اگر شما "پان‌کیک برای صبحانه" داشته باشید، مقدار `a:string` "پان‌کیک برای صبحانه" است. این تنها یک بار برای کل متن `capitalizeFirstWord` را اجرا می‌کند.

یک سناریو که باید مراقب آن باشید این است که اگر شما یک رشته چند خطی مانند `"یک سیب در روز\nپزشک را دور نگه می‌دارد"` داشته باشید. شما می‌خواهید اولین کاراکتر تمام خطوط را بزرگ‌نویس کنید. اگر خط جدیدی نداشته باشید، به سادگی اولین کاراکتر را بزرگ‌نویس کنید.

```shell
return toupper(a:string[0]) . a:string[1:]
```

اگر خط جدیدی داشته باشید، باید تمام کاراکترهای اول در هر خط را بزرگ‌نویس کنید، بنابراین آن‌ها را به یک آرایه جداشده با خطوط جدید تقسیم می‌کنید:

```shell
let l:lineArr = trim(a:string)->split('\n')
```

سپس هر عنصر در آرایه را نقشه‌برداری کرده و کلمه اول هر عنصر را بزرگ‌نویس می‌کنید:

```shell
let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
```

در نهایت، عناصر آرایه را کنار هم قرار می‌دهید:

```shell
return l:lineArr->join("\n")
```

و شما کار خود را تمام کردید!

## مستندات

دومین دایرکتوری در مخزن دایرکتوری `docs/` است. خوب است که به پلاگین خود مستندات کاملی ارائه دهید. در این بخش، به‌طور مختصر به چگونگی ایجاد مستندات پلاگین خود می‌پردازم.

دایرکتوری `docs/` یکی از مسیرهای ویژه زمان اجرا در Vim است. Vim تمام فایل‌های داخل `docs/` را می‌خواند، بنابراین وقتی شما به دنبال یک کلمه خاص هستید و آن کلمه در یکی از فایل‌های دایرکتوری `docs/` پیدا می‌شود، در صفحه کمک نمایش داده می‌شود. در اینجا یک `totitle.txt` دارید. من آن را این‌گونه نام‌گذاری کرده‌ام زیرا نام پلاگین است، اما می‌توانید آن را هر نامی که می‌خواهید نام‌گذاری کنید.

یک فایل مستندات Vim در اصل یک فایل txt است. تفاوت بین یک فایل txt معمولی و یک فایل کمک Vim این است که دومی از سینتکس‌های خاص "کمک" استفاده می‌کند. اما ابتدا، شما باید به Vim بگویید که آن را به عنوان نوع فایل `help` در نظر بگیرد. برای اینکه به Vim بگویید این `totitle.txt` را به عنوان یک فایل *کمک* تفسیر کند، دستور `:set ft=help` را اجرا کنید (`:h 'filetype'` برای اطلاعات بیشتر). به‌عنوان مثال، اگر می‌خواهید به Vim بگویید که این `totitle.txt` را به عنوان یک فایل txt *معمولی* تفسیر کند، دستور `:set ft=txt` را اجرا کنید.

### سینتکس خاص فایل کمک

برای قابل کشف کردن یک کلمه کلیدی، آن کلمه را با ستاره‌ها احاطه کنید. برای اینکه کلمه کلیدی `totitle` قابل کشف باشد زمانی که کاربر به دنبال `:h totitle` می‌گردد، آن را به صورت `*totitle*` در فایل کمک بنویسید.

به عنوان مثال، من این خطوط را در بالای فهرست مطالب خود دارم:

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

// سایر موارد TOC
```

توجه داشته باشید که من از دو کلمه کلیدی استفاده کرده‌ام: `*totitle*` و `*totitle-toc*` برای علامت‌گذاری بخش فهرست مطالب. شما می‌توانید به تعداد دلخواه کلمه کلیدی استفاده کنید. این بدان معناست که هر زمان که شما به دنبال `:h totitle` یا `:h totitle-toc` بگردید، Vim شما را به این مکان می‌برد.

در اینجا یک مثال دیگر، در جایی در پایین فایل:

```shell
2. Usage                                                       *totitle-usage*

// استفاده
```

اگر شما به دنبال `:h totitle-usage` بگردید، Vim شما را به این بخش می‌برد.

شما همچنین می‌توانید از لینک‌های داخلی برای ارجاع به بخش دیگری در فایل کمک استفاده کنید با احاطه کردن یک کلمه کلیدی با سینتکس بار `|`. در بخش TOC، شما کلمات کلیدی احاطه شده با بارها را می‌بینید، مانند `|totitle-intro|`، `|totitle-usage|` و غیره.

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

    1. Intro ........................... |totitle-intro|
    2. Usage ........................... |totitle-usage|
    3. Words to capitalize ............. |totitle-words|
    4. Operator ........................ |totitle-operator|
    5. Key-binding ..................... |totitle-keybinding|
    6. Bugs ............................ |totitle-bug-report|
    7. Contributing .................... |totitle-contributing|
    8. Credits ......................... |totitle-credits|

```
این به شما اجازه می‌دهد تا به تعریف پرش کنید. اگر شما مکان‌نما خود را روی `|totitle-intro|` قرار دهید و `Ctrl-]` را فشار دهید، Vim به تعریف آن کلمه پرش خواهد کرد. در این مورد، به مکان `*totitle-intro*` پرش خواهد کرد. این‌گونه است که می‌توانید به کلمات کلیدی مختلف در یک مستند کمک لینک دهید.

هیچ راه درست یا غلطی برای نوشتن یک فایل مستندات در Vim وجود ندارد. اگر به پلاگین‌های مختلف از نویسندگان مختلف نگاه کنید، بسیاری از آن‌ها از فرمت‌های مختلفی استفاده می‌کنند. نکته این است که یک مستند کمک آسان برای درک برای کاربران خود ایجاد کنید.

در نهایت، اگر شما در ابتدا پلاگین خود را به‌صورت محلی می‌نویسید و می‌خواهید صفحه مستندات را آزمایش کنید، به سادگی اضافه کردن یک فایل txt در داخل `~/.vim/docs/` به‌طور خودکار کلمات کلیدی شما را قابل جستجو نمی‌کند. شما باید به Vim بگویید که صفحه مستندات شما را اضافه کند. دستور `:helptags ~/.vim/doc` را اجرا کنید تا فایل‌های تگ جدید ایجاد کنید. حالا می‌توانید شروع به جستجوی کلمات کلیدی خود کنید.

## نتیجه‌گیری

شما به انتها رسیدید! این فصل ترکیبی از تمام فصل‌های Vimscript است. در اینجا شما در نهایت آنچه را که تاکنون آموخته‌اید به عمل می‌آورید. امیدوارم با خواندن این، نه تنها یاد بگیرید که چگونه پلاگین‌های Vim ایجاد کنید، بلکه شما را تشویق کند که پلاگین خود را بنویسید.

هر زمان که خود را در حال تکرار یک دنباله از اقدامات چندین بار پیدا کردید، باید سعی کنید خودتان را ایجاد کنید! گفته شده است که نباید چرخ را دوباره اختراع کنید. با این حال، من فکر می‌کنم که می‌تواند برای یادگیری مفید باشد که چرخ را دوباره اختراع کنید. پلاگین‌های دیگران را بخوانید. آن‌ها را دوباره بسازید. از آن‌ها یاد بگیرید. خودتان بنویسید! چه کسی می‌داند، شاید شما بعد از خواندن این، پلاگین فوق‌العاده و بسیار محبوب بعدی را بنویسید. شاید شما تبدیل به تیم پاپ افسانه‌ای بعدی شوید. وقتی این اتفاق بیفتد، به من اطلاع دهید!