---
description: این سند به شما آموزش می‌دهد که چگونه از ویم برای کامپایل کردن کدها استفاده
  کنید و با فرمان `:make` آشنا می‌شوید.
title: Ch19. Compile
---

کامپایل کردن موضوع مهمی برای بسیاری از زبان‌ها است. در این فصل، شما یاد خواهید گرفت که چگونه از ویم کامپایل کنید. همچنین به روش‌هایی برای استفاده از دستور `:make` ویم خواهیم پرداخت.

## کامپایل از خط فرمان

شما می‌توانید از عملگر bang (`!`) برای کامپایل استفاده کنید. اگر نیاز دارید که فایل `.cpp` خود را با `g++` کامپایل کنید، دستور زیر را اجرا کنید:

```shell
:!g++ hello.cpp -o hello
```

با این حال، تایپ دستی نام فایل و نام خروجی هر بار مستعد خطا و خسته‌کننده است. یک makefile بهترین راه است.

## دستور Make

ویم دارای دستور `:make` برای اجرای makefile است. وقتی آن را اجرا می‌کنید، ویم به دنبال یک makefile در دایرکتوری فعلی می‌گردد تا آن را اجرا کند.

یک فایل به نام `makefile` در دایرکتوری فعلی ایجاد کنید و این موارد را درون آن قرار دهید:

```shell
all:
	echo "Hello all"
foo:
	echo "Hello foo"
list_pls:
	ls
```

این را از ویم اجرا کنید:

```shell
:make
```

ویم آن را به همان روشی که از ترمینال اجرا می‌کنید، اجرا می‌کند. دستور `:make` پارامترهایی را مانند دستور make ترمینال می‌پذیرد. اجرا کنید:

```shell
:make foo
" خروجی "Hello foo"

:make list_pls
" خروجی نتیجه دستور ls
```

دستور `:make` از quickfix ویم برای ذخیره هر خطا در صورت اجرای یک دستور نادرست استفاده می‌کند. بیایید یک هدف غیرموجود را اجرا کنیم:

```shell
:make dontexist
```

شما باید یک خطا در اجرای آن دستور ببینید. برای مشاهده آن خطا، دستور quickfix `:copen` را اجرا کنید تا پنجره quickfix را ببینید:

```shell
|| make: *** No rule to make target `dontexist'.  Stop.
```

## کامپایل با Make

بیایید از makefile برای کامپایل یک برنامه ساده `.cpp` استفاده کنیم. ابتدا، بیایید یک فایل `hello.cpp` ایجاد کنیم:

```shell
#include <iostream>

int main() {
    std::cout << "Hello!\n";
    return 0;
}
```

makefile خود را به‌روزرسانی کنید تا یک فایل `.cpp` را بسازد و اجرا کند:

```shell
all:
	echo "build, run"
build:
	g++ hello.cpp -o hello
run:
	./hello
```

حالا اجرا کنید:

```shell
:make build
```

دستور `g++` فایل `./hello.cpp` را کامپایل کرده و `./hello` را ایجاد می‌کند. سپس اجرا کنید:

```shell
:make run
```

شما باید `"Hello!"` را در ترمینال ببینید.

## برنامه Make متفاوت

زمانی که شما `:make` را اجرا می‌کنید، ویم در واقع هر دستوری را که تحت گزینه `makeprg` تنظیم شده است، اجرا می‌کند. اگر `:set makeprg?` را اجرا کنید، خواهید دید:

```shell
makeprg=make
```

دستور پیش‌فرض `:make`، دستور خارجی `make` است. برای تغییر دستور `:make` به‌طوری که هر بار که آن را اجرا می‌کنید، `g++ {your-file-name}` را اجرا کند، دستور زیر را اجرا کنید:

```shell
:set makeprg=g++\ %
```

`\` برای فرار از فضای بعد از `g++` است. نماد `%` در ویم نمایانگر فایل فعلی است. دستور `g++\\ %` معادل اجرای `g++ hello.cpp` است.

به `./hello.cpp` بروید و سپس `:make` را اجرا کنید. ویم `hello.cpp` را کامپایل کرده و `a.out` را ایجاد می‌کند زیرا شما خروجی را مشخص نکردید. بیایید آن را بازنویسی کنیم تا خروجی کامپایل شده با نام فایل اصلی بدون پسوند نامگذاری شود. این را اجرا کنید یا به vimrc خود اضافه کنید:

```shell
set makeprg=g++\ %\ -o\ %<
```

تجزیه و تحلیل:
- `g++\ %` همانند بالا است. معادل اجرای `g++ <your-file>` است.
- `-o` گزینه خروجی است.
- `%<` در ویم نمایانگر نام فایل فعلی بدون پسوند است (`hello.cpp` به `hello` تبدیل می‌شود).

زمانی که شما `:make` را از داخل `./hello.cpp` اجرا می‌کنید، به `./hello` کامپایل می‌شود. برای اجرای سریع `./hello` از داخل `./hello.cpp`، دستور `:!./%<` را اجرا کنید. دوباره، این همانند اجرای `:!./{current-file-name-minus-the-extension}` است.

برای اطلاعات بیشتر، به `:h :compiler` و `:h write-compiler-plugin` مراجعه کنید.

## کامپایل خودکار هنگام ذخیره

شما می‌توانید با اتوماسیون کامپایل، زندگی را حتی آسان‌تر کنید. به یاد داشته باشید که می‌توانید از `autocmd` ویم برای تحریک اقدامات خودکار بر اساس رویدادهای خاص استفاده کنید. برای کامپایل خودکار فایل‌های `.cpp` در هر بار ذخیره، این را به vimrc خود اضافه کنید:

```shell
autocmd BufWritePost *.cpp make
```

هر بار که در یک فایل `.cpp` ذخیره می‌کنید، ویم دستور `make` را اجرا می‌کند.

## تغییر کامپایلر

ویم دارای دستور `:compiler` برای تغییر سریع کامپایلرها است. ساخت ویم شما احتمالاً با چندین پیکربندی کامپایلر پیش‌ساخته همراه است. برای بررسی اینکه چه کامپایلرهایی دارید، دستور زیر را اجرا کنید:

```shell
:e $VIMRUNTIME/compiler/<Tab>
```

شما باید فهرستی از کامپایلرها برای زبان‌های برنامه‌نویسی مختلف را ببینید.

برای استفاده از دستور `:compiler`، فرض کنید شما یک فایل روبی دارید، `hello.rb` و درون آن:

```shell
puts "Hello ruby"
```

به یاد داشته باشید که اگر شما `:make` را اجرا کنید، ویم هر دستوری را که به `makeprg` اختصاص داده شده است، اجرا می‌کند (پیش‌فرض `make` است). اگر شما اجرا کنید:

```shell
:compiler ruby
```

ویم اسکریپت `$VIMRUNTIME/compiler/ruby.vim` را اجرا کرده و `makeprg` را به استفاده از دستور `ruby` تغییر می‌دهد. حالا اگر شما `:set makeprg?` را اجرا کنید، باید بگوید `makeprg=ruby` (این بستگی به آنچه در فایل `$VIMRUNTIME/compiler/ruby.vim` شما وجود دارد یا اگر شما کامپایلرهای روبی سفارشی دیگری دارید، دارد). دستور `:compiler {your-lang}` به شما اجازه می‌دهد تا به سرعت به کامپایلرهای مختلف سوئیچ کنید. این برای پروژه‌هایی که از چندین زبان استفاده می‌کنند، مفید است.

شما نیازی به استفاده از `:compiler` و `makeprg` برای کامپایل یک برنامه ندارید. شما می‌توانید یک اسکریپت تست اجرا کنید، یک فایل را lint کنید، یک سیگنال ارسال کنید یا هر چیزی که می‌خواهید انجام دهید.

## ایجاد یک کامپایلر سفارشی

بیایید یک کامپایلر ساده Typescript ایجاد کنیم. Typescript را به ماشین خود نصب کنید (`npm install -g typescript`). شما اکنون باید دستور `tsc` را داشته باشید. اگر قبلاً با Typescript کار نکرده‌اید، `tsc` یک فایل Typescript را به یک فایل Javascript کامپایل می‌کند. فرض کنید که شما یک فایل دارید، `hello.ts`:

```shell
const hello = "hello";
console.log(hello);
```

اگر شما `tsc hello.ts` را اجرا کنید، به `hello.js` کامپایل می‌شود. با این حال، اگر شما عبارات زیر را درون `hello.ts` داشته باشید:

```shell
const hello = "hello";
hello = "hello again";
console.log(hello);
```

این خطا خواهد داد زیرا شما نمی‌توانید یک متغیر `const` را تغییر دهید. اجرای `tsc hello.ts` خطای زیر را خواهد داد:

```shell
hello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.

2 person = "hello again";
  ~~~~~~


Found 1 error.
```

برای ایجاد یک کامپایلر ساده Typescript، در دایرکتوری `~/.vim/` خود، یک دایرکتوری `compiler` ایجاد کنید (`~/.vim/compiler/`)، سپس یک فایل `typescript.vim` ایجاد کنید (`~/.vim/compiler/typescript.vim`). این موارد را درون آن قرار دهید:

```shell
CompilerSet makeprg=tsc
CompilerSet errorformat=%f:\ %m
```

خط اول `makeprg` را برای اجرای دستور `tsc` تنظیم می‌کند. خط دوم فرمت خطا را برای نمایش فایل (`%f`)، به دنبال یک دو نقطه (`:`) و یک فضای فرار (`\ `)، به دنبال پیام خطا (`%m`) تنظیم می‌کند. برای یادگیری بیشتر در مورد فرمت خطا، به `:h errorformat` مراجعه کنید.

شما همچنین باید برخی از کامپایلرهای پیش‌ساخته را بخوانید تا ببینید دیگران چگونه این کار را انجام می‌دهند. به `:e $VIMRUNTIME/compiler/<some-language>.vim` مراجعه کنید.

زیرا برخی از پلاگین‌ها ممکن است با فایل Typescript تداخل داشته باشند، بیایید فایل `hello.ts` را بدون هیچ پلاگینی باز کنیم، با استفاده از پرچم `--noplugin`:

```shell
vim --noplugin hello.ts
```

`makeprg` را بررسی کنید:

```shell
:set makeprg?
```

باید بگوید برنامه پیش‌فرض `make` است. برای استفاده از کامپایلر جدید Typescript، دستور زیر را اجرا کنید:

```shell
:compiler typescript
```

زمانی که شما `:set makeprg?` را اجرا می‌کنید، باید بگوید `tsc` حالا. بیایید آن را آزمایش کنیم. اجرا کنید:

```shell
:make %
```

به یاد داشته باشید که `%` به معنای فایل فعلی است. ببینید کامپایلر Typescript شما به درستی کار می‌کند! برای مشاهده لیست خطاها، دستور `:copen` را اجرا کنید.

## کامپایلر Async

گاهی اوقات کامپایل کردن ممکن است زمان زیادی ببرد. شما نمی‌خواهید در حین انتظار برای اتمام فرایند کامپایل، به یک ویم یخ‌زده خیره شوید. آیا خوب نیست اگر بتوانید به صورت غیرهمزمان کامپایل کنید تا همچنان در حین کامپایل از ویم استفاده کنید؟

خوشبختانه پلاگین‌هایی برای اجرای فرایندهای غیرهمزمان وجود دارد. دو مورد بزرگ عبارتند از:

- [vim-dispatch](https://github.com/tpope/vim-dispatch)
- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)

در باقی‌مانده این فصل، من به vim-dispatch می‌پردازم، اما به شدت توصیه می‌کنم که همه آن‌ها را امتحان کنید.

*ویم و نئو ویم در واقع از مشاغل غیرهمزمان پشتیبانی می‌کنند، اما این موضوع فراتر از دامنه این فصل است. اگر کنجکاو هستید، به `:h job-channel-overview.txt` مراجعه کنید.*

## پلاگین: Vim-dispatch

Vim-dispatch چندین دستور دارد، اما دو دستور اصلی آن `:Make` و `:Dispatch` هستند.

### Make غیرهمزمان

دستور `:Make` ویم-dispatch مشابه `:make` ویم است، اما به صورت غیرهمزمان اجرا می‌شود. اگر شما در یک پروژه جاوا اسکریپت هستید و نیاز دارید `npm t` را اجرا کنید، ممکن است سعی کنید `makeprg` خود را به این صورت تنظیم کنید:

```shell
:set makeprg=npm\\ t
```

اگر شما اجرا کنید:

```shell
:make
```

ویم `npm t` را اجرا می‌کند، اما شما به صفحه یخ‌زده خیره خواهید شد در حالی که تست جاوا اسکریپت شما در حال اجرا است. با vim-dispatch، شما فقط می‌توانید اجرا کنید:

```shell
:Make
```

ویم `npm t` را به صورت غیرهمزمان اجرا می‌کند. به این ترتیب، در حالی که `npm t` در یک فرایند پس‌زمینه در حال اجرا است، می‌توانید به کارهایی که انجام می‌دادید ادامه دهید. عالی!

### Dispatch غیرهمزمان

دستور `:Dispatch` شبیه به دستور `:compiler` و دستور `:!` است. این می‌تواند هر دستور خارجی را به صورت غیرهمزمان در ویم اجرا کند.

فرض کنید که شما در یک فایل مشخص روبی هستید و نیاز دارید یک تست را اجرا کنید. اجرا کنید:

```shell
:Dispatch bundle exec rspec %
```

ویم دستور `rspec` را به صورت غیرهمزمان بر روی فایل فعلی (`%`) اجرا خواهد کرد.

### اتوماسیون Dispatch

Vim-dispatch دارای متغیر بافر `b:dispatch` است که می‌توانید آن را برای ارزیابی دستور خاص به طور خودکار پیکربندی کنید. می‌توانید از آن با `autocmd` استفاده کنید. اگر این را در vimrc خود اضافه کنید:

```shell
autocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'
```

حالا هر بار که وارد فایلی (`BufEnter`) می‌شوید که با `_spec.rb` پایان می‌یابد، اجرای `:Dispatch` به طور خودکار `bundle exec rspec {your-current-ruby-spec-file}` را اجرا می‌کند.

## یادگیری کامپایل به روش هوشمند

در این فصل، شما یاد گرفتید که می‌توانید از دستورات `make` و `compiler` برای اجرای *هر* فرایند از داخل ویم به صورت غیرهمزمان برای تکمیل جریان کار برنامه‌نویسی خود استفاده کنید. توانایی ویم برای گسترش خود با برنامه‌های دیگر آن را قدرتمند می‌سازد.