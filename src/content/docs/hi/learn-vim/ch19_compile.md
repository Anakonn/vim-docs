---
description: इस दस्तावेज़ में, आप Vim से संकलन करने की प्रक्रिया और Vim के `:make`
  कमांड का उपयोग कैसे करें, यह सीखेंगे।
title: Ch19. Compile
---

संकलन कई भाषाओं के लिए एक महत्वपूर्ण विषय है। इस अध्याय में, आप सीखेंगे कि Vim से कैसे संकलित करें। आप Vim के `:make` कमांड का लाभ उठाने के तरीकों पर भी नज़र डालेंगे।

## कमांड लाइन से संकलित करें

आप संकलन के लिए बैंग ऑपरेटर (`!`) का उपयोग कर सकते हैं। यदि आपको अपने `.cpp` फ़ाइल को `g++` के साथ संकलित करने की आवश्यकता है, तो चलाएँ:

```shell
:!g++ hello.cpp -o hello
```

हालांकि, हर बार फ़ाइल का नाम और आउटपुट फ़ाइल का नाम मैन्युअल रूप से टाइप करना त्रुटि-प्रवण और थकाऊ है। एक मेकफ़ाइल सबसे अच्छा तरीका है।

## मेक कमांड

Vim में मेकफ़ाइल चलाने के लिए `:make` कमांड है। जब आप इसे चलाते हैं, Vim वर्तमान निर्देशिका में एक मेकफ़ाइल की तलाश करता है।

वर्तमान निर्देशिका में `makefile` नामक एक फ़ाइल बनाएं और इसके अंदर ये डालें:

```shell
all:
	echo "Hello all"
foo:
	echo "Hello foo"
list_pls:
	ls
```

इसे Vim से चलाएँ:

```shell
:make
```

Vim इसे उसी तरह निष्पादित करता है जैसे आप इसे टर्मिनल से चला रहे हैं। `:make` कमांड टर्मिनल मेक कमांड की तरह ही पैरामीटर स्वीकार करता है। चलाएँ:

```shell
:make foo
" आउटपुट "Hello foo"

:make list_pls
" ls कमांड का परिणाम आउटपुट करता है
```

`:make` कमांड किसी भी त्रुटि को स्टोर करने के लिए Vim के क्विकफिक्स का उपयोग करता है यदि आप एक गलत कमांड चलाते हैं। चलिए एक गैर-मौजूद लक्ष्य चलाते हैं:

```shell
:make dontexist
```

आपको उस कमांड को चलाते समय एक त्रुटि दिखाई देनी चाहिए। उस त्रुटि को देखने के लिए, क्विकफिक्स कमांड `:copen` चलाएँ ताकि क्विकफिक्स विंडो दिखाई दे:

```shell
|| make: *** No rule to make target `dontexist'.  Stop.
```

## मेक के साथ संकलन

आइए मेकफ़ाइल का उपयोग करके एक बुनियादी `.cpp` प्रोग्राम संकलित करें। पहले, आइए एक `hello.cpp` फ़ाइल बनाते हैं:

```shell
#include <iostream>

int main() {
    std::cout << "Hello!\n";
    return 0;
}
```

अपने मेकफ़ाइल को अपडेट करें ताकि एक `.cpp` फ़ाइल का निर्माण और चलाया जा सके:

```shell
all:
	echo "build, run"
build:
	g++ hello.cpp -o hello
run:
	./hello
```

अब चलाएँ:

```shell
:make build
```

`g++` `./hello.cpp` को संकलित करता है और `./hello` बनाता है। फिर चलाएँ:

```shell
:make run
```

आपको टर्मिनल पर `"Hello!"` प्रिंट होते हुए दिखाई देना चाहिए।

## विभिन्न मेक प्रोग्राम

जब आप `:make` चलाते हैं, तो वास्तव में Vim उस कमांड को चलाता है जो `makeprg` विकल्प के तहत सेट है। यदि आप चलाते हैं `:set makeprg?`, तो आप देखेंगे:

```shell
makeprg=make
```

डिफ़ॉल्ट `:make` कमांड `make` बाहरी कमांड है। प्रत्येक बार `:make` कमांड को `g++ {your-file-name}` निष्पादित करने के लिए बदलने के लिए, चलाएँ:

```shell
:set makeprg=g++\ %
```

`g++` के बाद स्पेस को एस्केप करने के लिए `\` है। Vim में `%` प्रतीक वर्तमान फ़ाइल का प्रतिनिधित्व करता है। कमांड `g++\\ %` `g++ hello.cpp` चलाने के बराबर है।

`./hello.cpp` पर जाएँ फिर `:make` चलाएँ। Vim `hello.cpp` को संकलित करता है और `a.out` बनाता है क्योंकि आपने आउटपुट निर्दिष्ट नहीं किया। इसे इस तरह से रिफ़ैक्टर करें कि यह संकलित आउटपुट का नाम मूल फ़ाइल के नाम के बिना एक्सटेंशन के साथ रखे। इसे चलाएँ या इसे vimrc में जोड़ें:

```shell
set makeprg=g++\ %\ -o\ %<
```

विवरण:
- `g++\ %` ऊपर के समान है। यह `g++ <your-file>` चलाने के बराबर है।
- `-o` आउटपुट विकल्प है।
- `%<` Vim में वर्तमान फ़ाइल नाम को बिना एक्सटेंशन के दर्शाता है (`hello.cpp` `hello` बन जाता है)।

जब आप `./hello.cpp` के अंदर से `:make` चलाते हैं, तो यह `./hello` में संकलित होता है। `./hello` को `./hello.cpp` के अंदर से जल्दी से निष्पादित करने के लिए, चलाएँ `:!./%<`। फिर से, यह `:!./{current-file-name-minus-the-extension}` चलाने के समान है।

अधिक जानकारी के लिए, `:h :compiler` और `:h write-compiler-plugin` देखें।

## सहेजने पर स्वचालित संकलन

आप संकलन को स्वचालित करके जीवन को और भी आसान बना सकते हैं। याद रखें कि आप Vim के `autocmd` का उपयोग करके कुछ घटनाओं के आधार पर स्वचालित क्रियाएँ ट्रिगर कर सकते हैं। प्रत्येक सहेजने पर `.cpp` फ़ाइलों को स्वचालित रूप से संकलित करने के लिए इसे अपने vimrc में जोड़ें:

```shell
autocmd BufWritePost *.cpp make
```

जब भी आप `.cpp` फ़ाइल के अंदर सहेजते हैं, Vim `make` कमांड निष्पादित करता है।

## संकलक स्विच करना

Vim में संकलकों को जल्दी से स्विच करने के लिए `:compiler` कमांड है। आपकी Vim बिल्ड शायद कई पूर्व-निर्मित संकलक कॉन्फ़िगरेशन के साथ आती है। यह देखने के लिए कि आपके पास कौन से संकलक हैं, चलाएँ:

```shell
:e $VIMRUNTIME/compiler/<Tab>
```

आपको विभिन्न प्रोग्रामिंग भाषाओं के लिए संकलकों की एक सूची दिखाई देनी चाहिए।

`:compiler` कमांड का उपयोग करने के लिए, मान लीजिए कि आपके पास एक रूबी फ़ाइल है, `hello.rb` और इसके अंदर है:

```shell
puts "Hello ruby"
```

याद रखें कि यदि आप `:make` चलाते हैं, तो Vim उस कमांड को निष्पादित करता है जो `makeprg` को असाइन की गई है (डिफ़ॉल्ट `make` है)। यदि आप चलाते हैं:

```shell
:compiler ruby
```

Vim `$VIMRUNTIME/compiler/ruby.vim` स्क्रिप्ट को चलाता है और `makeprg` को `ruby` कमांड का उपयोग करने के लिए बदलता है। अब यदि आप चलाते हैं `:set makeprg?`, तो यह `makeprg=ruby` कहेगा (यह इस पर निर्भर करता है कि आपके `$VIMRUNTIME/compiler/ruby.vim` फ़ाइल के अंदर क्या है या यदि आपके पास अन्य कस्टम रूबी संकलक हैं। आपके पास भिन्न हो सकते हैं)। `:compiler {your-lang}` कमांड आपको विभिन्न संकलकों में जल्दी से स्विच करने की अनुमति देती है। यह उपयोगी है यदि आपके प्रोजेक्ट में कई भाषाएँ हैं।

आपको एक प्रोग्राम संकलित करने के लिए `:compiler` और `makeprg` का उपयोग करने की आवश्यकता नहीं है। आप एक परीक्षण स्क्रिप्ट चला सकते हैं, एक फ़ाइल को लिंट कर सकते हैं, एक सिग्नल भेज सकते हैं, या जो चाहें कर सकते हैं।

## एक कस्टम संकलक बनाना

आइए एक सरल टाइपस्क्रिप्ट संकलक बनाते हैं। अपने मशीन पर टाइपस्क्रिप्ट इंस्टॉल करें (`npm install -g typescript`)। अब आपके पास `tsc` कमांड होना चाहिए। यदि आपने पहले टाइपस्क्रिप्ट के साथ काम नहीं किया है, तो `tsc` एक टाइपस्क्रिप्ट फ़ाइल को एक जावास्क्रिप्ट फ़ाइल में संकलित करता है। मान लीजिए कि आपके पास एक फ़ाइल है, `hello.ts`:

```shell
const hello = "hello";
console.log(hello);
```

यदि आप `tsc hello.ts` चलाते हैं, तो यह `hello.js` में संकलित होगा। हालाँकि, यदि आपके पास `hello.ts` के अंदर निम्नलिखित अभिव्यक्तियाँ हैं:

```shell
const hello = "hello";
hello = "hello again";
console.log(hello);
```

यह एक त्रुटि फेंकेगा क्योंकि आप `const` चर को परिवर्तित नहीं कर सकते। `tsc hello.ts` चलाने पर त्रुटि आएगी:

```shell
hello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.

2 person = "hello again";
  ~~~~~~


Found 1 error.
```

एक सरल टाइपस्क्रिप्ट संकलक बनाने के लिए, अपने `~/.vim/` निर्देशिका में, एक `compiler` निर्देशिका जोड़ें (`~/.vim/compiler/`), फिर एक `typescript.vim` फ़ाइल बनाएं (`~/.vim/compiler/typescript.vim`)। इसके अंदर यह डालें:

```shell
CompilerSet makeprg=tsc
CompilerSet errorformat=%f:\ %m
```

पहली पंक्ति `makeprg` को `tsc` कमांड चलाने के लिए सेट करती है। दूसरी पंक्ति त्रुटि प्रारूप को फ़ाइल (`%f`) के साथ प्रदर्शित करने के लिए सेट करती है, उसके बाद एक शाब्दिक कॉलन (`:`) और एक एस्केप स्पेस (`\ `), उसके बाद त्रुटि संदेश (`%m`)। त्रुटि प्रारूपण के बारे में अधिक जानने के लिए, `:h errorformat` देखें।

आपको यह देखने के लिए कुछ पूर्व-निर्मित संकलकों को भी पढ़ना चाहिए कि अन्य लोग इसे कैसे करते हैं। `:e $VIMRUNTIME/compiler/<some-language>.vim` देखें।

चूंकि कुछ प्लगइन्स टाइपस्क्रिप्ट फ़ाइल में हस्तक्षेप कर सकते हैं, आइए `--noplugin` फ़्लैग का उपयोग करके `hello.ts` को बिना किसी प्लगइन के खोलें:

```shell
vim --noplugin hello.ts
```

`makeprg` की जांच करें:

```shell
:set makeprg?
```

यह डिफ़ॉल्ट `make` प्रोग्राम कहेगा। नए टाइपस्क्रिप्ट संकलक का उपयोग करने के लिए, चलाएँ:

```shell
:compiler typescript
```

जब आप `:set makeprg?` चलाते हैं, तो यह अब `tsc` कहेगा। आइए इसे परीक्षण में डालते हैं। चलाएँ:

```shell
:make %
```

याद रखें कि `%` वर्तमान फ़ाइल का अर्थ है। अपने टाइपस्क्रिप्ट संकलक को अपेक्षित रूप से काम करते हुए देखें! त्रुटियों की सूची देखने के लिए, चलाएँ `:copen`।

## असिंक्रोनस संकलक

कभी-कभी संकलन में लंबा समय लग सकता है। आप नहीं चाहते कि आप अपने संकलन प्रक्रिया के समाप्त होने की प्रतीक्षा करते हुए एक फ्रीज़ किए गए Vim को घूरते रहें। क्या यह अच्छा नहीं होगा यदि आप असिंक्रोनस रूप से संकलित कर सकें ताकि आप संकलन के दौरान भी Vim का उपयोग कर सकें?

भाग्य से, असिंक्रोनस प्रक्रियाओं को चलाने के लिए प्लगइन्स हैं। दो बड़े हैं:

- [vim-dispatch](https://github.com/tpope/vim-dispatch)
- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)

इस अध्याय के शेष भाग में, मैं vim-dispatch के बारे में बताऊंगा, लेकिन मैं आपको सभी को आजमाने के लिए दृढ़ता से प्रोत्साहित करूंगा।

*Vim और NeoVim वास्तव में असिंक्रोनस नौकरियों का समर्थन करते हैं, लेकिन वे इस अध्याय के दायरे से परे हैं। यदि आप जिज्ञासु हैं, तो `:h job-channel-overview.txt` देखें।*

## प्लगइन: Vim-dispatch

Vim-dispatch में कई कमांड हैं, लेकिन दो मुख्य हैं `:Make` और `:Dispatch` कमांड।

### असिंक्रोनस मेक

Vim-dispatch का `:Make` कमांड Vim के `:make` के समान है, लेकिन यह असिंक्रोनस रूप से चलता है। यदि आप एक जावास्क्रिप्ट प्रोजेक्ट में हैं और आपको `npm t` चलाना है, तो आप अपने makeprg को सेट करने का प्रयास कर सकते हैं:

```shell
:set makeprg=npm\\ t
```

यदि आप चलाते हैं:

```shell
:make
```

Vim `npm t` को निष्पादित करेगा, लेकिन आप अपनी जावास्क्रिप्ट परीक्षण चलाते समय एक फ्रीज़ स्क्रीन को घूर रहे होंगे। vim-dispatch के साथ, आप बस चलाएँ:

```shell
:Make
```

Vim `npm t` को असिंक्रोनस रूप से चलाएगा। इस तरह, जबकि `npm t` एक बैकग्राउंड प्रक्रिया पर चल रहा है, आप जो भी कर रहे थे, उसे जारी रख सकते हैं। शानदार!

### असिंक्रोनस डिस्पैच

`:Dispatch` कमांड `:compiler` और `:!` कमांड की तरह है। यह Vim में किसी भी बाहरी कमांड को असिंक्रोनस रूप से चला सकता है।

मान लें कि आप एक रूबी स्पेक फ़ाइल के अंदर हैं और आपको एक परीक्षण चलाना है। चलाएँ:

```shell
:Dispatch bundle exec rspec %
```

Vim वर्तमान फ़ाइल (`%`) के खिलाफ `rspec` कमांड को असिंक्रोनस रूप से चलाएगा।

### डिस्पैच को स्वचालित करना

Vim-dispatch में `b:dispatch` बफ़र वेरिएबल है जिसे आप विशिष्ट कमांड को स्वचालित रूप से मूल्यांकित करने के लिए कॉन्फ़िगर कर सकते हैं। आप इसे `autocmd` के साथ उपयोग कर सकते हैं। यदि आप इसे अपने vimrc में जोड़ते हैं:

```shell
autocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'
```

अब जब भी आप एक फ़ाइल (`BufEnter`) में प्रवेश करते हैं जो `_spec.rb` के साथ समाप्त होती है, तो `:Dispatch` चलाने से स्वचालित रूप से `bundle exec rspec {your-current-ruby-spec-file}` निष्पादित होता है।

## स्मार्ट तरीके से संकलन सीखें

इस अध्याय में, आपने सीखा कि आप `make` और `compiler` कमांड का उपयोग करके *किसी भी* प्रक्रिया को Vim के अंदर असिंक्रोनस रूप से चला सकते हैं ताकि आपकी प्रोग्रामिंग कार्यप्रवाह को पूरा किया जा सके। Vim की अन्य प्रोग्रामों के साथ खुद को विस्तारित करने की क्षमता इसे शक्तिशाली बनाती है।