---
description: यह दस्तावेज़ Vim प्लगइन 'totitle-vim' के विकास की प्रक्रिया को समझाता
  है, जो शीर्षक केस को स्वचालित करने के लिए एक उपयोगी उपकरण है।
title: 'Ch29. Write a Plugin: Creating a Titlecase Operator'
---

जब आप Vim में अच्छे होने लगते हैं, तो आप अपने स्वयं के प्लगइन्स लिखना चाह सकते हैं। मैंने हाल ही में अपना पहला Vim प्लगइन लिखा, [totitle-vim](https://github.com/iggredible/totitle-vim)। यह एक टाइटलकेस ऑपरेटर प्लगइन है, जो Vim के अपरकेस `gU`, लोअरकेस `gu`, और टॉगलकेस `g~` ऑपरेटरों के समान है।

इस अध्याय में, मैं `totitle-vim` प्लगइन का विश्लेषण प्रस्तुत करूंगा। मुझे उम्मीद है कि मैं प्रक्रिया पर कुछ प्रकाश डाल सकूंगा और शायद आपको अपना अनोखा प्लगइन बनाने के लिए प्रेरित कर सकूं!

## समस्या

मैं अपने लेख लिखने के लिए Vim का उपयोग करता हूं, जिसमें यह गाइड भी शामिल है।

एक मुख्य समस्या थी शीर्षकों के लिए एक उचित टाइटल केस बनाना। इसे स्वचालित करने का एक तरीका यह है कि शीर्षक में प्रत्येक शब्द को `g/^#/ s/\<./\u\0/g` के साथ बड़े अक्षरों में लिखा जाए। बुनियादी उपयोग के लिए, यह कमांड पर्याप्त था, लेकिन यह अभी भी एक वास्तविक टाइटल केस होने के रूप में अच्छा नहीं है। "Capitalize The First Letter Of Each Word" में "The" और "Of" शब्दों को बड़े अक्षरों में लिखा जाना चाहिए। उचित बड़े अक्षरों के बिना, वाक्य थोड़ा अजीब दिखता है।

शुरुआत में, मैं एक प्लगइन लिखने की योजना नहीं बना रहा था। इसके अलावा, यह पता चला कि पहले से ही एक टाइटलकेस प्लगइन है: [vim-titlecase](https://github.com/christoomey/vim-titlecase)। हालांकि, कुछ चीजें थीं जो ठीक उसी तरह काम नहीं कर रही थीं जैसे मैं चाहता था। मुख्य समस्या ब्लॉकवाइज विजुअल मोड व्यवहार थी। यदि मेरे पास वाक्यांश है:

```shell
test title one
test title two
test title three
```

यदि मैं "tle" पर एक ब्लॉक विजुअल हाईलाइट का उपयोग करता हूं:

```shell
test ti[tle] one
test ti[tle] two
test ti[tle] three
```

यदि मैं `gt` दबाता हूं, तो प्लगइन इसे बड़े अक्षरों में नहीं लिखेगा। मुझे यह `gu`, `gU`, और `g~` के व्यवहार के साथ असंगत लगता है। इसलिए मैंने उस टाइटलकेस प्लगइन रेपो से काम करने का निर्णय लिया और इसका उपयोग करके अपने लिए एक टाइटलकेस प्लगइन बनाया जो `gu`, `gU`, और `g~` के साथ संगत है! फिर से, vim-titlecase प्लगइन स्वयं एक उत्कृष्ट प्लगइन है और इसका अपने आप में उपयोग किया जाना चाहिए (सच्चाई यह है, शायद गहराई में मैं बस अपना खुद का Vim प्लगइन लिखना चाहता था। मुझे वास्तव में ब्लॉकवाइज टाइटलकेसिंग फीचर का उपयोग वास्तविक जीवन में अक्सर नहीं होता है, केवल किनारे के मामलों के अलावा)।

### प्लगइन की योजना बनाना

पहली कोड की पंक्ति लिखने से पहले, मुझे यह तय करना होगा कि टाइटलकेस नियम क्या हैं। मैंने [titlecaseconverter साइट](https://titlecaseconverter.com/rules/) से विभिन्न बड़े अक्षर नियमों की एक अच्छी तालिका पाई। क्या आप जानते हैं कि अंग्रेजी भाषा में कम से कम 8 विभिन्न बड़े अक्षर नियम हैं? *गैसप!*

अंत में, मैंने उस सूची से सामान्य भाजकों का उपयोग करके प्लगइन के लिए एक अच्छा पर्याप्त बुनियादी नियम तैयार किया। इसके अलावा, मुझे संदेह है कि लोग शिकायत करेंगे, "अरे आदमी, आप AMA का उपयोग कर रहे हैं, आप APA का उपयोग क्यों नहीं कर रहे?"। यहाँ बुनियादी नियम हैं:
- पहला शब्द हमेशा बड़े अक्षरों में होता है।
- कुछ क्रियाविशेषण, संयोजक, और पूर्वसर्ग छोटे अक्षरों में होते हैं।
- यदि इनपुट शब्द पूरी तरह से बड़े अक्षरों में है, तो कुछ नहीं करें (यह एक संक्षिप्त रूप हो सकता है)।

जिन शब्दों को छोटे अक्षरों में लिखा गया है, विभिन्न नियमों की विभिन्न सूचियाँ हैं। मैंने `a an and at but by en for in nor of off on or out per so the to up yet vs via` के साथ रहने का निर्णय लिया।

### उपयोगकर्ता इंटरफ़ेस की योजना बनाना

मैं चाहता हूं कि प्लगइन एक ऑपरेटर हो जो Vim के मौजूदा केस ऑपरेटरों: `gu`, `gU`, और `g~` का पूरक हो। एक ऑपरेटर होने के नाते, इसे या तो एक मोशन या एक टेक्स्ट ऑब्जेक्ट स्वीकार करना चाहिए (`gtw` को अगले शब्द को टाइटलकेस करना चाहिए, `gtiw` को आंतरिक शब्द को टाइटलकेस करना चाहिए, `gt$` को वर्तमान स्थान से लेकर पंक्ति के अंत तक के शब्दों को टाइटलकेस करना चाहिए, `gtt` को वर्तमान पंक्ति को टाइटलकेस करना चाहिए, `gti(` को कोष्ठकों के अंदर के शब्दों को टाइटलकेस करना चाहिए, आदि)। मैं चाहता हूं कि इसे आसान स्मरण के लिए `gt` पर मैप किया जाए। इसके अलावा, इसे सभी विजुअल मोड के साथ भी काम करना चाहिए: `v`, `V`, और `Ctrl-V`। मुझे इसे *किसी भी* विजुअल मोड में हाइलाइट करने में सक्षम होना चाहिए, `gt` दबाना चाहिए, फिर सभी हाइलाइट किए गए टेक्स्ट टाइटलकेस हो जाएंगे।

## Vim रनटाइम

जब आप रेपो को देखते हैं तो सबसे पहली चीज़ जो आप देखते हैं वह है कि इसमें दो निर्देशिकाएँ हैं: `plugin/` और `doc/`। जब आप Vim शुरू करते हैं, तो यह `~/.vim` निर्देशिका के अंदर विशेष फ़ाइलों और निर्देशिकाओं की तलाश करता है और उस निर्देशिका के अंदर सभी स्क्रिप्ट फ़ाइलों को चलाता है। अधिक जानकारी के लिए, Vim रनटाइम अध्याय की समीक्षा करें।

प्लगइन दो Vim रनटाइम निर्देशिकाओं का उपयोग करता है: `doc/` और `plugin/`। `doc/` एक जगह है जहाँ मदद दस्तावेज़ रखा जाता है (ताकि आप बाद में कीवर्ड खोज सकें, जैसे `:h totitle`)। मैं बाद में मदद पृष्ठ बनाने के तरीके पर चर्चा करूंगा। अभी, चलो `plugin/` पर ध्यान केंद्रित करते हैं। `plugin/` निर्देशिका एक बार तब निष्पादित होती है जब Vim बूट होता है। इस निर्देशिका के अंदर एक फ़ाइल है: `totitle.vim`। नाम का कोई महत्व नहीं है (मैंने इसे `whatever.vim` नाम दिया होता और यह फिर भी काम करता)। प्लगइन के काम करने के लिए जिम्मेदार सभी कोड इस फ़ाइल के अंदर हैं।

## मैपिंग

चलो कोड के माध्यम से चलते हैं!

फ़ाइल की शुरुआत में, आपके पास है:

```shell
if !exists('g:totitle_default_keys')
  let g:totitle_default_keys = 1
endif
```

जब आप Vim शुरू करते हैं, `g:totitle_default_keys` अभी तक मौजूद नहीं होगा, इसलिए `!exists(...)` सत्य लौटाता है। इस मामले में, `g:totitle_default_keys` को 1 के बराबर परिभाषित करें। Vim में, 0 झूठा है और गैर-शून्य सत्य है (सत्य का संकेत देने के लिए 1 का उपयोग करें)।

चलो फ़ाइल के नीचे चलते हैं। आप यह देखेंगे:

```shell
if g:totitle_default_keys
  nnoremap <expr> gt ToTitle()
  xnoremap <expr> gt ToTitle()
  nnoremap <expr> gtt ToTitle() .. '_'
endif
```

यहाँ मुख्य `gt` मैपिंग परिभाषित की गई है। इस मामले में, जब आप फ़ाइल के नीचे `if` शर्तों पर पहुँचते हैं, तो `if g:totitle_default_keys` 1 (सत्य) लौटाएगा, इसलिए Vim निम्नलिखित मैप करता है:
- `nnoremap <expr> gt ToTitle()` सामान्य मोड *ऑपरेटर* को मैप करता है। यह आपको ऑपरेटर + मोशन/टेक्स्ट-ऑब्जेक्ट जैसे `gtw` को अगले शब्द को टाइटलकेस करने या `gtiw` को आंतरिक शब्द को टाइटलकेस करने की अनुमति देता है। मैं बाद में ऑपरेटर मैपिंग के काम करने के विवरण पर चर्चा करूंगा।
- `xnoremap <expr> gt ToTitle()` विजुअल मोड ऑपरेटरों को मैप करता है। यह आपको दृश्य रूप से हाइलाइट किए गए टेक्स्ट को टाइटलकेस करने की अनुमति देता है।
- `nnoremap <expr> gtt ToTitle() .. '_'` सामान्य मोड लाइनवाइज ऑपरेटर को मैप करता है (जो `guu` और `gUU` के समान है)। आप सोच सकते हैं कि अंत में `.. '_'` क्या करता है। `..` Vim का स्ट्रिंग इंटरपोलेशन ऑपरेटर है। `_` एक ऑपरेटर के साथ एक मोशन के रूप में उपयोग किया जाता है। यदि आप `:help _` में देखते हैं, तो यह कहता है कि अंडरस्कोर का उपयोग 1 पंक्ति नीचे गिनने के लिए किया जाता है। यह वर्तमान पंक्ति पर एक ऑपरेटर करता है (अन्य ऑपरेटरों के साथ इसे आजमाएं, `gU_` या `d_` चलाने की कोशिश करें, ध्यान दें कि यह `gUU` या `dd` के समान कार्य करता है)।
- अंत में, `<expr>` तर्क आपको गिनती निर्दिष्ट करने की अनुमति देता है, इसलिए आप `3gtw` कर सकते हैं ताकि अगले 3 शब्दों को टॉगलकेस किया जा सके।

अगर आप डिफ़ॉल्ट `gt` मैपिंग का उपयोग नहीं करना चाहते? आखिरकार, आप Vim के डिफ़ॉल्ट `gt` (टैब अगला) मैपिंग को ओवरराइड कर रहे हैं। अगर आप `gt` के बजाय `gz` का उपयोग करना चाहते हैं? क्या आप पहले `if !exists('g:totitle_default_keys')` और `if g:totitle_default_keys` की जांच करने की परेशानी में गए थे? यदि आप अपने vimrc में `let g:totitle_default_keys = 0` डालते हैं, तो `g:totitle_default_keys` पहले से ही मौजूद होगा जब प्लगइन चलाया जाएगा (आपके vimrc में कोड `plugin/` रनटाइम फ़ाइलों से पहले निष्पादित होते हैं), इसलिए `!exists('g:totitle_default_keys')` झूठा लौटाता है। इसके अलावा, `if g:totitle_default_keys` झूठा होगा (क्योंकि इसका मान 0 होगा), इसलिए यह `gt` मैपिंग को भी निष्पादित नहीं करेगा! यह प्रभावी रूप से आपको Vimrc में अपनी कस्टम मैपिंग परिभाषित करने की अनुमति देता है।

अपने खुद के टाइटलकेस मैपिंग को `gz` परिभाषित करने के लिए, अपने vimrc में यह जोड़ें:

```shell
let g:totitle_default_keys = 0

nnoremap <expr> gz ToTitle()
xnoremap <expr> gz ToTitle()
nnoremap <expr> gzz ToTitle() .. '_'
```

आसान है।

## ToTitle फ़ंक्शन

`ToTitle()` फ़ंक्शन इस फ़ाइल में सबसे लंबा फ़ंक्शन है।

```shell
 function! ToTitle(type = '')
  if a:type ==# ''
    set opfunc=ToTitle
    return 'g@'
  endif

  " invoke this when calling the ToTitle() function
  if a:type != 'block' && a:type != 'line' && a:type != 'char'
    let l:words = a:type
    let l:wordsArr = trim(l:words)->split('\s\+')
    call map(l:wordsArr, 's:capitalize(v:val)')
    return l:wordsArr->join(' ')
  endif

  " save the current settings
  let l:sel_save = &selection
  let l:reg_save = getreginfo('"')
  let l:cb_save = &clipboard
  let l:visual_marks_save = [getpos("'<"), getpos("'>")]

  try
    set clipboard= selection=inclusive
    let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
    let l:selected_phrase = getreg('"')
    let l:WORD_PATTERN = '\<\k*\>'
    let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

    let l:startLine = line("'<")
    let l:startCol = virtcol(".")

    " when user calls a block operation
    if a:type ==# "block"
      sil! keepj norm! gv"ad
      keepj $
      keepj pu_

      let l:lastLine = line("$")

      sil! keepj norm "ap

      let l:curLine = line(".")

      sil! keepj norm! VGg@
      exe "keepj norm! 0\<c-v>G$h\"ad"
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
      exe "keepj " . l:lastLine
      sil! keepj norm! "_dG
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"

    " when user calls a char or line operation
    else
      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
      let l:titlecased = s:capitalizeFirstWord(l:titlecased)
      call setreg('"', l:titlecased)
      let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
      silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"
    endif
  finally

    " restore the settings
    call setreg('"', l:reg_save)
    call setpos("'<", l:visual_marks_save[0])
    call setpos("'>", l:visual_marks_save[1])
    let &clipboard = l:cb_save
    let &selection = l:sel_save
  endtry
  return
endfunction
```

यह बहुत लंबा है, इसलिए चलो इसे तोड़ते हैं।

*मैं इसे छोटे हिस्सों में पुनर्गठित कर सकता था, लेकिन इस अध्याय को पूरा करने के लिए, मैंने इसे जैसा है वैसा ही छोड़ दिया।*
## ऑपरेटर फ़ंक्शन

यहाँ कोड का पहला भाग है:

```shell
if a:type ==# ''
  set opfunc=ToTitle
  return 'g@'
endif
```

`opfunc` क्या है? यह `g@` क्यों लौटा रहा है?

Vim में एक विशेष ऑपरेटर है, ऑपरेटर फ़ंक्शन, `g@`। यह ऑपरेटर आपको `opfunc` विकल्प में असाइन किए गए *किसी भी* फ़ंक्शन का उपयोग करने की अनुमति देता है। यदि मैंने `Foo()` फ़ंक्शन को `opfunc` में असाइन किया है, तो जब मैं `g@w` चलाता हूँ, मैं अगले शब्द पर `Foo()` चला रहा हूँ। यदि मैं `g@i(` चलाता हूँ, तो मैं आंतरिक कोष्ठकों पर `Foo()` चला रहा हूँ। यह ऑपरेटर फ़ंक्शन अपने स्वयं के Vim ऑपरेटर बनाने के लिए महत्वपूर्ण है।

अगली पंक्ति `opfunc` को `ToTitle` फ़ंक्शन में असाइन करती है।

```shell
set opfunc=ToTitle
```

अगली पंक्ति वास्तव में `g@` लौटा रही है:

```shell
return g@
```

तो ये दोनों पंक्तियाँ ठीक से कैसे काम करती हैं और यह `g@` क्यों लौटा रही है?

मान लीजिए कि आपके पास निम्नलिखित मैप है:

```shell
nnoremap <expr> gt ToTitle()`
```

फिर आप `gtw` दबाते हैं (अगले शब्द को टाइटलकेस करें)। जब आप पहली बार `gtw` चलाते हैं, तो Vim `ToTitle()` विधि को कॉल करता है। लेकिन अभी `opfunc` अभी भी खाली है। आप `ToTitle()` को कोई तर्क भी नहीं दे रहे हैं, इसलिए इसका `a:type` मान `''` होगा। यह शर्तीय अभिव्यक्ति को तर्क `a:type`, `if a:type ==# ''`, को सत्य मानने के लिए मजबूर करता है। अंदर, आप `opfunc` को `ToTitle` फ़ंक्शन में `set opfunc=ToTitle` के साथ असाइन करते हैं। अब `opfunc` `ToTitle` को असाइन किया गया है। अंततः, जब आप `opfunc` को `ToTitle` फ़ंक्शन में असाइन करते हैं, तो आप `g@` लौटाते हैं। मैं नीचे बताऊँगा कि यह `g@` क्यों लौटाता है।

आप अभी तक खत्म नहीं हुए हैं। याद रखें, आपने अभी `gtw` दबाया है। `gt` दबाने से ऊपर के सभी कार्य किए गए हैं, लेकिन आपके पास अभी भी `w` को प्रोसेस करना है। `g@` लौटाकर, इस बिंदु पर, आपके पास तकनीकी रूप से `g@w` है (यही कारण है कि आपके पास `return g@` है)। चूंकि `g@` फ़ंक्शन ऑपरेटर है, आप इसे `w` गति के साथ पास कर रहे हैं। इसलिए Vim, `g@w` प्राप्त करने पर, `ToTitle` को *एक बार और* कॉल करता है (चिंता न करें, आप अंतहीन लूप में नहीं फँसेंगे जैसा कि आप थोड़ी देर में देखेंगे)।

संक्षेप में, `gtw` दबाने पर, Vim चेक करता है कि `opfunc` खाली है या नहीं। यदि यह खाली है, तो Vim इसे `ToTitle` के साथ असाइन करेगा। फिर यह `g@` लौटाता है, मूल रूप से `ToTitle` को एक बार और कॉल करता है ताकि आप अब इसे एक ऑपरेटर के रूप में उपयोग कर सकें। यह एक कस्टम ऑपरेटर बनाने का सबसे कठिन हिस्सा है और आपने इसे किया! अगला, आपको `ToTitle()` के लिए लॉजिक बनाना है ताकि इनपुट को वास्तव में टाइटलकेस किया जा सके।

## इनपुट प्रोसेसिंग

अब आपके पास `gt` एक ऑपरेटर के रूप में कार्य कर रहा है जो `ToTitle()` को निष्पादित करता है। लेकिन आप अगला क्या करते हैं? आप वास्तव में टेक्स्ट को टाइटलकेस कैसे करते हैं?

जब भी आप Vim में कोई ऑपरेटर चलाते हैं, तो तीन अलग-अलग क्रिया गति प्रकार होते हैं: वर्ण, पंक्ति, और ब्लॉक। `g@w` (शब्द) एक वर्ण ऑपरेशन का उदाहरण है। `g@j` (एक पंक्ति नीचे) एक पंक्ति ऑपरेशन का उदाहरण है। ब्लॉक ऑपरेशन दुर्लभ है, लेकिन आमतौर पर जब आप `Ctrl-V` (विजुअल ब्लॉक) ऑपरेशन करते हैं, तो इसे ब्लॉक ऑपरेशन के रूप में गिना जाएगा। जो ऑपरेशन कुछ वर्णों को आगे / पीछे लक्षित करते हैं, उन्हें आमतौर पर वर्ण ऑपरेशन माना जाता है (`b`, `e`, `w`, `ge`, आदि)। जो ऑपरेशन कुछ पंक्तियों को नीचे / ऊपर लक्षित करते हैं, उन्हें आमतौर पर पंक्ति ऑपरेशन माना जाता है (`j`, `k`)। जो ऑपरेशन कॉलम को आगे, पीछे, ऊपर, या नीचे लक्षित करते हैं, उन्हें आमतौर पर ब्लॉक ऑपरेशन माना जाता है (वे आमतौर पर या तो कॉलमर फोर्स्ड-मोशन या ब्लॉकवाइज विजुअल मोड होते हैं; अधिक जानकारी के लिए: `:h forced-motion`)।

इसका मतलब है, यदि आप `g@w` दबाते हैं, तो `g@` `ToTitle()` को तर्क के रूप में एक शाब्दिक स्ट्रिंग `"char"` पास करेगा। यदि आप `g@j` करते हैं, तो `g@` `ToTitle()` को तर्क के रूप में एक शाब्दिक स्ट्रिंग `"line"` पास करेगा। यह स्ट्रिंग `ToTitle` फ़ंक्शन में `type` तर्क के रूप में पास की जाएगी।

## अपना खुद का कस्टम फ़ंक्शन ऑपरेटर बनाना

आइए हम एक डमी फ़ंक्शन लिखकर `g@` के साथ खेलते हैं:

```shell
function! Test(some_arg)
  echom a:some_arg 
endfunction
```

अब उस फ़ंक्शन को `opfunc` में असाइन करें:

```shell
:set opfunc=Test
```

`g@` ऑपरेटर `Test(some_arg)` को निष्पादित करेगा और इसे `"char"`, `"line"`, या `"block"` में से किसी एक के साथ पास करेगा, यह इस पर निर्भर करता है कि आप कौन सा ऑपरेशन करते हैं। विभिन्न ऑपरेशनों को चलाएँ जैसे `g@iw` (आंतरिक शब्द), `g@j` (एक पंक्ति नीचे), `g@$` (पंक्ति के अंत तक), आदि। देखें कि कौन से विभिन्न मान इको किए जा रहे हैं। ब्लॉक ऑपरेशन का परीक्षण करने के लिए, आप ब्लॉक ऑपरेशनों के लिए Vim के फोर्स्ड मोशन का उपयोग कर सकते हैं: `g@Ctrl-Vj` (एक कॉलम नीचे ब्लॉक ऑपरेशन)।

आप इसे विजुअल मोड के साथ भी उपयोग कर सकते हैं। विभिन्न विजुअल हाइलाइट्स जैसे `v`, `V`, और `Ctrl-V` का उपयोग करें फिर `g@` दबाएँ (सावधान रहें, यह आउटपुट इको को बहुत तेजी से फ्लैश करेगा, इसलिए आपको तेज़ नज़र रखनी होगी - लेकिन इको निश्चित रूप से वहाँ है। इसके अलावा, चूंकि आप `echom` का उपयोग कर रहे हैं, आप `:messages` के साथ रिकॉर्ड किए गए इको संदेशों की जांच कर सकते हैं)।

काफी अच्छा है, है ना? आप Vim के साथ क्या-क्या प्रोग्राम कर सकते हैं! इसे स्कूल में क्यों नहीं सिखाया गया? आइए अपने प्लगइन के साथ आगे बढ़ते हैं।

## ToTitle एक फ़ंक्शन के रूप में

अगले कुछ पंक्तियों पर चलते हैं:

```shell
if a:type != 'block' && a:type != 'line' && a:type != 'char'
  let l:words = a:type
  let l:wordsArr = trim(l:words)->split('\s\+')
  call map(l:wordsArr, 's:capitalize(v:val)')
  return l:wordsArr->join(' ')
endif
```

यह पंक्ति वास्तव में `ToTitle()` के ऑपरेटर व्यवहार से संबंधित नहीं है, बल्कि इसे एक कॉल करने योग्य TitleCase फ़ंक्शन में सक्षम बनाने के लिए है (हाँ, मुझे पता है कि मैं सिंगल रिस्पॉन्सिबिलिटी प्रिंसिपल का उल्लंघन कर रहा हूँ)। प्रेरणा यह है कि, Vim में मूल `toupper()` और `tolower()` फ़ंक्शन हैं जो किसी भी दिए गए स्ट्रिंग को अपरकेस और लोअरकेस करेंगे। उदाहरण: `:echo toupper('hello')` `'HELLO'` लौटाता है और `:echo tolower('HELLO')` `'hello'` लौटाता है। मैं चाहता हूँ कि इस प्लगइन में `ToTitle` को चलाने की क्षमता हो ताकि आप `:echo ToTitle('once upon a time')` कर सकें और `'Once Upon a Time'` लौटाने का मान प्राप्त कर सकें।

अब, आप जानते हैं कि जब आप `g@` के साथ `ToTitle(type)` को कॉल कर रहे हैं, तो `type` तर्क का मान `'block'`, `'line'`, या `'char'` में से एक होगा। यदि तर्क न तो `'block'` है, न `'line'` है, और न ही `'char'`, तो आप सुरक्षित रूप से मान सकते हैं कि `ToTitle()` `g@` के बाहर कॉल किया जा रहा है। इस मामले में, आप उन्हें सफेद स्थानों (`\s\+`) द्वारा विभाजित करते हैं:

```shell
let l:wordsArr = trim(l:words)->split('\s\+')
```

फिर प्रत्येक तत्व को कैपिटलाइज़ करते हैं:

```shell
call map(l:wordsArr, 's:capitalize(v:val)')
```

फिर उन्हें एक साथ जोड़ने से पहले:

```shell
l:wordsArr->join(' ')
```

`capitalize()` फ़ंक्शन बाद में कवर किया जाएगा।

## अस्थायी चर

अगली कुछ पंक्तियाँ:

```shell
let l:sel_save = &selection
let l:reg_save = getreginfo('"')
let l:cb_save = &clipboard
let l:visual_marks_save = [getpos("'<"), getpos("'>")]
```

ये पंक्तियाँ विभिन्न वर्तमान स्थितियों को अस्थायी चर में संरक्षित करती हैं। बाद में आप विजुअल मोड, मार्क्स, और रजिस्टर का उपयोग करेंगे। ऐसा करने से कुछ स्थितियों में बदलाव होगा। चूंकि आप इतिहास को संशोधित नहीं करना चाहते, आपको उन्हें अस्थायी चर में सहेजना होगा ताकि आप बाद में स्थितियों को पुनर्स्थापित कर सकें।
## चयन को बड़े अक्षरों में बदलना

अगली पंक्तियाँ महत्वपूर्ण हैं:

```shell
try
  set clipboard= selection=inclusive
  let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
  let l:selected_phrase = getreg('"')
  let l:WORD_PATTERN = '\<\k*\>'
  let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

  let l:startLine = line("'<")
  let l:startCol = virtcol(".")
```
आइए इन्हें छोटे टुकड़ों में देखते हैं। यह पंक्ति:

```shell
set clipboard= selection=inclusive
```

आप पहले `selection` विकल्प को समावेशी और `clipboard` को खाली सेट करते हैं। चयन विशेषता आमतौर पर दृश्य मोड के साथ उपयोग की जाती है और इसके तीन संभावित मान हैं: `old`, `inclusive`, और `exclusive`। इसे समावेशी सेट करना मतलब है कि चयन का अंतिम अक्षर शामिल है। मैं इन्हें यहाँ कवर नहीं करूंगा, लेकिन बिंदु यह है कि इसे समावेशी चुनने से यह दृश्य मोड में लगातार व्यवहार करता है। डिफ़ॉल्ट रूप से Vim इसे समावेशी सेट करता है, लेकिन आप इसे यहाँ फिर भी सेट करते हैं ताकि यदि आपके किसी प्लगइन ने इसे किसी अन्य मान पर सेट किया हो। यदि आप जानने के लिए उत्सुक हैं कि वे वास्तव में क्या करते हैं, तो `:h 'clipboard'` और `:h 'selection'` देखें।

अगला, आपके पास यह अजीब दिखने वाला हैश है जिसके बाद एक निष्पादन आदेश है:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
```

पहले, `#{}` सिंटैक्स Vim का शब्दकोश डेटा प्रकार है। स्थानीय चर `l:commands` एक हैश है जिसमें 'lines', 'char', और 'block' इसके कुंजी हैं। आदेश `silent exe '...'` उस स्ट्रिंग के अंदर जो भी आदेश है उसे चुपचाप निष्पादित करता है (अन्यथा यह आपकी स्क्रीन के नीचे सूचनाएँ प्रदर्शित करेगा)।

दूसरे, निष्पादित आदेश हैं `'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')`। पहला, `noautocmd`, अगले आदेश को बिना किसी ऑटो कमांड को सक्रिय किए निष्पादित करेगा। दूसरा, `keepjumps`, चलते समय कर्सर के आंदोलन को रिकॉर्ड नहीं करने के लिए है। Vim में, कुछ गति स्वचालित रूप से परिवर्तन सूची, कूद सूची, और मार्क सूची में रिकॉर्ड की जाती हैं। यह उसे रोकता है। `noautocmd` और `keepjumps` का उद्देश्य साइड इफेक्ट्स को रोकना है। अंततः, `normal` आदेश स्ट्रिंग्स को सामान्य आदेश के रूप में निष्पादित करता है। `..` Vim का स्ट्रिंग इंटरपोलेशन सिंटैक्स है। `get()` एक गेटर विधि है जो या तो एक सूची, ब्लॉब, या शब्दकोश स्वीकार करती है। इस मामले में, आप इसे शब्दकोश `l:commands` पास कर रहे हैं। कुंजी `a:type` है। आपने पहले सीखा कि `a:type` तीन स्ट्रिंग मानों में से एक है: 'char', 'line', या 'block'। तो यदि `a:type` 'line' है, तो आप `"noautocmd keepjumps normal! '[V']y"` निष्पादित करेंगे (अधिक के लिए, `:h silent`, `:h :exe`, `:h :noautocmd`, `:h :keepjumps`, `:h :normal`, और `:h get()` देखें)।

आइए देखते हैं कि `'[V']y` क्या करता है। पहले मान लें कि आपके पास यह पाठ है:

```shell
दूसरा नाश्ता
पहले नाश्ते से बेहतर है
```
मान लें कि आपका कर्सर पहले पंक्ति पर है। फिर आप `g@j` दबाते हैं (ऑपरेटर फ़ंक्शन, `g@`, एक पंक्ति नीचे, `j` के साथ चलाते हैं)। `'[` कर्सर को पहले से बदले या यांकी किए गए पाठ की शुरुआत पर ले जाता है। हालांकि आपने तकनीकी रूप से `g@j` के साथ कोई पाठ नहीं बदला या यांकी नहीं किया, Vim `g@` आदेश के प्रारंभ और अंत गति के स्थानों को `'[` और `']` के साथ याद रखता है (अधिक के लिए, `:h g@` देखें)। आपके मामले में, `'[` दबाने से आपका कर्सर पहले पंक्ति पर जाता है क्योंकि यही वह स्थान है जहाँ आपने `g@` चलाया था। `V` एक पंक्ति-वार दृश्य मोड आदेश है। अंततः, `']` आपके कर्सर को पिछले बदले या यांकी किए गए पाठ के अंत पर ले जाता है, लेकिन इस मामले में, यह आपके अंतिम `g@` ऑपरेशन के अंत पर आपके कर्सर को ले जाता है। अंततः, `y` चयनित पाठ को यांकी करता है।

आपने जो किया वह वही पाठ यांकी करना था जिस पर आपने `g@` किया था।

यदि आप यहाँ अन्य दो आदेशों पर नज़र डालते हैं:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
```

वे सभी समान क्रियाएँ करते हैं, सिवाय इसके कि पंक्ति-वार क्रियाओं के बजाय, आप वर्ण-वार या ब्लॉक-वार क्रियाएँ करेंगे। मैं दोहराने जैसा लग सकता हूँ, लेकिन तीनों मामलों में आप प्रभावी रूप से वही पाठ यांकी कर रहे हैं जिस पर आपने `g@` किया था।

आइए अगली पंक्ति पर नज़र डालते हैं:

```shell
let l:selected_phrase = getreg('"')
```

यह पंक्ति अनाम रजिस्टर (`"`) की सामग्री प्राप्त करती है और इसे चर `l:selected_phrase` के अंदर संग्रहीत करती है। एक मिनट रुकिए... क्या आपने अभी एक पाठ का यांकी नहीं किया? अनाम रजिस्टर वर्तमान में उस पाठ को रखता है जिसे आपने अभी यांकी किया था। इसी तरह यह प्लगइन पाठ की एक प्रति प्राप्त करने में सक्षम है।

अगली पंक्ति एक नियमित अभिव्यक्ति पैटर्न है:

```shell
let l:WORD_PATTERN = '\<\k*\>'
```

`\<` और `\>` शब्द सीमा पैटर्न हैं। `\<` के बाद का अक्षर एक शब्द की शुरुआत को मेल करता है और `\>` के पहले का अक्षर एक शब्द के अंत को मेल करता है। `\k` कीवर्ड पैटर्न है। आप देख सकते हैं कि Vim किसे कीवर्ड के रूप में स्वीकार करता है `:set iskeyword?` के साथ। याद रखें कि Vim में `w` गति आपके कर्सर को शब्द के अनुसार ले जाती है। Vim के पास "कीवर्ड" का एक पूर्व-निर्धारित विचार है (आप उन्हें `iskeyword` विकल्प को बदलकर संपादित भी कर सकते हैं)। `:h /\<`, `:h /\>`, और `:h /\k`, और `:h 'iskeyword'` के लिए देखें। अंततः, `*` का अर्थ है शून्य या अधिक बाद के पैटर्न।

बड़ी तस्वीर में, `'\<\k*\>'` एक शब्द को मेल करता है। यदि आपके पास एक स्ट्रिंग है:

```shell
एक दो तीन
```

इस पैटर्न के खिलाफ मेल करने पर आपको तीन मेल मिलेंगे: "एक", "दो", और "तीन"।

अंततः, आपके पास एक और पैटर्न है:

```shell
let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'
```

याद रखें कि Vim का प्रतिस्थापन आदेश एक अभिव्यक्ति के साथ `\={your-expression}` के साथ उपयोग किया जा सकता है। उदाहरण के लिए, यदि आप वर्तमान पंक्ति में "donut" स्ट्रिंग को बड़े अक्षरों में करना चाहते हैं, तो आप Vim के `toupper()` फ़ंक्शन का उपयोग कर सकते हैं। आप इसे `:%s/donut/\=toupper(submatch(0))/g` चलाकर प्राप्त कर सकते हैं। `submatch(0)` प्रतिस्थापन आदेश में उपयोग की जाने वाली एक विशेष अभिव्यक्ति है। यह संपूर्ण मेल किए गए पाठ को लौटाता है।

अगली दो पंक्तियाँ:

```shell
let l:startLine = line("'<")
let l:startCol = virtcol(".")
```

`line()` अभिव्यक्ति एक पंक्ति संख्या लौटाती है। यहाँ आप इसे मार्क `'<` के साथ पास करते हैं, जो अंतिम चयनित दृश्य क्षेत्र की पहली पंक्ति का प्रतिनिधित्व करता है। याद रखें कि आपने पाठ को यांकी करने के लिए दृश्य मोड का उपयोग किया था। `'<` उस दृश्य क्षेत्र चयन की शुरुआत की पंक्ति संख्या लौटाता है। `virtcol()` अभिव्यक्ति वर्तमान कर्सर की कॉलम संख्या लौटाती है। आप थोड़ी देर में अपने कर्सर को चारों ओर ले जाने वाले हैं, इसलिए आपको अपने कर्सर के स्थान को संग्रहीत करने की आवश्यकता है ताकि आप बाद में यहाँ लौट सकें।

यहाँ एक ब्रेक लें और अब तक की सभी चीज़ों की समीक्षा करें। सुनिश्चित करें कि आप अभी भी साथ चल रहे हैं। जब आप तैयार हों, तो चलिए आगे बढ़ते हैं।
## एक ब्लॉक ऑपरेशन को संभालना

आइए इस अनुभाग के माध्यम से चलते हैं:

```shell
if a:type ==# "block"
  sil! keepj norm! gv"ad
  keepj $
  keepj pu_

  let l:lastLine = line("$")

  sil! keepj norm "ap

  let l:curLine = line(".")

  sil! keepj norm! VGg@
  exe "keepj norm! 0\<c-v>G$h\"ad" 
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
  exe "keepj " . l:lastLine
  sil! keepj norm! "_dG
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

अब आपके टेक्स्ट को वास्तव में बड़े अक्षरों में बदलने का समय है। याद रखें कि आपके पास `a:type` या तो 'char', 'line', या 'block' होना चाहिए। अधिकांश मामलों में, आपको शायद 'char' और 'line' मिलेंगे। लेकिन कभी-कभी आपको एक ब्लॉक मिल सकता है। यह दुर्लभ है, लेकिन इसे संबोधित करना आवश्यक है। दुर्भाग्यवश, एक ब्लॉक को संभालना 'char' और 'line' को संभालने के रूप में सीधा नहीं है। इसमें थोड़ा अतिरिक्त प्रयास लगेगा, लेकिन यह संभव है।

आपके पास यह टेक्स्ट है:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner
```

मान लीजिए कि आपका कर्सर पहले लाइन पर "pancake" के "c" पर है। आप फिर दृश्य ब्लॉक (`Ctrl-V`) का उपयोग करके नीचे और आगे "cake" को सभी तीन लाइनों में चुनते हैं:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner
```

जब आप `gt` दबाते हैं, तो आप चाहते हैं कि आपको मिले:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner
```

यहाँ आपकी मूल धारणाएँ हैं: जब आप "pancakes" में तीन "cakes" को हाइलाइट करते हैं, तो आप Vim को बता रहे हैं कि आपके पास तीन शब्दों की पंक्तियाँ हैं जिन्हें आप हाइलाइट करना चाहते हैं। ये शब्द हैं "cake", "cake", और "cake"। आप "Cake", "Cake", और "Cake" प्राप्त करने की उम्मीद करते हैं।

आइए कार्यान्वयन विवरण पर चलते हैं। अगली कुछ पंक्तियों में:

```shell
sil! keepj norm! gv"ad
keepj $
keepj pu_
let l:lastLine = line("$")
sil! keepj norm "ap
let l:curLine = line(".")
```

पहली पंक्ति:

```shell
sil! keepj norm! gv"ad
```

याद रखें कि `sil!` चुपचाप चलता है और `keepj` कूदने के इतिहास को बनाए रखता है जब आप चलते हैं। आप फिर सामान्य कमांड `gv"ad` को निष्पादित करते हैं। `gv` अंतिम दृश्य रूप से हाइलाइट किए गए टेक्स्ट को चुनता है (पैनकेक उदाहरण में, यह सभी तीन 'cakes' को फिर से हाइलाइट करेगा)। `"ad` दृश्य रूप से हाइलाइट किए गए टेक्स्ट को हटाता है और उन्हें रजिस्टर a में संग्रहीत करता है। परिणामस्वरूप, आपके पास अब है:

```shell
pan for breakfast
pan for lunch
pan for dinner
```

अब आपके पास रजिस्टर a में 'cakes' के 3 *ब्लॉक* (लाइन नहीं) हैं। यह भेद महत्वपूर्ण है। लाइनवाइज दृश्य मोड के साथ टेक्स्ट को यांकी करना ब्लॉकवाइज दृश्य मोड के साथ टेक्स्ट को यांकी करने से अलग है। इसे ध्यान में रखें क्योंकि आप इसे बाद में फिर से देखेंगे।

अगला आपके पास है:

```shell
keepj $
keepj pu_
```

`$` आपको आपकी फ़ाइल की अंतिम पंक्ति पर ले जाता है। `pu_` आपके कर्सर के नीचे एक पंक्ति जोड़ता है। आप उन्हें `keepj` के साथ चलाना चाहते हैं ताकि आप कूदने के इतिहास को न बदलें।

फिर आप अपनी अंतिम पंक्ति के नंबर को स्थानीय चर `lastLine` में संग्रहीत करते हैं।

```shell
let l:lastLine = line("$")
```

फिर आप रजिस्टर से सामग्री को `norm "ap` के साथ पेस्ट करते हैं।

```shell
sil! keepj norm "ap
```

याद रखें कि यह आपकी फ़ाइल की अंतिम पंक्ति के नीचे बनाई गई नई पंक्ति पर हो रहा है - आप वर्तमान में फ़ाइल के नीचे हैं। पेस्ट करने से आपको ये *ब्लॉक* टेक्स्ट मिलते हैं:

```shell
cake
cake
cake
```

अगला, आप उस वर्तमान पंक्ति का स्थान संग्रहीत करते हैं जहाँ आपका कर्सर है।

```shell
let l:curLine = line(".")
```

अब आइए अगली कुछ पंक्तियों पर चलते हैं:

```shell
sil! keepj norm! VGg@
exe "keepj norm! 0\<c-v>G$h\"ad"
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

यह पंक्ति:

```shell
sil! keepj norm! VGg@
```

`VG` दृश्य रूप से उन्हें लाइन दृश्य मोड के साथ वर्तमान लाइन से फ़ाइल के अंत तक हाइलाइट करता है। तो यहाँ आप 'cake' टेक्स्ट के तीन ब्लॉकों को लाइनवाइज हाइलाइट कर रहे हैं (ब्लॉक बनाम लाइन के भेद को याद रखें)। ध्यान दें कि जब आपने पहले तीन "cake" टेक्स्ट को पेस्ट किया, तो आप उन्हें ब्लॉकों के रूप में पेस्ट कर रहे थे। अब आप उन्हें लाइनों के रूप में हाइलाइट कर रहे हैं। वे बाहर से समान लग सकते हैं, लेकिन आंतरिक रूप से, Vim टेक्स्ट के ब्लॉकों को पेस्ट करने और लाइनों के टेक्स्ट को पेस्ट करने के बीच का अंतर जानता है।

```shell
cake
cake
cake
```

`g@` फ़ंक्शन ऑपरेटर है, इसलिए आप मूल रूप से इसे स्वयं को पुनरावृत्त कॉल कर रहे हैं। लेकिन क्यों? इसका क्या उद्देश्य है?

आप `g@` को पुनरावृत्त कॉल कर रहे हैं और इसे 'cake' टेक्स्ट की सभी 3 लाइनों के साथ पास कर रहे हैं (जब आपने इसे `V` के साथ चलाया, तो आपके पास अब लाइनें हैं, न कि ब्लॉक) ताकि इसे कोड के अन्य भाग द्वारा संभाला जा सके (आप इसे बाद में देखेंगे)। `g@` को चलाने का परिणाम तीन लाइनों के सही शीर्षक वाले टेक्स्ट हैं:

```shell
Cake
Cake
Cake
```

अगली पंक्ति:

```shell
exe "keepj norm! 0\<c-v>G$h\"ad"
```

यह सामान्य मोड कमांड को लाइन की शुरुआत पर जाने के लिए चलाता है (`0`), अंतिम पंक्ति और उस पंक्ति पर अंतिम वर्ण पर जाने के लिए ब्लॉक दृश्य हाइलाइट का उपयोग करता है (`<c-v>G$`)। `h` कर्सर को समायोजित करने के लिए है (जब `$` करते हैं तो Vim एक अतिरिक्त पंक्ति को दाईं ओर ले जाता है)। अंततः, आप हाइलाइट किए गए टेक्स्ट को हटा देते हैं और इसे रजिस्टर a में संग्रहीत करते हैं (`"ad`).

अगली पंक्ति:

```shell
exe "keepj " . l:startLine
```

आप अपने कर्सर को `startLine` पर वापस ले जाते हैं।

अगला:

```shell
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
```

`startLine` स्थान पर होने के नाते, आप अब `startCol` द्वारा चिह्नित कॉलम पर कूदते हैं। `\<bar>\` बार `|` गति है। Vim में बार गति आपके कर्सर को nth कॉलम पर ले जाती है (मान लीजिए कि `startCol` 4 था। `4|` चलाने से आपका कर्सर 4 के कॉलम स्थिति पर कूद जाएगा)। याद रखें कि आपने `startCol` को उस स्थान पर संग्रहीत किया था जहाँ आप शीर्षक के लिए टेक्स्ट की कॉलम स्थिति को संग्रहीत करना चाहते थे। अंततः, `"aP` रजिस्टर a में संग्रहीत टेक्स्ट को पेस्ट करता है। यह टेक्स्ट को वापस उसी स्थान पर रखता है जहाँ इसे पहले हटाया गया था।

आइए अगली 4 पंक्तियों पर नज़र डालें:

```shell
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

`exe "keepj " . l:lastLine` आपके कर्सर को पहले के `lastLine` स्थान पर वापस ले जाता है। `sil! keepj norm! "_dG` अतिरिक्त स्थानों को हटा देता है जो ब्लैकहोल रजिस्टर (`"_dG`) का उपयोग करके बनाए गए थे ताकि आपका अनाम रजिस्टर साफ रहे। `exe "keepj " . l:startLine` आपके कर्सर को `startLine` पर वापस ले जाता है। अंततः, `exe "sil! keepj norm! " . l:startCol . "\<bar>"` आपके कर्सर को `startCol` कॉलम पर ले जाता है।

ये सभी क्रियाएँ हैं जो आप Vim में मैन्युअल रूप से कर सकते थे। हालाँकि, इन क्रियाओं को पुन: प्रयोज्य फ़ंक्शंस में बदलने का लाभ यह है कि वे आपको हर बार शीर्षक के लिए 30+ पंक्तियों के निर्देश चलाने से बचाएंगे। यहाँ जो बात ध्यान देने योग्य है, वह यह है कि, जो कुछ भी आप Vim में मैन्युअल रूप से कर सकते हैं, आप उसे एक पुन: प्रयोज्य फ़ंक्शन में बदल सकते हैं, इसलिए एक प्लगइन!

यह इस तरह दिखेगा।

कुछ टेक्स्ट दिया गया:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner

... कुछ टेक्स्ट
```

पहले, आप इसे ब्लॉकवाइज दृश्य रूप से हाइलाइट करते हैं:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner

... कुछ टेक्स्ट
```

फिर आप इसे हटा देते हैं और उस टेक्स्ट को रजिस्टर a में संग्रहीत करते हैं:

```shell
pan for breakfast
pan for lunch
pan for dinner

... कुछ टेक्स्ट
```

फिर आप इसे फ़ाइल के नीचे पेस्ट करते हैं:

```shell
pan for breakfast
pan for lunch
pan for dinner

... कुछ टेक्स्ट
cake
cake
cake
```

फिर आप इसे बड़े अक्षरों में बदलते हैं:

```shell
pan for breakfast
pan for lunch
pan for dinner

... कुछ टेक्स्ट
Cake
Cake
Cake
```

अंत में, आप बड़े अक्षरों वाले टेक्स्ट को वापस रखते हैं:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner

... कुछ टेक्स्ट
```

## लाइन और कैरैक्टर ऑपरेशन्स को संभालना

आप अभी तक समाप्त नहीं हुए हैं। आपने केवल उस किनारे के मामले को संबोधित किया है जब आप ब्लॉक टेक्स्ट पर `gt` चलाते हैं। आपको अभी भी 'लाइन' और 'कैरैक्टर' ऑपरेशन्स को संभालने की आवश्यकता है। आइए देखें कि यह `else` कोड कैसे किया जाता है।

यहाँ कोड हैं:

```shell
if a:type ==# "block"
  # ... 
else
  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
  let l:titlecased = s:capitalizeFirstWord(l:titlecased)
  call setreg('"', l:titlecased)
  let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
  silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
endif
```

आइए उन्हें पंक्ति दर पंक्ति देखें। इस प्लगइन का रहस्य इस पंक्ति में है:

```shell
let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
```

`@@` अनाम रजिस्टर से शीर्षक बनाने के लिए टेक्स्ट को रखता है। `l:WORD_PATTERN` व्यक्तिगत कीवर्ड मैच है। `l:UPCASE_REPLACEMENT` `capitalize()` कमांड को कॉल करता है (जिसे आप बाद में देखेंगे)। `'g'` वैश्विक ध्वज है जो प्रतिस्थापन कमांड को सभी दिए गए शब्दों को प्रतिस्थापित करने के लिए निर्देशित करता है, न कि केवल पहले शब्द को।

अगली पंक्ति:

```shell
let l:titlecased = s:capitalizeFirstWord(l:titlecased)
```

यह सुनिश्चित करता है कि पहला शब्द हमेशा बड़े अक्षरों में होगा। यदि आपके पास "an apple a day keeps the doctor away" जैसे वाक्यांश हैं, तो चूंकि पहला शब्द, "an", एक विशेष शब्द है, आपका प्रतिस्थापन कमांड इसे बड़े अक्षरों में नहीं करेगा। आपको एक ऐसा तरीका चाहिए जो हमेशा पहले वर्ण को बड़े अक्षरों में बनाए रखे। यह फ़ंक्शन ठीक यही करता है (आप इस फ़ंक्शन का विवरण बाद में देखेंगे)। इन शीर्षककरण विधियों का परिणाम स्थानीय चर `l:titlecased` में संग्रहीत होता है।

अगली पंक्ति:

```shell
call setreg('"', l:titlecased)
```

यह बड़े अक्षरों वाले स्ट्रिंग को अनाम रजिस्टर (`"`) में रखता है।

अगला, निम्नलिखित दो पंक्तियाँ:

```shell
let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
```

अरे, यह परिचित लगता है! आपने पहले `l:commands` के साथ एक समान पैटर्न देखा है। यहाँ यांकी के बजाय, आप पेस्ट (`p`) का उपयोग करते हैं। ताज़ा करने के लिए पिछले अनुभाग को देखें जहाँ मैंने `l:commands` के बारे में चर्चा की थी।

अंत में, ये दो पंक्तियाँ:

```shell
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

आप अपने कर्सर को उस लाइन और कॉलम पर वापस ले जा रहे हैं जहाँ आपने शुरुआत की थी। बस इतना ही!

आइए संक्षेप में देखें। उपरोक्त प्रतिस्थापन विधि इतनी स्मार्ट है कि यह दिए गए टेक्स्ट को बड़े अक्षरों में बदलने और विशेष शब्दों को छोड़ने में सक्षम है (इस पर बाद में अधिक)। जब आपके पास एक शीर्षक वाला स्ट्रिंग होता है, तो आप उन्हें अनाम रजिस्टर में संग्रहीत करते हैं। फिर आप उसी टेक्स्ट को दृश्य रूप से हाइलाइट करते हैं जिस पर आपने पहले `g@` चलाया था, फिर अनाम रजिस्टर से पेस्ट करते हैं (यह प्रभावी रूप से गैर-शीर्षक वाले टेक्स्ट को शीर्षक वाले संस्करण के साथ बदलता है)। अंततः, आप अपने कर्सर को वापस उस स्थान पर ले जाते हैं जहाँ आपने शुरुआत की थी।
## साफ-सफाई

आप तकनीकी रूप से तैयार हैं। टेक्स्ट अब शीर्षक केस में हैं। जो कुछ भी बचा है, वह है रजिस्टर और सेटिंग्स को पुनर्स्थापित करना।

```shell
call setreg('"', l:reg_save)
call setpos("'<", l:visual_marks_save[0])
call setpos("'>", l:visual_marks_save[1])
let &clipboard = l:cb_save
let &selection = l:sel_save
```

ये पुनर्स्थापित करते हैं:
- अनाम रजिस्टर।
- `<` और `>` मार्क।
- `'clipboard'` और `'selection'` विकल्प।

उफ्फ, आप तैयार हैं। यह एक लंबा फ़ंक्शन था। मैं फ़ंक्शन को छोटे हिस्सों में तोड़कर छोटा कर सकता था, लेकिन फिलहाल, यही पर्याप्त होगा। अब चलिए संक्षेप में कैपिटलाइज़ फ़ंक्शंस पर चलते हैं।

## कैपिटलाइज़ फ़ंक्शन

इस अनुभाग में, चलिए `s:capitalize()` फ़ंक्शन पर चलते हैं। यह फ़ंक्शन इस तरह दिखता है:

```shell
function! s:capitalize(string)
    if(toupper(a:string) ==# a:string && a:string != 'A')
        return a:string
    endif

    let l:str = tolower(a:string)
    let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
      return l:str
    endif

    return toupper(l:str[0]) . l:str[1:]
endfunction
```

याद रखें कि `capitalize()` फ़ंक्शन के लिए तर्क, `a:string`, वह व्यक्तिगत शब्द है जो `g@` ऑपरेटर द्वारा पास किया गया है। इसलिए यदि मैं "पैनकेक फॉर नाश्ता" टेक्स्ट पर `gt` चला रहा हूं, तो `ToTitle` `capitalize(string)` को *तीन* बार कॉल करेगा, एक बार "पैनकेक" के लिए, एक बार "फॉर" के लिए, और एक बार "नाश्ता" के लिए।

फ़ंक्शन का पहला भाग है:

```shell
if(toupper(a:string) ==# a:string && a:string != 'A')
  return a:string
endif
```

पहली शर्त (`toupper(a:string) ==# a:string`) यह जांचती है कि क्या तर्क का अपरकेस संस्करण वही है जो स्ट्रिंग है और क्या स्ट्रिंग स्वयं "A" है। यदि ये सत्य हैं, तो उस स्ट्रिंग को लौटाएं। यह इस धारणा पर आधारित है कि यदि कोई शब्द पहले से पूरी तरह से अपरकेस है, तो यह एक संक्षिप्त रूप है। उदाहरण के लिए, "CEO" शब्द को अन्यथा "Ceo" में परिवर्तित किया जाएगा। हुम्म, आपका CEO खुश नहीं होगा। इसलिए किसी भी पूरी तरह से अपरकेस शब्द को अकेला छोड़ना सबसे अच्छा है। दूसरी शर्त, `a:string != 'A'`, एक कैपिटलाइज्ड "A" वर्ण के लिए एक किनारे के मामले को संबोधित करती है। यदि `a:string` पहले से ही एक कैपिटलाइज्ड "A" है, तो यह गलती से `toupper(a:string) ==# a:string` परीक्षण पास कर जाएगा। क्योंकि "a" अंग्रेजी में एक अनिश्चित लेख है, इसे लोअरकेस में होना चाहिए।

अगला भाग स्ट्रिंग को लोअरकेस करने के लिए मजबूर करता है:

```shell
let l:str = tolower(a:string)
```

अगला भाग सभी शब्द अपवादों की सूची का एक regex है। मैंने उन्हें https://titlecaseconverter.com/rules/ से प्राप्त किया:

```shell
let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
```

अगला भाग:

```shell
if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
  return l:str
endif
```

पहले, यह जांचें कि आपकी स्ट्रिंग अपवादित शब्द सूची (`l:exclusions`) का हिस्सा है या नहीं। यदि ऐसा है, तो इसे कैपिटलाइज़ न करें। फिर जांचें कि आपकी स्ट्रिंग स्थानीय अपवाद सूची (`s:local_exclusion_list`) का हिस्सा है या नहीं। यह अपवाद सूची एक कस्टम सूची है जिसे उपयोगकर्ता vimrc में जोड़ सकता है (यदि उपयोगकर्ता के पास विशेष शब्दों के लिए अतिरिक्त आवश्यकताएँ हैं)।

अंतिम भाग शब्द के कैपिटलाइज्ड संस्करण को लौटाता है। पहला वर्ण अपरकेस होता है जबकि बाकी जैसा है वैसा ही रहता है।

```shell
return toupper(l:str[0]) . l:str[1:]
```

चलो दूसरे कैपिटलाइज़ फ़ंक्शन पर चलते हैं। फ़ंक्शन इस तरह दिखता है:

```shell
function! s:capitalizeFirstWord(string)
  if (a:string =~ "\n")
    let l:lineArr = trim(a:string)->split('\n')
    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
    return l:lineArr->join("\n")
  endif
  return toupper(a:string[0]) . a:string[1:]
endfunction
```

यह फ़ंक्शन एक किनारे के मामले को संभालने के लिए बनाया गया था यदि आपके पास एक वाक्य है जो एक अपवादित शब्द से शुरू होता है, जैसे "एक सेब एक दिन डॉक्टर को दूर रखता है"। अंग्रेजी भाषा के कैपिटलाइजेशन नियमों के आधार पर, वाक्य में सभी पहले शब्दों को, चाहे वह विशेष शब्द हो या न हो, कैपिटलाइज किया जाना चाहिए। केवल आपके `substitute()` कमांड के साथ, आपके वाक्य में "एक" लोअरकेस हो जाएगा। आपको पहले वर्ण को अपरकेस करने के लिए मजबूर करना होगा।

इस `capitalizeFirstWord` फ़ंक्शन में, `a:string` तर्क एक व्यक्तिगत शब्द नहीं है जैसे कि `capitalize` फ़ंक्शन के अंदर `a:string`, बल्कि यह पूरे टेक्स्ट है। इसलिए यदि आपके पास "पैनकेक फॉर नाश्ता" है, तो `a:string` का मान "पैनकेक फॉर नाश्ता" है। यह पूरे टेक्स्ट के लिए केवल एक बार `capitalizeFirstWord` चलाता है।

एक परिदृश्य जिसे आपको देखना है वह है यदि आपके पास एक मल्टी-लाइन स्ट्रिंग है जैसे "एक सेब एक दिन\nडॉक्टर को दूर रखता है"। आप सभी लाइनों के पहले वर्ण को अपरकेस करना चाहते हैं। यदि आपके पास नई लाइन्स नहीं हैं, तो बस पहले वर्ण को अपरकेस करें।

```shell
return toupper(a:string[0]) . a:string[1:]
```

यदि आपके पास नई लाइन्स हैं, तो आपको प्रत्येक लाइन में पहले वर्ण को कैपिटलाइज करना होगा, इसलिए आप उन्हें नई लाइनों द्वारा अलग किए गए एक एरे में विभाजित करते हैं:

```shell
let l:lineArr = trim(a:string)->split('\n')
```

फिर आप एरे के प्रत्येक तत्व को मैप करते हैं और प्रत्येक तत्व के पहले शब्द को कैपिटलाइज करते हैं:

```shell
let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
```

अंत में, आप एरे के तत्वों को एक साथ रखते हैं:

```shell
return l:lineArr->join("\n")
```

और आप तैयार हैं!

## दस्तावेज़

गिट रिपॉजिटरी में दूसरी निर्देशिका `docs/` निर्देशिका है। प्लगइन के लिए एक व्यापक दस्तावेज़ प्रदान करना अच्छा है। इस अनुभाग में, मैं संक्षेप में बताऊंगा कि आप अपने स्वयं के प्लगइन दस्तावेज़ कैसे बना सकते हैं।

`docs/` निर्देशिका Vim के विशेष रनटाइम पथों में से एक है। Vim `docs/` के अंदर सभी फ़ाइलों को पढ़ता है, इसलिए जब आप किसी विशेष कीवर्ड के लिए खोज करते हैं और वह कीवर्ड `docs/` निर्देशिका में से किसी एक फ़ाइल में पाया जाता है, तो यह इसे मदद पृष्ठ में प्रदर्शित करेगा। यहाँ आपके पास `totitle.txt` है। मैंने इसे इस तरह नामित किया क्योंकि यह प्लगइन का नाम है, लेकिन आप इसे कुछ भी नाम दे सकते हैं।

एक Vim दस्तावेज़ फ़ाइल मूल रूप से एक txt फ़ाइल है। एक सामान्य txt फ़ाइल और एक Vim हेल्प फ़ाइल के बीच का अंतर यह है कि बाद वाली विशेष "हेल्प" वाक्यविन्यास का उपयोग करती है। लेकिन पहले, आपको Vim को बताना होगा कि इसे टेक्स्ट फ़ाइल प्रकार के रूप में नहीं, बल्कि `help` फ़ाइल प्रकार के रूप में मानें। Vim को यह बताने के लिए कि इस `totitle.txt` को *हेल्प* फ़ाइल के रूप में व्याख्या करें, `:set ft=help` चलाएँ (`:h 'filetype'` के लिए अधिक)। वैसे, यदि आप Vim को यह बताना चाहते हैं कि इस `totitle.txt` को *सामान्य* txt फ़ाइल के रूप में व्याख्या करें, तो `:set ft=txt` चलाएँ।

### हेल्प फ़ाइल विशेष वाक्यविन्यास

किसी कीवर्ड को खोजने योग्य बनाने के लिए, उस कीवर्ड को तारों के साथ घेरें। उपयोगकर्ता द्वारा `:h totitle` के लिए खोज करते समय कीवर्ड `totitle` को खोजने योग्य बनाने के लिए, इसे हेल्प फ़ाइल में `*totitle*` के रूप में लिखें।

उदाहरण के लिए, मेरे पास मेरी सामग्री की तालिका के शीर्ष पर ये पंक्तियाँ हैं:

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

// अधिक TOC सामग्री
```

ध्यान दें कि मैंने तालिका की सामग्री अनुभाग को चिह्नित करने के लिए दो कीवर्ड का उपयोग किया: `*totitle*` और `*totitle-toc*`। इसका अर्थ है कि जब भी आप `:h totitle` या `:h totitle-toc` के लिए खोज करते हैं, Vim आपको इस स्थान पर ले जाएगा।

यहाँ एक और उदाहरण है, फ़ाइल के नीचे कहीं:

```shell
2. उपयोग                                                       *totitle-usage*

// उपयोग
```

यदि आप `:h totitle-usage` के लिए खोज करते हैं, तो Vim आपको इस अनुभाग में ले जाएगा।

आप हेल्प फ़ाइल में किसी अन्य अनुभाग का संदर्भ देने के लिए आंतरिक लिंक भी उपयोग कर सकते हैं, कीवर्ड को बार वाक्यविन्यास `|` के साथ घेरकर। TOC अनुभाग में, आप देखेंगे कि कीवर्ड बार के चारों ओर घिरे हुए हैं, जैसे `|totitle-intro|`, `|totitle-usage|`, आदि।

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

    1. परिचय ........................... |totitle-intro|
    2. उपयोग ........................... |totitle-usage|
    3. कैपिटलाइज़ करने के लिए शब्द ............. |totitle-words|
    4. ऑपरेटर ........................ |totitle-operator|
    5. कुंजी-बाइंडिंग ..................... |totitle-keybinding|
    6. बग ............................ |totitle-bug-report|
    7. योगदान .................... |totitle-contributing|
    8. श्रेय ......................... |totitle-credits|

```
यह आपको परिभाषा पर कूदने की अनुमति देता है। यदि आप `|totitle-intro|` पर कहीं अपने कर्सर को रखते हैं और `Ctrl-]` दबाते हैं, तो Vim उस शब्द की परिभाषा पर कूद जाएगा। इस मामले में, यह `*totitle-intro*` स्थान पर कूद जाएगा। इस तरह आप हेल्प डॉक में विभिन्न कीवर्ड से लिंक कर सकते हैं।

Vim में एक डॉक फ़ाइल लिखने का कोई सही या गलत तरीका नहीं है। यदि आप विभिन्न लेखकों द्वारा विभिन्न प्लगइन्स को देखते हैं, तो उनमें से कई विभिन्न प्रारूपों का उपयोग करते हैं। बिंदु यह है कि अपने उपयोगकर्ताओं के लिए एक आसान-से-समझने वाला हेल्प डॉक बनाना है।

अंत में, यदि आप पहले अपने स्वयं के प्लगइन को स्थानीय रूप से लिख रहे हैं और आप दस्तावेज़ पृष्ठ का परीक्षण करना चाहते हैं, तो बस `~/.vim/docs/` के अंदर एक txt फ़ाइल जोड़ने से आपके कीवर्ड स्वचालित रूप से खोजने योग्य नहीं बनेंगे। आपको Vim को अपने डॉक पृष्ठ को जोड़ने के लिए निर्देशित करना होगा। नए टैग फ़ाइलें बनाने के लिए `:helptags ~/.vim/doc` कमांड चलाएँ। अब आप अपने कीवर्ड के लिए खोज करना शुरू कर सकते हैं।

## निष्कर्ष

आप अंत तक पहुँच गए! यह अध्याय सभी Vimscript अध्यायों का समामेलन है। यहाँ आप अंततः जो आपने अब तक सीखा है उसे अभ्यास में डाल रहे हैं। उम्मीद है कि इसे पढ़ने के बाद, आपने न केवल यह समझा कि Vim प्लगइन्स कैसे बनाए जाते हैं, बल्कि आपको अपने स्वयं के प्लगइन लिखने के लिए भी प्रेरित किया।

जब भी आप एक ही क्रियाओं के अनुक्रम को कई बार दोहराते हैं, तो आपको अपना खुद का बनाने की कोशिश करनी चाहिए! कहा गया है कि आपको पहिया को फिर से नहीं बनाना चाहिए। हालांकि, मुझे लगता है कि सीखने के लिए पहिया को फिर से बनाना फायदेमंद हो सकता है। दूसरों के प्लगइन्स पढ़ें। उन्हें फिर से बनाएं। उनसे सीखें। अपना खुद का लिखें! कौन जानता है, शायद आप इस पढ़ाई के बाद अगला शानदार, सुपर-लोकप्रिय प्लगइन लिखेंगे। शायद आप अगले प्रसिद्ध टिम पोप होंगे। जब ऐसा होगा, तो मुझे बताएं!