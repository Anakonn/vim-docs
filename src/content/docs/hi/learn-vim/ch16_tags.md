---
description: इस दस्तावेज़ में, आप Vim टैग्स का उपयोग करके कोडबेस में किसी भी परिभाषा
  पर जल्दी जाने की विधि सीखेंगे।
title: Ch16. Tags
---

एक उपयोगी विशेषता टेक्स्ट संपादन में किसी भी परिभाषा पर जल्दी जाने की क्षमता है। इस अध्याय में, आप सीखेंगे कि कैसे Vim टैग का उपयोग करें।

## टैग अवलोकन

मान लीजिए कि किसी ने आपको एक नया कोडबेस दिया:

```shell
one = One.new
one.donut
```

`One`? `donut`? खैर, ये शायद उन डेवलपर्स के लिए स्पष्ट थे जिन्होंने तब कोड लिखा था, लेकिन अब वे डेवलपर्स यहाँ नहीं हैं और यह आपके ऊपर है कि आप इन अस्पष्ट कोड को समझें। इसे समझने में मदद करने का एक तरीका यह है कि आप स्रोत कोड का पालन करें जहाँ `One` और `donut` परिभाषित हैं।

आप इन्हें `fzf` या `grep` (या `vimgrep`) के साथ खोज सकते हैं, लेकिन इस मामले में, टैग तेज़ हैं।

टैग को एक पते की पुस्तक के रूप में सोचें:

```shell
Name    Address
Iggy1   1234 Cool St, 11111
Iggy2   9876 Awesome Ave, 2222
```

नाम-पता जोड़ी रखने के बजाय, टैग परिभाषाओं को पते के साथ जोड़े में संग्रहीत करते हैं।

मान लीजिए कि आपके पास एक ही निर्देशिका में ये दो रूबी फ़ाइलें हैं:

```shell
## one.rb
class One
  def initialize
    puts "Initialized"
  end

  def donut
    puts "Bar"
  end
end
```

और

```shell
## two.rb
require './one'

one = One.new
one.donut
```

परिभाषा पर कूदने के लिए, आप सामान्य मोड में `Ctrl-]` का उपयोग कर सकते हैं। `two.rb` के अंदर, उस पंक्ति पर जाएँ जहाँ `one.donut` है और कर्सर को `donut` पर ले जाएँ। `Ctrl-]` दबाएँ।

अरे, Vim टैग फ़ाइल नहीं ढूंढ सका। आपको पहले टैग फ़ाइल उत्पन्न करनी होगी।

## टैग जनरेटर

आधुनिक Vim टैग जनरेटर के साथ नहीं आता, इसलिए आपको एक बाहरी टैग जनरेटर डाउनलोड करना होगा। चुनने के लिए कई विकल्प हैं:

- ctags = केवल C। लगभग हर जगह उपलब्ध।
- exuberant ctags = सबसे लोकप्रिय में से एक। कई भाषाओं का समर्थन करता है।
- universal ctags = exuberant ctags के समान, लेकिन नया।
- etags = Emacs के लिए। ह्म्म...
- JTags = Java
- ptags.py = Python
- ptags = Perl
- gnatxref = Ada

यदि आप ऑनलाइन Vim ट्यूटोरियल देखते हैं, तो कई [exuberant ctags](http://ctags.sourceforge.net/) की सिफारिश करेंगे। यह [41 प्रोग्रामिंग भाषाओं](http://ctags.sourceforge.net/languages.html) का समर्थन करता है। मैंने इसका उपयोग किया और यह बहुत अच्छा काम करता है। हालाँकि, चूंकि इसे 2009 के बाद से बनाए नहीं रखा गया है, Universal ctags एक बेहतर विकल्प होगा। यह exuberant ctags के समान काम करता है और वर्तमान में बनाए रखा जा रहा है।

मैं universal ctags को स्थापित करने के विवरण में नहीं जाऊँगा। अधिक निर्देशों के लिए [universal ctags](https://github.com/universal-ctags/ctags) रिपॉजिटरी देखें।

मान लीजिए कि आपके पास universal ctags स्थापित है, चलिए एक बुनियादी टैग फ़ाइल उत्पन्न करते हैं। चलाएँ:

```shell
ctags -R .
```

`R` विकल्प ctags को आपके वर्तमान स्थान (`.`) से पुनरावृत्त स्कैन करने के लिए कहता है। आपको अपनी वर्तमान निर्देशिका में एक `tags` फ़ाइल दिखाई देनी चाहिए। इसके अंदर आपको कुछ ऐसा दिखाई देगा:

```shell
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	<https://ctags.io/>	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/b43eb39/
One	one.rb	/^class One$/;"	c
donut	one.rb	/^  def donut$/;"	f	class:One
initialize	one.rb	/^  def initialize$/;"	f	class:One
```

आपका थोड़ा अलग दिख सकता है आपके Vim सेटिंग और ctags जनरेटर के आधार पर। एक टैग फ़ाइल दो भागों से बनी होती है: टैग मेटाडेटा और टैग सूची। ये मेटाडेटा (`!TAG_FILE...`) आमतौर पर ctags जनरेटर द्वारा नियंत्रित होते हैं। मैं इसे यहाँ चर्चा नहीं करूँगा, लेकिन उनके दस्तावेज़ों की जांच करने के लिए स्वतंत्र महसूस करें! टैग सूची सभी परिभाषाओं की एक सूची है जिसे ctags द्वारा अनुक्रमित किया गया है।

अब `two.rb` पर जाएँ, कर्सर को `donut` पर रखें, और `Ctrl-]` टाइप करें। Vim आपको `one.rb` फ़ाइल पर ले जाएगा जहाँ `def donut` है। सफलता! लेकिन Vim ने यह कैसे किया?

## टैग्स एनाटॉमी

आइए `donut` टैग आइटम पर नज़र डालते हैं:

```shell
donut	one.rb	/^  def donut$/;"	f	class:One
```

उपरोक्त टैग आइटम चार घटकों से बना है: एक `tagname`, एक `tagfile`, एक `tagaddress`, और टैग विकल्प।
- `donut` `tagname` है। जब आपका कर्सर "donut" पर होता है, तो Vim टैग फ़ाइल में "donut" स्ट्रिंग वाला एक पंक्ति खोजता है।
- `one.rb` `tagfile` है। Vim `one.rb` फ़ाइल की खोज करता है।
- `/^ def donut$/` `tagaddress` है। `/.../` एक पैटर्न संकेतक है। `^` एक पंक्ति पर पहले तत्व के लिए एक पैटर्न है। इसके बाद दो स्पेस हैं, फिर स्ट्रिंग `def donut` है। अंत में, `$` एक पंक्ति पर अंतिम तत्व के लिए एक पैटर्न है।
- `f class:One` टैग विकल्प है जो Vim को बताता है कि `donut` फ़ंक्शन एक फ़ंक्शन (`f`) है और `One` क्लास का हिस्सा है।

आइए टैग सूची में एक और आइटम पर नज़र डालते हैं:

```shell
One	one.rb	/^class One$/;"	c
```

यह पंक्ति `donut` पैटर्न के समान तरीके से काम करती है:

- `One` `tagname` है। ध्यान दें कि टैग के साथ, पहला स्कैन केस-संवेदनशील होता है। यदि आपके पास सूची में `One` और `one` है, तो Vim `One` को `one` पर प्राथमिकता देगा।
- `one.rb` `tagfile` है। Vim `one.rb` फ़ाइल की खोज करता है।
- `/^class One$/` `tagaddress` पैटर्न है। Vim उस पंक्ति की खोज करता है जो (`^`) `class` से शुरू होती है और (`$`) `One` पर समाप्त होती है।
- `c` संभावित टैग विकल्पों में से एक है। चूंकि `One` एक रूबी क्लास है और कोई प्रक्रिया नहीं है, यह इसे `c` के साथ चिह्नित करता है।

आपके द्वारा उपयोग किए जाने वाले टैग जनरेटर के आधार पर, आपकी टैग फ़ाइल की सामग्री अलग दिख सकती है। न्यूनतम, एक टैग फ़ाइल में इनमें से किसी एक प्रारूप में होना चाहिए:

```shell
1.  {tagname} {TAB} {tagfile} {TAB} {tagaddress}
2.  {tagname} {TAB} {tagfile} {TAB} {tagaddress} {term} {field} ..
```

## टैग फ़ाइल

आपने सीखा है कि एक नई फ़ाइल, `tags`, `ctags -R .` चलाने के बाद बनाई जाती है। Vim को टैग फ़ाइल कहाँ खोजनी है, यह कैसे पता चलता है?

यदि आप `:set tags?` चलाते हैं, तो आप देख सकते हैं `tags=./tags,tags` (आपकी Vim सेटिंग के आधार पर, यह अलग हो सकता है)। यहाँ Vim वर्तमान फ़ाइल के पथ में सभी टैग की खोज करता है `./tags` के मामले में और वर्तमान निर्देशिका (आपकी परियोजना की जड़) के मामले में `tags`।

इसके अलावा `./tags` के मामले में, Vim सबसे पहले आपकी वर्तमान फ़ाइल के पथ के अंदर टैग फ़ाइल की खोज करेगा, चाहे वह कितनी भी नेस्टेड हो, फिर यह वर्तमान निर्देशिका (परियोजना की जड़) की टैग फ़ाइल की खोज करेगा। Vim पहले मिलान मिलने के बाद रुक जाता है।

यदि आपकी `'tags'` फ़ाइल में कहा गया होता `tags=./tags,tags,/user/iggy/mytags/tags`, तो Vim `/user/iggy/mytags` निर्देशिका में टैग फ़ाइल की खोज करेगा जब Vim `./tags` और `tags` निर्देशिका की खोज समाप्त कर लेगा। आपको अपनी टैग फ़ाइल को अपनी परियोजना के अंदर संग्रहीत करने की आवश्यकता नहीं है, आप उन्हें अलग रख सकते हैं।

एक नई टैग फ़ाइल स्थान जोड़ने के लिए, निम्नलिखित का उपयोग करें:

```shell
set tags+=path/to/my/tags/file
```

## बड़े प्रोजेक्ट के लिए टैग उत्पन्न करना

यदि आपने एक बड़े प्रोजेक्ट में ctags चलाने की कोशिश की, तो इसमें बहुत समय लग सकता है क्योंकि Vim हर नेस्टेड निर्देशिका के अंदर भी देखता है। यदि आप एक जावास्क्रिप्ट डेवलपर हैं, तो आप जानते हैं कि `node_modules` बहुत बड़ा हो सकता है। कल्पना करें कि आपके पास पांच उप-प्रोजेक्ट हैं और प्रत्येक में अपना `node_modules` निर्देशिका है। यदि आप `ctags -R .` चलाते हैं, तो ctags सभी 5 `node_modules` के माध्यम से स्कैन करने की कोशिश करेगा। आपको शायद `node_modules` पर ctags चलाने की आवश्यकता नहीं है।

`node_modules` को छोड़कर ctags चलाने के लिए, चलाएँ:

```shell
ctags -R --exclude=node_modules .
```

इस बार इसे एक सेकंड से कम समय लेना चाहिए। वैसे, आप `exclude` विकल्प का कई बार उपयोग कर सकते हैं:

```shell
ctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .
```

बात यह है, यदि आप किसी निर्देशिका को छोड़ना चाहते हैं, तो `--exclude` आपका सबसे अच्छा दोस्त है।

## टैग्स नेविगेशन

आप केवल `Ctrl-]` का उपयोग करके अच्छा मील प्राप्त कर सकते हैं, लेकिन चलिए कुछ और तरकीबें सीखते हैं। टैग कूदने की कुंजी `Ctrl-]` का एक कमांड-लाइन मोड विकल्प है: `:tag {tag-name}`। यदि आप चलाते हैं:

```shell
:tag donut
```

Vim `donut` विधि पर कूद जाएगा, ठीक वैसे ही जैसे "donut" स्ट्रिंग पर `Ctrl-]` करना। आप तर्क को भी `<Tab>` के साथ ऑटो-कंप्लीट कर सकते हैं:

```shell
:tag d<Tab>
```

Vim सभी टैग को सूचीबद्ध करता है जो "d" से शुरू होते हैं। इस मामले में, "donut"।

एक वास्तविक प्रोजेक्ट में, आप एक ही नाम के कई तरीकों का सामना कर सकते हैं। चलिए पहले की दो रूबी फ़ाइलों को अपडेट करते हैं। `one.rb` के अंदर:

```shell
## one.rb
class One
  def initialize
    puts "Initialized"
  end

  def donut
    puts "one donut"
  end

  def pancake
    puts "one pancake"
  end
end
```

`two.rb` के अंदर:

```shell
## two.rb
require './one.rb'

def pancake
  "Two pancakes"
end

one = One.new
one.donut
puts pancake
```

यदि आप कोडिंग कर रहे हैं, तो यह न भूलें कि आपको अब कई नई प्रक्रियाएँ होने के कारण फिर से `ctags -R .` चलाना होगा। आपके पास `pancake` प्रक्रिया के दो उदाहरण हैं। यदि आप `two.rb` के अंदर हैं और आपने `Ctrl-]` दबाया, तो क्या होगा?

Vim `two.rb` के अंदर `def pancake` पर कूद जाएगा, न कि `one.rb` के अंदर `def pancake` पर। इसका कारण यह है कि Vim `two.rb` के अंदर `pancake` प्रक्रिया को दूसरी `pancake` प्रक्रिया की तुलना में उच्च प्राथमिकता के रूप में देखता है।

## टैग प्राथमिकता

सभी टैग समान नहीं होते। कुछ टैग की उच्च प्राथमिकता होती है। यदि Vim को डुप्लिकेट आइटम नाम प्रस्तुत किए जाते हैं, तो Vim कीवर्ड की प्राथमिकता की जांच करता है। क्रम इस प्रकार है:

1. वर्तमान फ़ाइल में एक पूर्ण मेल खाता स्थिर टैग।
2. वर्तमान फ़ाइल में एक पूर्ण मेल खाता वैश्विक टैग।
3. एक अलग फ़ाइल में एक पूर्ण मेल खाता वैश्विक टैग।
4. एक अन्य फ़ाइल में एक पूर्ण मेल खाता स्थिर टैग।
5. वर्तमान फ़ाइल में एक केस-इनसेंसिटिवली मेल खाता स्थिर टैग।
6. वर्तमान फ़ाइल में एक केस-इनसेंसिटिवली मेल खाता वैश्विक टैग।
7. एक अलग फ़ाइल में एक केस-इनसेंसिटिवली मेल खाता वैश्विक टैग।
8. वर्तमान फ़ाइल में एक केस-इनसेंसिटिवली मेल खाता स्थिर टैग।

प्राथमिकता सूची के अनुसार, Vim उसी फ़ाइल में पाए गए सटीक मेल को प्राथमिकता देता है। यही कारण है कि Vim `two.rb` के अंदर `pancake` प्रक्रिया को `one.rb` के अंदर `pancake` प्रक्रिया पर चुनता है। आपकी `'tagcase'`, `'ignorecase'`, और `'smartcase'` सेटिंग्स के आधार पर प्राथमिकता सूची में कुछ अपवाद हो सकते हैं, लेकिन मैं इसे यहाँ चर्चा नहीं करूँगा। यदि आप रुचि रखते हैं, तो `:h tag-priority` की जांच करें।

## चयनात्मक टैग कूद

यह अच्छा होगा यदि आप चुन सकें कि किस टैग आइटम पर कूदना है, बजाय इसके कि हमेशा उच्च प्राथमिकता वाले टैग आइटम पर जाएँ। शायद आपको वास्तव में `two.rb` में `pancake` विधि पर कूदने की आवश्यकता है और न कि `one.rb` में। ऐसा करने के लिए, आप `:tselect` का उपयोग कर सकते हैं। चलाएँ:

```shell
:tselect pancake
```

आप स्क्रीन के नीचे देखेंगे:
## pri kind tag               file
1 F C f    pancake           two.rb
             def pancake
2 F   f    pancake           one.rb
             class:One
             def pancake
```

यदि आप 2 टाइप करते हैं, तो Vim `one.rb` में प्रक्रिया पर कूद जाएगा। यदि आप 1 टाइप करते हैं, तो Vim `two.rb` में प्रक्रिया पर कूद जाएगा।

`pri` कॉलम पर ध्यान दें। पहले मैच पर आपके पास `F C` है और दूसरे मैच पर `F` है। यही Vim टैग प्राथमिकता निर्धारित करने के लिए उपयोग करता है। `F C` का मतलब है कि यह वर्तमान (`C`) फ़ाइल में पूरी तरह से मेल खाता (`F`) वैश्विक टैग है। `F` का मतलब है केवल पूरी तरह से मेल खाता (`F`) वैश्विक टैग। `F C` हमेशा `F` की तुलना में उच्च प्राथमिकता रखता है।

यदि आप `:tselect donut` चलाते हैं, तो Vim आपको चयन करने के लिए टैग आइटम का चयन करने के लिए प्रेरित करता है, भले ही चुनने के लिए केवल एक विकल्प हो। क्या Vim केवल तभी टैग सूची को प्रदर्शित करने के लिए प्रेरित कर सकता है जब कई मेल हों और यदि केवल एक टैग पाया गया हो तो तुरंत कूद जाए?

बिल्कुल! Vim में `:tjump` विधि है। चलाएँ:

```shell
:tjump donut
```

Vim तुरंत `one.rb` में `donut` प्रक्रिया पर कूद जाएगा, जैसे कि `:tag donut` चलाना। अब चलाएँ:

```shell
:tjump pancake
```

Vim आपको चयन करने के लिए टैग विकल्पों को प्रेरित करेगा, जैसे कि `:tselect pancake` चलाना। `tjump` के साथ आपको दोनों विधियों का सर्वश्रेष्ठ मिलता है।

Vim में `tjump` के लिए एक सामान्य मोड कुंजी है: `g Ctrl-]`। मुझे व्यक्तिगत रूप से `g Ctrl-]` `Ctrl-]` से बेहतर लगता है।

## टैग के साथ ऑटो-कंप्लीशन

टैग ऑटो-कंप्लीशन में सहायता कर सकते हैं। अध्याय 6, इंसर्ट मोड से याद रखें, कि आप विभिन्न ऑटो-कंप्लीशन करने के लिए `Ctrl-X` उप-मोड का उपयोग कर सकते हैं। एक ऑटो-कंप्लीशन उप-मोड जिसका मैंने उल्लेख नहीं किया था वह है `Ctrl-]`। यदि आप इंसर्ट मोड में `Ctrl-X Ctrl-]` करते हैं, तो Vim ऑटो-कंप्लीशन के लिए टैग फ़ाइल का उपयोग करेगा।

यदि आप इंसर्ट मोड में जाते हैं और `Ctrl-x Ctrl-]` टाइप करते हैं, तो आप देखेंगे:

```shell
One
donut
initialize
pancake
```

## टैग स्टैक

Vim आपके द्वारा कूदे गए सभी टैग की एक सूची को टैग स्टैक में रखता है। आप इस स्टैक को `:tags` के साथ देख सकते हैं। यदि आपने पहले `pancake` पर टैग-जंप किया, उसके बाद `donut`, और `:tags` चलाया, तो आप देखेंगे:

```shell
  # TO tag         FROM line  in file/text
  1  1 pancake            10  ch16_tags/two.rb
  2  1 donut               9  ch16_tags/two.rb
>
```

ऊपर `>` प्रतीक पर ध्यान दें। यह आपके स्टैक में वर्तमान स्थिति को दर्शाता है। "पॉप" करने के लिए स्टैक को पिछले एक स्टैक पर वापस जाने के लिए, आप `:pop` चला सकते हैं। इसे आजमाएँ, फिर `:tags` फिर से चलाएँ:

```shell
  # TO tag         FROM line  in file/text
  1  1 pancake            10  puts pancake
> 2  1 donut               9  one.donut

```

ध्यान दें कि `>` प्रतीक अब दूसरी पंक्ति पर है, जहाँ `donut` है। एक बार और `pop` करें, फिर `:tags` फिर से चलाएँ:

```shell
  # TO tag         FROM line  in file/text
> 1  1 pancake            10  puts pancake
  2  1 donut               9  one.donut
```

सामान्य मोड में, आप `Ctrl-t` चला सकते हैं ताकि `:pop` के समान प्रभाव प्राप्त कर सकें।

## स्वचालित टैग जनरेशन

Vim टैग का एक बड़ा नुकसान यह है कि जब भी आप कोई महत्वपूर्ण परिवर्तन करते हैं, तो आपको टैग फ़ाइल को फिर से जनरेट करना होता है। यदि आपने हाल ही में `pancake` प्रक्रिया का नाम बदलकर `waffle` प्रक्रिया कर दिया है, तो टैग फ़ाइल को यह नहीं पता था कि `pancake` प्रक्रिया का नाम बदल दिया गया है। यह अभी भी टैग की सूची में `pancake` को संग्रहीत करता है। आपको एक अपडेटेड टैग फ़ाइल बनाने के लिए `ctags -R .` चलाना होगा। इस तरह से एक नई टैग फ़ाइल बनाना थकाऊ हो सकता है।

भाग्य से, टैग स्वचालित रूप से उत्पन्न करने के लिए आप कई विधियों का उपयोग कर सकते हैं।

## सेव पर टैग उत्पन्न करें

Vim में एक ऑटो-कमांड (`autocmd`) विधि है जो किसी घटना ट्रिगर पर कोई भी कमांड निष्पादित करती है। आप इसका उपयोग प्रत्येक सेव पर टैग उत्पन्न करने के लिए कर सकते हैं। चलाएँ:

```shell
:autocmd BufWritePost *.rb silent !ctags -R .
```

विवरण:
- `autocmd` एक कमांड-लाइन कमांड है। यह एक घटना, फ़ाइल पैटर्न, और एक कमांड स्वीकार करता है।
- `BufWritePost` एक बफर को सहेजने के लिए एक घटना है। प्रत्येक बार जब आप एक फ़ाइल को सहेजते हैं, तो आप एक `BufWritePost` घटना को ट्रिगर करते हैं।
- `.rb` एक फ़ाइल पैटर्न है जो रूबी फ़ाइलों के लिए है।
- `silent` वास्तव में उस कमांड का हिस्सा है जिसे आप पास कर रहे हैं। इसके बिना, Vim प्रत्येक बार जब आप ऑटो-कमांड को ट्रिगर करते हैं, तो `press ENTER or type command to continue` प्रदर्शित करेगा।
- `!ctags -R .` निष्पादित करने के लिए कमांड है। याद रखें कि `!cmd` Vim के अंदर से टर्मिनल कमांड निष्पादित करता है।

अब प्रत्येक बार जब आप एक रूबी फ़ाइल के अंदर से सेव करते हैं, तो Vim `ctags -R .` चलाएगा।

## प्लगइन्स का उपयोग करना

स्वचालित रूप से ctags उत्पन्न करने के लिए कई प्लगइन्स हैं:

- [vim-gutentags](https://github.com/ludovicchabant/vim-gutentags)
- [vim-tags](https://github.com/szw/vim-tags)
- [vim-easytags](https://github.com/xolox/vim-easytags)
- [vim-autotag](https://github.com/craigemery/vim-autotag)

मैं vim-gutentags का उपयोग करता हूँ। इसका उपयोग करना सरल है और यह सीधे बॉक्स से काम करेगा।

## Ctags और Git Hooks

टिम पोप, कई बेहतरीन Vim प्लगइन्स के लेखक, ने git hooks का उपयोग करने का सुझाव देने वाला एक ब्लॉग लिखा। [इसे देखें](https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html)।

## स्मार्ट तरीके से टैग सीखें

एक टैग तब उपयोगी होता है जब इसे सही तरीके से कॉन्फ़िगर किया गया हो। मान लीजिए कि आप एक नए कोडबेस का सामना कर रहे हैं और आप समझना चाहते हैं कि `functionFood` क्या करता है, आप आसानी से इसकी परिभाषा पर कूदकर इसे पढ़ सकते हैं। इसके अंदर, आप सीखते हैं कि यह भी `functionBreakfast` को कॉल करता है। आप इसका अनुसरण करते हैं और आप सीखते हैं कि यह `functionPancake` को कॉल करता है। आपका फ़ंक्शन कॉल ग्राफ कुछ इस तरह दिखता है:

```shell
functionFood -> functionBreakfast -> functionPancake
```

यह आपको यह जानकारी देता है कि यह कोड प्रवाह नाश्ते के लिए पैनकेक से संबंधित है।

टैग के बारे में अधिक जानने के लिए, `:h tags` देखें। अब जब आप जानते हैं कि टैग का उपयोग कैसे करना है, चलिए एक अलग विशेषता: फोल्डिंग का अन्वेषण करते हैं।