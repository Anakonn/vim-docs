---
description: यह दस्तावेज़ Vim में वेरिएबल्स के विभिन्न स्रोतों और स्कोप के बारे में
  जानकारी प्रदान करता है, जिसमें म्यूटेबल और इम्यूटेबल वेरिएबल्स शामिल हैं।
title: Ch27. Vimscript Variable Scopes
---

Vimscript फ़ंक्शनों में गोताखोरी करने से पहले, आइए Vim वेरिएबल्स के विभिन्न स्रोतों और दायरे के बारे में जानें।

## परिवर्तनीय और अपरिवर्तनीय वेरिएबल्स

आप Vim में `let` के साथ एक वेरिएबल को मान असाइन कर सकते हैं:

```shell
let pancake = "pancake"
```

बाद में आप किसी भी समय उस वेरिएबल को कॉल कर सकते हैं।

```shell
echo pancake
" returns "pancake"
```

`let` परिवर्तनीय है, जिसका अर्थ है कि आप भविष्य में किसी भी समय मान को बदल सकते हैं।

```shell
let pancake = "pancake"
let pancake = "not waffles"

echo pancake
" returns "not waffles"
```

ध्यान दें कि जब आप सेट वेरिएबल का मान बदलना चाहते हैं, तो आपको अभी भी `let` का उपयोग करना होगा।

```shell
let beverage = "milk"

beverage = "orange juice"
" throws an error
```

आप `const` के साथ एक अपरिवर्तनीय वेरिएबल परिभाषित कर सकते हैं। अपरिवर्तनीय होने के नाते, एक बार वेरिएबल मान असाइन करने के बाद, आप इसे किसी अन्य मान के साथ पुनः असाइन नहीं कर सकते।

```shell
const waffle = "waffle"
const waffle = "pancake"
" throws an error
```

## वेरिएबल स्रोत

वेरिएबल्स के लिए तीन स्रोत हैं: पर्यावरण वेरिएबल, विकल्प वेरिएबल, और रजिस्टर वेरिएबल।

### पर्यावरण वेरिएबल

Vim आपके टर्मिनल पर्यावरण वेरिएबल्स तक पहुँच सकता है। उदाहरण के लिए, यदि आपके टर्मिनल में `SHELL` पर्यावरण वेरिएबल उपलब्ध है, तो आप इसे Vim से इस प्रकार एक्सेस कर सकते हैं:

```shell
echo $SHELL
" returns $SHELL value. In my case, it returns /bin/bash
```

### विकल्प वेरिएबल

आप Vim विकल्पों को `&` के साथ एक्सेस कर सकते हैं (ये सेटिंग्स हैं जिन्हें आप `set` के साथ एक्सेस करते हैं)।

उदाहरण के लिए, यह देखने के लिए कि Vim कौन सा बैकग्राउंड उपयोग करता है, आप चला सकते हैं:

```shell
echo &background
" returns either "light" or "dark"
```

वैकल्पिक रूप से, आप हमेशा `set background?` चला सकते हैं ताकि `background` विकल्प का मान देख सकें।

### रजिस्टर वेरिएबल

आप Vim रजिस्टर (Ch. 08) को `@` के साथ एक्सेस कर सकते हैं।

मान लीजिए कि "चॉकलेट" का मान पहले से रजिस्टर a में सहेजा गया है। इसे एक्सेस करने के लिए, आप `@a` का उपयोग कर सकते हैं। आप इसे `let` के साथ भी अपडेट कर सकते हैं।

```shell
echo @a
" returns chocolate

let @a .= " donut"

echo @a
" returns "chocolate donut"
```

अब जब आप रजिस्टर `a` से पेस्ट करते हैं (`"ap`), तो यह "चॉकलेट डोनट" लौटाएगा। ऑपरेटर `.=` दो स्ट्रिंग्स को संयोजित करता है। अभिव्यक्ति `let @a .= " donut"` वही है जो `let @a = @a . " donut"`

## वेरिएबल दायरे

Vim में 9 विभिन्न वेरिएबल दायरे हैं। आप उन्हें उनके पूर्ववर्ती अक्षर से पहचान सकते हैं:

```shell
g:           वैश्विक वेरिएबल
{nothing}    वैश्विक वेरिएबल
b:           बफर-स्थानीय वेरिएबल
w:           विंडो-स्थानीय वेरिएबल
t:           टैब-स्थानीय वेरिएबल
s:           स्रोतित Vimscript वेरिएबल
l:           फ़ंक्शन स्थानीय वेरिएबल
a:           फ़ंक्शन औपचारिक पैरामीटर वेरिएबल
v:           अंतर्निहित Vim वेरिएबल
```

### वैश्विक वेरिएबल

जब आप एक "सामान्य" वेरिएबल घोषित कर रहे होते हैं:

```shell
let pancake = "pancake"
```

`pancake` वास्तव में एक वैश्विक वेरिएबल है। जब आप एक वैश्विक वेरिएबल परिभाषित करते हैं, तो आप उन्हें कहीं से भी कॉल कर सकते हैं।

एक वेरिएबल के साथ `g:` जोड़ने से भी एक वैश्विक वेरिएबल बनता है।

```shell
let g:waffle = "waffle"
```

इस मामले में `pancake` और `g:waffle` का एक ही दायरा है। आप प्रत्येक को `g:` के साथ या बिना कॉल कर सकते हैं।

```shell
echo pancake
" returns "pancake"

echo g:pancake
" returns "pancake"

echo waffle
" returns "waffle"

echo g:waffle
" returns "waffle"
```

### बफर वेरिएबल

`b:` के साथ पूर्ववर्ती वेरिएबल एक बफर वेरिएबल है। एक बफर वेरिएबल वह वेरिएबल है जो वर्तमान बफर के लिए स्थानीय है (Ch. 02)। यदि आपके पास कई बफर खुले हैं, तो प्रत्येक बफर की अपनी अलग बफर वेरिएबल्स की सूची होगी।

बफर 1 में:

```shell
const b:donut = "chocolate donut"
```

बफर 2 में:

```shell
const b:donut = "blueberry donut"
```

यदि आप बफर 1 से `echo b:donut` चलाते हैं, तो यह "चॉकलेट डोनट" लौटाएगा। यदि आप इसे बफर 2 से चलाते हैं, तो यह "ब्लूबेरी डोनट" लौटाएगा।

एक साइड नोट पर, Vim में एक *विशेष* बफर वेरिएबल `b:changedtick` है जो वर्तमान बफर में किए गए सभी परिवर्तनों को ट्रैक करता है।

1. `echo b:changedtick` चलाएँ और संख्या नोट करें जो यह लौटाता है।
2. Vim में परिवर्तन करें।
3. फिर से `echo b:changedtick` चलाएँ और नोट करें कि यह अब कौन सी संख्या लौटाता है।

### विंडो वेरिएबल

`w:` के साथ पूर्ववर्ती वेरिएबल एक विंडो वेरिएबल है। यह केवल उसी विंडो में मौजूद है।

विंडो 1 में:

```shell
const w:donut = "chocolate donut"
```

विंडो 2 में:

```shell
const w:donut = "raspberry donut"
```

प्रत्येक विंडो पर, आप अद्वितीय मान प्राप्त करने के लिए `echo w:donut` कॉल कर सकते हैं।

### टैब वेरिएबल

`t:` के साथ पूर्ववर्ती वेरिएबल एक टैब वेरिएबल है। यह केवल उसी टैब में मौजूद है।

टैब 1 में:

```shell
const t:donut = "chocolate donut"
```

टैब 2 में:

```shell
const t:donut = "blackberry donut"
```

प्रत्येक टैब पर, आप अद्वितीय मान प्राप्त करने के लिए `echo t:donut` कॉल कर सकते हैं।

### स्क्रिप्ट वेरिएबल

`s:` के साथ पूर्ववर्ती वेरिएबल एक स्क्रिप्ट वेरिएबल है। इन वेरिएबल्स को केवल उसी स्क्रिप्ट के अंदर एक्सेस किया जा सकता है।

यदि आपके पास एक मनमाना फ़ाइल `dozen.vim` है और इसके अंदर आपके पास है:

```shell
let s:dozen = 12

function Consume()
  let s:dozen -= 1
  echo s:dozen " is left"
endfunction
```

फ़ाइल को `:source dozen.vim` के साथ स्रोत करें। अब `Consume` फ़ंक्शन को कॉल करें:

```shell
:call Consume()
" returns "11 is left"

:call Consume()
" returns "10 is left"

:echo s:dozen
" Undefined variable error
```

जब आप `Consume` को कॉल करते हैं, तो आप देखते हैं कि यह अपेक्षित रूप से `s:dozen` मान को घटाता है। जब आप सीधे `s:dozen` मान प्राप्त करने की कोशिश करते हैं, तो Vim इसे नहीं पाएगा क्योंकि आप दायरे से बाहर हैं। `s:dozen` केवल `dozen.vim` के अंदर से एक्सेस किया जा सकता है।

हर बार जब आप `dozen.vim` फ़ाइल को स्रोत करते हैं, तो यह `s:dozen` काउंटर को रीसेट कर देता है। यदि आप `s:dozen` मान को घटाने के बीच में हैं और आप `:source dozen.vim` चलाते हैं, तो काउंटर 12 पर रीसेट हो जाता है। यह अनजान उपयोगकर्ताओं के लिए एक समस्या हो सकती है। इस समस्या को ठीक करने के लिए, कोड को फिर से लिखें:

```shell
if !exists("s:dozen")
  let s:dozen = 12
endif

function Consume()
  let s:dozen -= 1
  echo s:dozen
endfunction
```

अब जब आप घटाने के बीच में `dozen.vim` को स्रोत करते हैं, तो Vim `!exists("s:dozen")` पढ़ता है, यह पाता है कि यह सत्य है, और मान को 12 पर रीसेट नहीं करता है।

### फ़ंक्शन स्थानीय और फ़ंक्शन औपचारिक पैरामीटर वेरिएबल

फ़ंक्शन स्थानीय वेरिएबल (`l:`) और फ़ंक्शन औपचारिक वेरिएबल (`a:`) दोनों को अगले अध्याय में कवर किया जाएगा।

### अंतर्निहित Vim वेरिएबल्स

`v:` के साथ पूर्ववर्ती वेरिएबल एक विशेष अंतर्निहित Vim वेरिएबल है। आप इन वेरिएबल्स को परिभाषित नहीं कर सकते। आपने इनमें से कुछ पहले ही देखे हैं।
- `v:version` आपको बताता है कि आप कौन सा Vim संस्करण उपयोग कर रहे हैं।
- `v:key` उस समय की वर्तमान आइटम मान को रखता है जब आप एक डिक्शनरी के माध्यम से इटरेट कर रहे होते हैं।
- `v:val` उस समय की वर्तमान आइटम मान को रखता है जब आप `map()` या `filter()` ऑपरेशन चला रहे होते हैं।
- `v:true`, `v:false`, `v:null`, और `v:none` विशेष डेटा प्रकार हैं।

अन्य वेरिएबल्स भी हैं। Vim अंतर्निहित वेरिएबल्स की सूची के लिए, `:h vim-variable` या `:h v:` देखें।

## स्मार्ट तरीके से Vim वेरिएबल दायरों का उपयोग करना

पर्यावरण, विकल्प, और रजिस्टर वेरिएबल्स तक जल्दी पहुँच पाने की क्षमता आपको अपने संपादक और टर्मिनल वातावरण को अनुकूलित करने के लिए व्यापक लचीलापन देती है। आपने यह भी सीखा कि Vim में 9 विभिन्न वेरिएबल दायरे हैं, प्रत्येक एक निश्चित प्रतिबंधों के तहत मौजूद है। आप इन अद्वितीय वेरिएबल प्रकारों का लाभ उठाकर अपने प्रोग्राम को अलग कर सकते हैं।

आप यहाँ तक पहुँच चुके हैं। आपने डेटा प्रकारों, संयोजनों के साधनों, और वेरिएबल दायरों के बारे में सीखा। केवल एक चीज़ बाकी है: फ़ंक्शन।