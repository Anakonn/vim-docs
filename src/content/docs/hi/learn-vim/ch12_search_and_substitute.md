---
description: यह दस्तावेज़ खोज और प्रतिस्थापन के लिए नियमित अभिव्यक्तियों का उपयोग
  करने की विधियों को समझाता है, जिससे आप टेक्स्ट को तेजी से लक्षित कर सकते हैं।
title: Ch12. Search and Substitute
---

यह अध्याय दो अलग लेकिन संबंधित अवधारणाओं को कवर करता है: खोज और प्रतिस्थापन। अक्सर संपादन करते समय, आपको उनके सबसे सामान्य पैटर्न के आधार पर कई पाठों की खोज करने की आवश्यकता होती है। नियमित अभिव्यक्तियों का उपयोग करके खोज और प्रतिस्थापन में सीधे स्ट्रिंग के बजाय, आप किसी भी पाठ को जल्दी से लक्षित कर सकेंगे।

एक साइड नोट के रूप में, इस अध्याय में, मैं खोज के बारे में बात करते समय `/` का उपयोग करूंगा। आप जो कुछ भी `/` के साथ कर सकते हैं, उसे `?` के साथ भी किया जा सकता है।

## स्मार्ट केस संवेदनशीलता

खोज शब्द के केस को मिलाना मुश्किल हो सकता है। यदि आप "Learn Vim" पाठ की खोज कर रहे हैं, तो आप एक अक्षर के केस को गलत टाइप कर सकते हैं और एक गलत खोज परिणाम प्राप्त कर सकते हैं। क्या यह आसान और सुरक्षित नहीं होगा यदि आप किसी भी केस को मिलाने में सक्षम हो सकें? यहीं पर विकल्प `ignorecase` चमकता है। बस अपने vimrc में `set ignorecase` जोड़ें और आपके सभी खोज शब्द केस संवेदनशील नहीं हो जाएंगे। अब आपको `/Learn Vim` करने की आवश्यकता नहीं है, `/learn vim` काम करेगा।

हालांकि, ऐसे समय होते हैं जब आपको एक केस विशिष्ट वाक्यांश की खोज करने की आवश्यकता होती है। ऐसा करने का एक तरीका `ignorecase` विकल्प को बंद करना है, लेकिन जब भी आपको केस संवेदनशील वाक्यांश की खोज करने की आवश्यकता होती है, तो यह हर बार चालू और बंद करने का बहुत काम है।

`ignorecase` को टॉगल करने से बचने के लिए, Vim में एक `smartcase` विकल्प है जो केस संवेदनशील स्ट्रिंग की खोज करता है यदि खोज पैटर्न *कम से कम एक बड़े अक्षर को शामिल करता है*। आप दोनों `ignorecase` और `smartcase` को संयोजित कर सकते हैं ताकि जब आप सभी छोटे अक्षर दर्ज करें तो एक केस संवेदनशील खोज करें और जब आप एक या अधिक बड़े अक्षर दर्ज करें तो एक केस संवेदनशील खोज करें।

अपने vimrc में जोड़ें:

```shell
set ignorecase smartcase
```

यदि आपके पास ये पाठ हैं:

```shell
hello
HELLO
Hello
```

- `/hello` "hello", "HELLO", और "Hello" से मेल खाता है।
- `/HELLO` केवल "HELLO" से मेल खाता है।
- `/Hello` केवल "Hello" से मेल खाता है।

एक कमी है। यदि आपको केवल एक छोटे अक्षर की खोज करने की आवश्यकता है तो क्या होगा? जब आप `/hello` करते हैं, तो Vim अब केस संवेदनशील खोज करता है। आप अपने खोज शब्द में कहीं भी `\C` पैटर्न का उपयोग कर सकते हैं ताकि Vim को बताएं कि अगला खोज शब्द केस संवेदनशील होगा। यदि आप `/\Chello` करते हैं, तो यह "hello" से सख्ती से मेल खाएगा, न कि "HELLO" या "Hello" से।

## एक पंक्ति में पहला और अंतिम अक्षर

आप `^` का उपयोग करके एक पंक्ति में पहले अक्षर से मेल खा सकते हैं और `$` का उपयोग करके एक पंक्ति में अंतिम अक्षर से मेल खा सकते हैं।

यदि आपके पास यह पाठ है:

```shell
hello hello
```

आप पहले "hello" को `/^hello` के साथ लक्षित कर सकते हैं। `^` के बाद का अक्षर पंक्ति में पहला अक्षर होना चाहिए। अंतिम "hello" को लक्षित करने के लिए, `/hello$` चलाएं। `$` के पहले का अक्षर पंक्ति में अंतिम अक्षर होना चाहिए।

यदि आपके पास यह पाठ है:

```shell
hello hello friend
```

`/hello$` चलाने पर कुछ भी मेल नहीं खाएगा क्योंकि "friend" उस पंक्ति में अंतिम शब्द है, "hello" नहीं।

## खोज को दोहराना

आप पिछले खोज को `//` के साथ दोहरा सकते हैं। यदि आपने अभी `/hello` के लिए खोज की है, तो `//` चलाना `/hello` चलाने के बराबर है। यह शॉर्टकट आपको कुछ कीस्ट्रोक्स बचा सकता है, खासकर यदि आपने अभी एक लंबे स्ट्रिंग के लिए खोज की है। यह भी याद रखें कि आप अंतिम खोज को समान दिशा और विपरीत दिशा में क्रमशः `n` और `N` का उपयोग करके दोहरा सकते हैं।

यदि आप *n* अंतिम खोज शब्द को जल्दी से याद करना चाहते हैं तो क्या होगा? आप पहले `/` दबाकर खोज इतिहास को जल्दी से पार कर सकते हैं, फिर `up`/`down` तीर कुंजियों (या `Ctrl-N`/`Ctrl-P`) को तब तक दबाएं जब तक आपको आवश्यक खोज शब्द न मिल जाए। अपने सभी खोज इतिहास को देखने के लिए, आप `:history /` चला सकते हैं।

जब आप खोज करते समय एक फ़ाइल के अंत में पहुँचते हैं, तो Vim एक त्रुटि फेंकता है: `"Search hit the BOTTOM without match for: {your-search}"`। कभी-कभी यह अधिक खोज से सुरक्षा का एक अच्छा उपाय हो सकता है, लेकिन अन्य बार आप खोज को फिर से शीर्ष पर लाना चाहते हैं। आप `set wrapscan` विकल्प का उपयोग कर सकते हैं ताकि Vim फ़ाइल के अंत पर पहुँचने पर फिर से फ़ाइल के शीर्ष पर खोज कर सके। इस सुविधा को बंद करने के लिए, `set nowrapscan` करें।

## वैकल्पिक शब्दों की खोज

एक साथ कई शब्दों की खोज करना सामान्य है। यदि आपको "hello vim" या "hola vim" में से किसी एक की खोज करने की आवश्यकता है, लेकिन "salve vim" या "bonjour vim" नहीं, तो आप `|` पैटर्न का उपयोग कर सकते हैं।

इस पाठ को देखते हुए:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

दोनों "hello" और "hola" से मेल खाने के लिए, आप `/hello\|hola` कर सकते हैं। आपको या तो (`|`) ऑपरेटर को एस्केप (`\`) करना होगा, अन्यथा Vim सचमुच "|" स्ट्रिंग की खोज करेगा।

यदि आप हर बार `\|` टाइप नहीं करना चाहते हैं, तो आप खोज की शुरुआत में `magic` सिंटैक्स (`\v`) का उपयोग कर सकते हैं: `/\vhello|hola`। मैं इस गाइड में `magic` को कवर नहीं करूंगा, लेकिन `\v` के साथ, आपको विशेष वर्णों को एस्केप करने की आवश्यकता नहीं है। `\v` के बारे में अधिक जानने के लिए, कृपया `:h \v` देखें।

## मिलान की शुरुआत और अंत को सेट करना

शायद आपको एक पाठ की खोज करने की आवश्यकता है जो एक यौगिक शब्द का हिस्सा है। यदि आपके पास ये पाठ हैं:

```shell
11vim22
vim22
11vim
vim
```

यदि आपको "vim" का चयन करना है लेकिन केवल जब यह "11" से शुरू होता है और "22" पर समाप्त होता है, तो आप `\zs` (शुरुआती मिलान) और `\ze` (अंतिम मिलान) ऑपरेटर का उपयोग कर सकते हैं। चलाएं:

```shell
/11\zsvim\ze22
```

Vim को अभी भी पूरे पैटर्न "11vim22" से मेल खाना होगा, लेकिन केवल `\zs` और `\ze` के बीच के पैटर्न को हाइलाइट करता है। एक और उदाहरण:

```shell
foobar
foobaz
```

यदि आपको "foobaz" में "foo" से मेल खाने की आवश्यकता है लेकिन "foobar" में नहीं, तो चलाएं:

```shell
/foo\zebaz
```

## वर्ण सीमा की खोज

अब तक आपके सभी खोज शब्द एक शाब्दिक शब्द खोज रहे हैं। वास्तविक जीवन में, आपको अपने पाठ को खोजने के लिए एक सामान्य पैटर्न का उपयोग करने की आवश्यकता हो सकती है। सबसे बुनियादी पैटर्न वर्ण सीमा है, `[ ]`।

यदि आपको किसी भी अंक की खोज करने की आवश्यकता है, तो आप शायद हर बार `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0` टाइप नहीं करना चाहेंगे। इसके बजाय, एकल अंक के लिए मेल करने के लिए `/[0-9]` का उपयोग करें। `0-9` अभिव्यक्ति 0-9 के अंकों की एक सीमा का प्रतिनिधित्व करती है जिसे Vim मेल करने का प्रयास करेगा, इसलिए यदि आप 1 से 5 के बीच के अंकों की तलाश कर रहे हैं, तो `/[1-5]` का उपयोग करें।

अंक ही एकमात्र डेटा प्रकार नहीं हैं जिन्हें Vim देख सकता है। आप छोटे अक्षरों के लिए `/[a-z]` और बड़े अक्षरों के लिए `/[A-Z]` का उपयोग कर सकते हैं।

आप इन सीमाओं को एक साथ संयोजित कर सकते हैं। यदि आपको 0-9 के अंकों और "a" से "f" (जैसे एक हेक्स) के बीच के छोटे और बड़े अक्षरों की खोज करने की आवश्यकता है, तो आप `/[0-9a-fA-F]` कर सकते हैं।

नकारात्मक खोज करने के लिए, आप वर्ण सीमा ब्रैकेट के भीतर `^` जोड़ सकते हैं। एक गैर-अंक की खोज करने के लिए, चलाएं `/[^0-9]`। Vim किसी भी वर्ण से मेल खाएगा जब तक कि यह अंक न हो। सावधान रहें कि ब्रैकेट के भीतर का कैरेट (`^`) एक पंक्ति की शुरुआत के कैरेट से अलग है (जैसे: `/^hello`)। यदि एक कैरेट ब्रैकेट के एक जोड़े के बाहर है और खोज शब्द में पहला अक्षर है, तो इसका अर्थ है "एक पंक्ति में पहला अक्षर"। यदि एक कैरेट ब्रैकेट के एक जोड़े के भीतर है और यह ब्रैकेट के भीतर का पहला अक्षर है, तो इसका अर्थ है नकारात्मक खोज ऑपरेटर। `/^abc` एक पंक्ति में पहले "abc" से मेल खाता है और `/[^abc]` किसी भी वर्ण से मेल खाता है सिवाय "a", "b", या "c" के।

## दोहराए जाने वाले अक्षरों की खोज

यदि आपको इस पाठ में दो अंकों की खोज करने की आवश्यकता है:

```shell
1aa
11a
111
```

आप `/[0-9][0-9]` का उपयोग कर सकते हैं ताकि दो अंकों के वर्ण से मेल खा सके, लेकिन यह विधि स्केलेबल नहीं है। यदि आपको बीस अंकों से मेल खाने की आवश्यकता है तो क्या होगा? `[0-9]` को बीस बार टाइप करना मजेदार अनुभव नहीं है। यही कारण है कि आपको `count` तर्क की आवश्यकता है।

आप अपनी खोज में `count` पास कर सकते हैं। इसकी निम्नलिखित सिंटैक्स है:

```shell
{n,m}
```

वैसे, इन `count` ब्रैसेस को जब आप Vim में उपयोग करते हैं तो एस्केप करना आवश्यक है। `count` ऑपरेटर को उस एकल वर्ण के बाद रखा जाता है जिसे आप बढ़ाना चाहते हैं।

यहाँ `count` सिंटैक्स के चार अलग-अलग रूप हैं:
- `{n}` एक सटीक मिलान है। `/[0-9]\{2\}` दो अंकों की संख्याओं से मेल खाता है: "11" और "111" में "11"।
- `{n,m}` एक सीमा मिलान है। `/[0-9]\{2,3\}` 2 और 3 अंकों की संख्याओं के बीच मेल खाता है: "11" और "111"।
- `{,m}` एक अधिकतम मिलान है। `/[0-9]\{,3\}` 3 अंकों की संख्याओं तक मेल खाता है: "1", "11", और "111"।
- `{n,}` एक न्यूनतम मिलान है। `/[0-9]\{2,\}` कम से कम 2 या अधिक अंकों की संख्याओं से मेल खाता है: "11" और "111"।

`count` तर्क `\{0,\}` (शून्य या अधिक) और `\{1,\}` (एक या अधिक) सामान्य खोज पैटर्न हैं और Vim के लिए उनके विशेष ऑपरेटर हैं: `*` और `+` (`+` को एस्केप करने की आवश्यकता होती है जबकि `*` बिना एस्केप के ठीक काम करता है)। यदि आप `/[0-9]*` करते हैं, तो यह `/[0-9]\{0,\}` के समान है। यह शून्य या अधिक अंकों की खोज करता है। यह "", "1", "123" से मेल खाएगा। वैसे, यह "a" जैसे गैर-अंकों से भी मेल खाएगा, क्योंकि "a" में तकनीकी रूप से शून्य अंक है। `*` का उपयोग करने से पहले सोच-समझकर निर्णय लें। यदि आप `/[0-9]\+` करते हैं, तो यह `/[0-9]\{1,\}` के समान है। यह एक या अधिक अंकों की खोज करता है। यह "1" और "12" से मेल खाएगा।

## पूर्वनिर्धारित वर्ण सीमाएँ

Vim में सामान्य वर्णों जैसे अंकों और अक्षरों के लिए पूर्वनिर्धारित सीमाएँ हैं। मैं यहाँ हर एक को नहीं बताऊंगा, लेकिन आप पूरी सूची `:h /character-classes` के अंदर पा सकते हैं। यहाँ कुछ उपयोगी हैं:

```shell
\d    अंक [0-9]
\D    गैर-अंक [^0-9]
\s    व्हाइटस्पेस वर्ण (स्पेस और टैब)
\S    गैर-व्हाइटस्पेस वर्ण (स्पेस और टैब को छोड़कर सब कुछ)
\w    शब्द वर्ण [0-9A-Za-z_]
\l    छोटे अक्षर [a-z]
\u    बड़े अक्षर [A-Z]
```

आप उनका उपयोग उसी तरह कर सकते हैं जैसे आप वर्ण सीमाओं का उपयोग करते हैं। किसी भी एकल अंक की खोज करने के लिए, `/[0-9]` का उपयोग करने के बजाय, आप `/\d` का उपयोग कर सकते हैं ताकि सिंटैक्स अधिक संक्षिप्त हो सके।

## खोज उदाहरण: समान वर्णों के जोड़े के बीच एक पाठ को कैप्चर करना

यदि आप एक वाक्यांश की खोज करना चाहते हैं जो डबल कोट्स के एक जोड़े से घिरा हुआ है:

```shell
"Vim is awesome!"
```

यह चलाएं:

```shell
/"[^"]\+"
```

आइए इसे तोड़ते हैं:
- `"` एक शाब्दिक डबल कोट है। यह पहले डबल कोट से मेल खाता है।
- `[^"]` का अर्थ है डबल कोट के अलावा कोई भी वर्ण। यह किसी भी अल्फ़ान्यूमेरिक और व्हाइटस्पेस वर्ण से मेल खाता है जब तक कि यह डबल कोट न हो।
- `\+` का अर्थ है एक या अधिक। चूंकि यह `[^"]` के द्वारा पूर्ववत है, Vim एक या अधिक वर्णों की तलाश करता है जो डबल कोट नहीं हैं।
- `"` एक शाब्दिक डबल कोट है। यह बंद डबल कोट से मेल खाता है।

जब Vim पहले `"` को देखता है, तो यह पैटर्न कैप्चर करना शुरू करता है। जैसे ही यह एक पंक्ति में दूसरे डबल कोट को देखता है, यह दूसरे `"` पैटर्न से मेल खाता है और पैटर्न कैप्चर करना बंद कर देता है। इस बीच, सभी गैर-डबल-कोट वर्ण जो बीच में हैं, `[^"]\+` पैटर्न द्वारा कैप्चर किए जाते हैं, इस मामले में, वाक्यांश `Vim is awesome!`। यह एक सामान्य पैटर्न है जो समान डिलिमिटर्स के एक जोड़े से घिरे वाक्यांश को कैप्चर करने के लिए उपयोग किया जाता है।

- एकल कोट्स से घिरे वाक्यांश को कैप्चर करने के लिए, आप `/'[^']\+'` का उपयोग कर सकते हैं।
- शून्य से घिरे वाक्यांश को कैप्चर करने के लिए, आप `/0[^0]\+0` का उपयोग कर सकते हैं।

## खोज उदाहरण: फोन नंबर कैप्चर करना

यदि आप एक हाइफ़न (`-`) द्वारा अलग किए गए यूएस फोन नंबर से मेल खाना चाहते हैं, जैसे `123-456-7890`, तो आप उपयोग कर सकते हैं:

```shell
/\d\{3\}-\d\{3\}-\d\{4\}
```

यूएस फोन नंबर तीन अंकों की संख्या के एक सेट, उसके बाद तीन और अंकों, और अंत में चार अंकों से मिलकर बनता है। आइए इसे तोड़ते हैं:
- `\d\{3\}` एक अंक को ठीक तीन बार दोहराने से मेल खाता है
- `-` एक शाब्दिक हाइफ़न है

आप एस्केप टाइपिंग से बच सकते हैं `\v` के साथ:

```shell
/\v\d{3}-\d{3}-\d{4}
```

यह पैटर्न किसी भी दोहराए जाने वाले अंकों को कैप्चर करने के लिए भी उपयोगी है, जैसे आईपी पते और ज़िप कोड।

यह इस अध्याय के खोज भाग को कवर करता है। अब चलिए प्रतिस्थापन पर चलते हैं।

## बुनियादी प्रतिस्थापन

Vim का प्रतिस्थापन आदेश किसी भी पैटर्न को जल्दी से खोजने और बदलने के लिए एक उपयोगी आदेश है। प्रतिस्थापन की सिंटैक्स है:

```shell
:s/{old-pattern}/{new-pattern}/
```

आइए एक बुनियादी उपयोग से शुरू करें। यदि आपके पास यह पाठ है:

```shell
vim is good
```

आइए "good" को "awesome" से प्रतिस्थापित करें क्योंकि Vim अद्भुत है। चलाएं `:s/good/awesome/`। आपको यह दिखाई देना चाहिए:

```shell
vim is awesome
```
## अंतिम प्रतिस्थापन को दोहराना

आप अंतिम प्रतिस्थापन आदेश को सामान्य आदेश `&` या `:s` चलाकर दोहरा सकते हैं। यदि आपने अभी `:s/good/awesome/` चलाया है, तो `&` या `:s` चलाने से यह दोहराएगा।

इसके अलावा, इस अध्याय में मैंने पहले उल्लेख किया था कि आप पिछले खोज पैटर्न को दोहराने के लिए `//` का उपयोग कर सकते हैं। यह चाल प्रतिस्थापन आदेश के साथ काम करती है। यदि `/good` हाल ही में किया गया था और आप पहले प्रतिस्थापन पैटर्न तर्क को खाली छोड़ देते हैं, जैसे `:s//awesome/`, तो यह `:s/good/awesome/` चलाने के समान काम करेगा।

## प्रतिस्थापन सीमा

जैसे कई Ex आदेशों में, आप प्रतिस्थापन आदेश में एक सीमा तर्क पास कर सकते हैं। सिंटैक्स है:

```shell
:[range]s/old/new/
```

यदि आपके पास ये अभिव्यक्तियाँ हैं:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

तीन से पांच पंक्तियों में "let" को "const" में प्रतिस्थापित करने के लिए, आप कर सकते हैं:

```shell
:3,5s/let/const/
```

यहाँ कुछ सीमा भिन्नताएँ हैं जिन्हें आप पास कर सकते हैं:

- `:,3s/let/const/` - यदि कॉमा से पहले कुछ नहीं दिया गया है, तो यह वर्तमान पंक्ति का प्रतिनिधित्व करता है। वर्तमान पंक्ति से पंक्ति 3 तक प्रतिस्थापित करें।
- `:1,s/let/const/` - यदि कॉमा के बाद कुछ नहीं दिया गया है, तो यह भी वर्तमान पंक्ति का प्रतिनिधित्व करता है। पंक्ति 1 से वर्तमान पंक्ति तक प्रतिस्थापित करें।
- `:3s/let/const/` - यदि केवल एक मान सीमा के रूप में दिया गया है (कोई कॉमा नहीं), तो यह केवल उस पंक्ति पर प्रतिस्थापन करता है।

Vim में, `%` आमतौर पर पूरे फ़ाइल का प्रतिनिधित्व करता है। यदि आप `:%s/let/const/` चलाते हैं, तो यह सभी पंक्तियों पर प्रतिस्थापन करेगा। इस सीमा सिंटैक्स का ध्यान रखें। कई कमांड-लाइन आदेश जो आप आगामी अध्यायों में सीखेंगे, इस रूप का पालन करेंगे।

## पैटर्न मिलान

अगले कुछ अनुभाग बुनियादी नियमित अभिव्यक्तियों को कवर करेंगे। प्रतिस्थापन आदेश में महारत हासिल करने के लिए मजबूत पैटर्न ज्ञान आवश्यक है।

यदि आपके पास निम्नलिखित अभिव्यक्तियाँ हैं:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

अंक के चारों ओर डबल कोट्स जोड़ने के लिए:

```shell
:%s/\d/"\0"/
```

परिणाम:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

आइए आदेश को तोड़ते हैं:
- `:%s` पूरे फ़ाइल को प्रतिस्थापन करने के लिए लक्षित करता है।
- `\d` अंकों के लिए Vim की पूर्वनिर्धारित सीमा है (जैसे `[0-9]` का उपयोग करना)।
- `"\0"` यहाँ डबल कोट्स वास्तविक डबल कोट्स हैं। `\0` एक विशेष वर्ण है जो "पूरे मेल खाने वाले पैटर्न" का प्रतिनिधित्व करता है। यहाँ मेल खाने वाला पैटर्न एकल अंक संख्या है, `\d`।

वैकल्पिक रूप से, `&` भी पूरे मेल खाने वाले पैटर्न का प्रतिनिधित्व करता है जैसे `\0`। `:s/\d/"&"/` भी काम करेगा।

आइए एक और उदाहरण पर विचार करें। दिए गए इन अभिव्यक्तियों और आपको सभी "let" को चर नामों के साथ स्वैप करने की आवश्यकता है।

```shell
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

यह करने के लिए, चलाएँ:

```shell
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

ऊपर दिया गया आदेश बहुत सारे बैकस्लैशों को शामिल करता है और पढ़ने में कठिन है। इस मामले में `\v` ऑपरेटर का उपयोग करना अधिक सुविधाजनक है:

```shell
:%s/\v(\w+) (\w+)/\2 \1/
```

परिणाम:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

बहुत अच्छा! आइए उस आदेश को तोड़ते हैं:
- `:%s` फ़ाइल में सभी पंक्तियों को प्रतिस्थापन करने के लिए लक्षित करता है।
- `(\w+) (\w+)` एक समूह मिलान है। `\w` Vim की पूर्वनिर्धारित सीमाओं में से एक है जो एक शब्द वर्ण का प्रतिनिधित्व करता है (`[0-9A-Za-z_]`)। इसके चारों ओर `( )` एक समूह में एक शब्द वर्ण मिलान को कैप्चर करता है। दोनों समूहों के बीच का स्थान ध्यान दें। `(\w+) (\w+)` दो समूहों को कैप्चर करता है। पहला समूह "one" को कैप्चर करता है और दूसरा समूह "two" को कैप्चर करता है।
- `\2 \1` उल्टे क्रम में कैप्चर किए गए समूह को लौटाता है। `\2` में कैप्चर किया गया स्ट्रिंग "let" और `\1` में स्ट्रिंग "one" है। `\2 \1` होने पर "let one" स्ट्रिंग लौटाता है।

याद रखें कि `\0` पूरे मेल खाने वाले पैटर्न का प्रतिनिधित्व करता है। आप मेल खाने वाली स्ट्रिंग को छोटे समूहों में `( )` के साथ तोड़ सकते हैं। प्रत्येक समूह को `\1`, `\2`, `\3`, आदि द्वारा दर्शाया जाता है।

आइए इस समूह मिलान अवधारणा को मजबूत करने के लिए एक और उदाहरण करें। यदि आपके पास ये संख्याएँ हैं:

```shell
123
456
789
```

क्रम को उलटने के लिए, चलाएँ:

```shell
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

परिणाम है:

```shell
321
654
987
```

प्रत्येक `(\d)` प्रत्येक अंक से मेल खाता है और एक समूह बनाता है। पहले पंक्ति में, पहले `(\d)` का मान 1 है, दूसरे `(\d)` का मान 2 है, और तीसरे `(\d)` का मान 3 है। उन्हें `\1`, `\2`, और `\3` में संग्रहीत किया गया है। प्रतिस्थापन के दूसरे भाग में, नया पैटर्न `\3\2\1` पहले पंक्ति पर "321" मान का परिणाम देता है।

यदि आपने इसके बजाय यह चलाया होता:

```shell
:%s/\v(\d\d)(\d)/\2\1/
```
आपको एक अलग परिणाम मिला होता:

```shell
312
645
978
```

यह इसलिए है क्योंकि अब आपके पास केवल दो समूह हैं। पहला समूह, `(\d\d)` द्वारा कैप्चर किया गया है, `\1` में संग्रहीत है और इसका मान 12 है। दूसरा समूह, `(\d)` द्वारा कैप्चर किया गया है, `\2` में संग्रहीत है और इसका मान 3 है। फिर, `\2\1` 312 लौटाता है।

## प्रतिस्थापन ध्वज

यदि आपके पास वाक्य है:

```shell
चॉकलेट पैनकेक, स्ट्रॉबेरी पैनकेक, ब्लूबेरी पैनकेक
```

सभी पैनकेक्स को डोनट्स में प्रतिस्थापित करने के लिए, आप बस यह नहीं चला सकते:

```shell
:s/pancake/donut
```

ऊपर दिया गया आदेश केवल पहले मेल को प्रतिस्थापित करेगा, जिससे आपको मिलेगा:

```shell
चॉकलेट डोनट, स्ट्रॉबेरी पैनकेक, ब्लूबेरी पैनकेक
```

इसका समाधान करने के दो तरीके हैं। आप या तो प्रतिस्थापन आदेश को दो बार और चला सकते हैं या आप इसे एक वैश्विक (`g`) ध्वज पास कर सकते हैं ताकि एक पंक्ति में सभी मेल को प्रतिस्थापित किया जा सके।

आइए वैश्विक ध्वज के बारे में बात करते हैं। चलाएँ:

```shell
:s/pancake/donut/g
```

Vim एक तेज़ आदेश में सभी पैनकेक्स को डोनट्स में प्रतिस्थापित करता है। वैश्विक आदेश प्रतिस्थापन आदेश द्वारा स्वीकार किए जाने वाले कई ध्वजों में से एक है। आप प्रतिस्थापन आदेश के अंत में ध्वज पास करते हैं। यहाँ कुछ उपयोगी ध्वजों की सूची है:

```shell
&    पिछले प्रतिस्थापन आदेश से ध्वज पुन: उपयोग करें।
g    पंक्ति में सभी मेल को प्रतिस्थापित करें।
c    प्रतिस्थापन की पुष्टि के लिए पूछें।
e    प्रतिस्थापन विफल होने पर त्रुटि संदेश को प्रदर्शित होने से रोकें।
i    केस संवेदनशील प्रतिस्थापन करें।
I    केस संवेदनहीन प्रतिस्थापन करें।
```

और भी ध्वज हैं जो मैंने ऊपर सूचीबद्ध नहीं किए हैं। सभी ध्वजों के बारे में पढ़ने के लिए, `:h s_flags` देखें।

वैसे, पुनरावृत्ति-प्रतिस्थापन आदेश (`&` और `:s`) ध्वजों को बनाए नहीं रखते हैं। `&` चलाने से केवल `:s/pancake/donut/` को `g` के बिना दोहराएगा। पिछले प्रतिस्थापन आदेश को सभी ध्वजों के साथ जल्दी से दोहराने के लिए, `:&&` चलाएँ।

## डिलिमिटर बदलना

यदि आपको एक URL को लंबे पथ के साथ प्रतिस्थापित करने की आवश्यकता है:

```shell
https://mysite.com/a/b/c/d/e
```

इसे "hello" शब्द के साथ प्रतिस्थापित करने के लिए, चलाएँ:

```shell
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

हालांकि, यह बताना कठिन है कि कौन से फॉरवर्ड स्लैश (`/`) प्रतिस्थापन पैटर्न का हिस्सा हैं और कौन से डिलिमिटर्स हैं। आप किसी भी एकल-बाइट वर्ण (अक्षरों, संख्याओं, या `"`, `|`, और `\` को छोड़कर) के साथ डिलिमिटर बदल सकते हैं। आइए उन्हें `+` से प्रतिस्थापित करें। ऊपर दिया गया प्रतिस्थापन आदेश फिर इस प्रकार लिखा जा सकता है:

```shell
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

अब यह देखना आसान है कि डिलिमिटर्स कहाँ हैं।

## विशेष प्रतिस्थापन

आप प्रतिस्थापित किए जा रहे पाठ के केस को भी संशोधित कर सकते हैं। दिए गए निम्नलिखित अभिव्यक्तियों और आपके कार्य में "one", "two", "three", आदि के चर को अपरकेस करना है।

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

चलाएँ:

```shell
:%s/\v(\w+) (\w+)/\1 \U\2/
```

आपको मिलेगा:

```shell
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

तोड़ना:
- `(\w+) (\w+)` पहले दो मेल खाने वाले समूहों को कैप्चर करता है, जैसे "let" और "one"।
- `\1` पहले समूह का मान लौटाता है, "let"।
- `\U\2` दूसरे समूह (`\2`) को अपरकेस करता है।

इस आदेश का ट्रिक `\U\2` अभिव्यक्ति है। `\U` अगले वर्ण को अपरकेस करने का निर्देश देता है।

आइए एक और उदाहरण करें। मान लीजिए आप एक Vim गाइड लिख रहे हैं और आपको एक पंक्ति में प्रत्येक शब्द के पहले अक्षर को बड़े अक्षर में लिखने की आवश्यकता है।

```shell
vim is the greatest text editor in the whole galaxy
```

आप चला सकते हैं:

```shell
:s/\<./\U&/g
```

परिणाम:

```shell
Vim Is The Greatest Text Editor In The Whole Galaxy
```

यहाँ तोड़ना:
- `:s` वर्तमान पंक्ति को प्रतिस्थापित करता है।
- `\<.` दो भागों से मिलकर बना है: `\<` शब्द की शुरुआत को मेल करने के लिए और `.` किसी भी वर्ण को मेल करने के लिए। `\<` ऑपरेटर अगले वर्ण को शब्द का पहला वर्ण बनाता है। चूंकि `.` अगला वर्ण है, यह किसी भी शब्द का पहला वर्ण मेल करेगा।
- `\U&` बाद के प्रतीक, `&` को अपरकेस करता है। याद रखें कि `&` (या `\0`) पूरे मेल को दर्शाता है। यह किसी भी शब्द का पहला वर्ण मेल करता है।
- `g` वैश्विक ध्वज। इसके बिना, यह आदेश केवल पहले मेल को प्रतिस्थापित करता है। आपको इस पंक्ति पर प्रत्येक मेल को प्रतिस्थापित करने की आवश्यकता है।

प्रतिस्थापन के विशेष प्रतिस्थापन प्रतीकों जैसे `\U` के बारे में अधिक जानने के लिए, `:h sub-replace-special` देखें।

## वैकल्पिक पैटर्न

कभी-कभी आपको एक साथ कई पैटर्न से मेल खाने की आवश्यकता होती है। यदि आपके पास निम्नलिखित अभिवादन हैं:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

आपको "vim" शब्द को "friend" के साथ प्रतिस्थापित करना है लेकिन केवल उन पंक्तियों पर जो "hello" या "hola" शब्द को शामिल करती हैं। इस अध्याय में पहले याद रखें, आप कई वैकल्पिक पैटर्न के लिए `|` का उपयोग कर सकते हैं।

```shell
:%s/\v(hello|hola) vim/\1 friend/g
```

परिणाम:

```shell
hello friend
hola friend
salve vim
bonjour vim
```

यहाँ तोड़ना:
- `%s` फ़ाइल में प्रत्येक पंक्ति पर प्रतिस्थापन आदेश चलाता है।
- `(hello|hola)` *या* "hello" या "hola" से मेल खाता है और इसे एक समूह के रूप में मानता है।
- `vim` वास्तविक शब्द "vim" है।
- `\1` पहला समूह है, जो "hello" या "hola" पाठ है।
- `friend` वास्तविक शब्द "friend" है।

## पैटर्न की शुरुआत और अंत को प्रतिस्थापित करना

याद रखें कि आप `\zs` और `\ze` का उपयोग करके मेल के प्रारंभ और अंत को परिभाषित कर सकते हैं। यह तकनीक प्रतिस्थापन में भी काम करती है। यदि आपके पास है:

```shell
चॉकलेट पैनकेक
स्ट्रॉबेरी स्वीटकेक
ब्लूबेरी हॉटकेक
```

"हॉटकेक" में "केक" को "डॉग" के साथ प्रतिस्थापित करने के लिए ताकि "हॉटडॉग" प्राप्त हो:

```shell
:%s/hot\zscake/dog/g
```

परिणाम:

```shell
चॉकलेट पैनकेक
स्ट्रॉबेरी स्वीटकेक
ब्लूबेरी हॉटडॉग
```
## लालची और गैर-लालची

आप इस ट्रिक के साथ एक पंक्ति में nth मिलान को प्रतिस्थापित कर सकते हैं:

```shell
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

तीसरे "Mississippi" को "Arkansas" के साथ प्रतिस्थापित करने के लिए, चलाएँ:

```shell
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

विवरण:
- `:s/` प्रतिस्थापन कमांड है।
- `\v` जादुई कीवर्ड है ताकि आपको विशेष कीवर्ड को एस्केप करने की आवश्यकता न हो।
- `.` किसी भी एकल अक्षर से मेल खाता है।
- `{-}` पूर्ववर्ती परमाणु का 0 या अधिक गैर-लालची मिलान करता है।
- `\zsMississippi` "Mississippi" को मिलान की शुरुआत बनाता है।
- `(...){3}` तीसरे मिलान की तलाश करता है।

आपने इस अध्याय में `{3}` सिंटैक्स को पहले देखा है। इस मामले में, `{3}` ठीक तीसरे मिलान से मेल खाएगा। यहाँ नया ट्रिक `{-}` है। यह एक गैर-लालची मिलान है। यह दिए गए पैटर्न का सबसे छोटा मिलान खोजता है। इस मामले में, `(.{-}Mississippi)` किसी भी अक्षर द्वारा पूर्ववर्ती "Mississippi" की सबसे कम मात्रा से मेल खाता है। इसे `(.*Mississippi)` के साथ तुलना करें जहाँ यह दिए गए पैटर्न का सबसे लंबा मिलान खोजता है।

यदि आप `(.{-}Mississippi)` का उपयोग करते हैं, तो आपको पाँच मिलान मिलते हैं: "One Mississippi", "Two Mississippi", आदि। यदि आप `(.*Mississippi)` का उपयोग करते हैं, तो आपको एक मिलान मिलता है: अंतिम "Mississippi"। `*` एक लालची मिलानकर्ता है और `{-}` एक गैर-लालची मिलानकर्ता है। अधिक जानने के लिए `:h /\{-` और `:h non-greedy` देखें।

चलो एक सरल उदाहरण करते हैं। यदि आपके पास स्ट्रिंग है:

```shell
abc1de1
```

आप "abc1de1" (लालची) से मेल खा सकते हैं:

```shell
/a.*1
```

आप "abc1" (गैर-लालची) से मेल खा सकते हैं:

```shell
/a.\{-}1
```

तो यदि आपको सबसे लंबे मिलान (लालची) को अपरकेस करना है, तो चलाएँ:

```shell
:s/a.*1/\U&/g
```

ताकि प्राप्त करें:

```shell
ABC1DEFG1
```

यदि आपको सबसे छोटे मिलान (गैर-लालची) को अपरकेस करना है, तो चलाएँ:

```shell
:s/a.\{-}1/\U&/g
```

ताकि प्राप्त करें:

```shell
ABC1defg1
```

यदि आप लालची बनाम गैर-लालची अवधारणा में नए हैं, तो इसे समझना कठिन हो सकता है। जब तक आप इसे समझ न लें, विभिन्न संयोजनों के साथ प्रयोग करें।

## कई फ़ाइलों में प्रतिस्थापन

अंत में, चलो सीखते हैं कि कई फ़ाइलों में वाक्यांशों को कैसे प्रतिस्थापित किया जाए। इस अनुभाग के लिए, मान लें कि आपके पास दो फ़ाइलें हैं: `food.txt` और `animal.txt`।

`food.txt` के अंदर:

```shell
corndog
hotdog
chilidog
```

`animal.txt` के अंदर:

```shell
large dog
medium dog
small dog
```

मान लें कि आपकी निर्देशिका संरचना इस तरह दिखती है:

```shell
- food.txt
- animal.txt
```

पहले, `:args` के अंदर `food.txt` और `animal.txt` दोनों को कैप्चर करें। पहले के अध्यायों से याद रखें कि `:args` का उपयोग फ़ाइल नामों की एक सूची बनाने के लिए किया जा सकता है। Vim के अंदर इसे करने के कई तरीके हैं, उनमें से एक है:

```shell
:args *.txt                  वर्तमान स्थान में सभी txt फ़ाइलों को कैप्चर करता है
```

इसे परीक्षण करने के लिए, जब आप `:args` चलाते हैं, तो आपको यह देखना चाहिए:

```shell
[food.txt] animal.txt
```

अब जब सभी प्रासंगिक फ़ाइलें तर्क सूची में संग्रहीत हैं, तो आप `:argdo` कमांड के साथ एक बहु-फ़ाइल प्रतिस्थापन कर सकते हैं। चलाएँ:

```shell
:argdo %s/dog/chicken/
```

यह `:args` सूची के अंदर सभी फ़ाइलों के खिलाफ प्रतिस्थापन करता है। अंत में, परिवर्तित फ़ाइलों को सहेजने के लिए चलाएँ:

```shell
:argdo update
```

`:args` और `:argdo` कई फ़ाइलों में कमांड लाइन कमांड लागू करने के लिए उपयोगी उपकरण हैं। इसे अन्य कमांड के साथ आज़माएँ!

## मैक्रोज़ के साथ कई फ़ाइलों में प्रतिस्थापन

वैकल्पिक रूप से, आप मैक्रोज़ के साथ कई फ़ाइलों में प्रतिस्थापन कमांड भी चला सकते हैं। चलाएँ:

```shell
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

विवरण:
- `:args *.txt` सभी टेक्स्ट फ़ाइलों को `:args` सूची में जोड़ता है।
- `qq` "q" रजिस्टर में मैक्रो शुरू करता है।
- `:%s/dog/chicken/g` वर्तमान फ़ाइल में सभी पंक्तियों पर "dog" को "chicken" के साथ प्रतिस्थापित करता है।
- `:wnext` फ़ाइल को सहेजता है और फिर `args` सूची में अगली फ़ाइल पर जाता है।
- `q` मैक्रो रिकॉर्डिंग को रोकता है।
- `99@q` मैक्रो को निन्यानवे बार निष्पादित करता है। Vim पहले त्रुटि का सामना करने पर मैक्रो निष्पादन को रोक देगा, इसलिए Vim वास्तव में मैक्रो को निन्यानवे बार निष्पादित नहीं करेगा।

## स्मार्ट तरीके से खोज और प्रतिस्थापन सीखना

अच्छी खोज करने की क्षमता संपादन में एक आवश्यक कौशल है। खोज में महारत हासिल करने से आपको किसी फ़ाइल में किसी भी पैटर्न की खोज के लिए नियमित अभिव्यक्तियों की लचीलापन का उपयोग करने की अनुमति मिलती है। इन चीज़ों को सीखने के लिए अपना समय लें। नियमित अभिव्यक्ति के साथ बेहतर होने के लिए, आपको नियमित अभिव्यक्तियों का सक्रिय रूप से उपयोग करना होगा। मैंने एक बार नियमित अभिव्यक्ति के बारे में एक किताब पढ़ी थी बिना वास्तव में इसे किए और उसके बाद मैंने जो कुछ भी पढ़ा था, लगभग सब कुछ भूल गया। सक्रिय कोडिंग किसी भी कौशल में महारत हासिल करने का सबसे अच्छा तरीका है।

आपकी पैटर्न मिलान कौशल को सुधारने का एक अच्छा तरीका है जब भी आपको किसी पैटर्न (जैसे "hello 123") के लिए खोजने की आवश्यकता हो, तो सीधे खोज शब्द (`/hello 123`) के लिए पूछने के बजाय, इसके लिए एक पैटर्न बनाने की कोशिश करें (कुछ ऐसा जैसे `/\v(\l+) (\d+)`)। इनमें से कई नियमित अभिव्यक्ति अवधारणाएँ सामान्य प्रोग्रामिंग में भी लागू होती हैं, केवल Vim का उपयोग करते समय नहीं।

अब जब आपने Vim में उन्नत खोज और प्रतिस्थापन के बारे में सीखा है, चलो सबसे बहुपरकारी कमांड, वैश्विक कमांड के बारे में सीखते हैं।