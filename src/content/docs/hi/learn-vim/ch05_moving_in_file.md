---
description: इस दस्तावेज़ में, आप Vim के मूल गति और उनके कुशल उपयोग के बारे में जानेंगे,
  जिससे आप फ़ाइलों में तेजी से नेविगेट कर सकें।
title: Ch05. Moving in a File
---

शुरुआत में, कीबोर्ड के साथ चलना धीमा और अजीब लगता है लेकिन हार मत मानो! एक बार जब आप इसकी आदत डाल लेते हैं, तो आप माउस का उपयोग करने की तुलना में फ़ाइल में कहीं भी तेजी से जा सकते हैं।

इस अध्याय में, आप आवश्यक गतियों को सीखेंगे और उन्हें प्रभावी ढंग से कैसे उपयोग करना है। ध्यान रखें कि यह **सभी** गतियाँ नहीं हैं जो Vim के पास हैं। यहाँ का लक्ष्य उपयोगी गतियों को पेश करना है ताकि आप जल्दी उत्पादक बन सकें। यदि आपको और अधिक सीखने की आवश्यकता है, तो `:h motion.txt` देखें।

## वर्ण नेविगेशन

सबसे बुनियादी गति इकाई एक वर्ण को बाईं ओर, नीचे, ऊपर और दाईं ओर ले जाना है।

```shell
h   बाईं ओर
j   नीचे
k   ऊपर
l   दाईं ओर
gj  एक नरम लिपटे हुए लाइन में नीचे
gk  एक नरम लिपटे हुए लाइन में ऊपर
```

आप दिशा सूचक तीरों के साथ भी चल सकते हैं। यदि आप अभी शुरुआत कर रहे हैं, तो किसी भी विधि का उपयोग करने में संकोच न करें जो आपको सबसे अधिक आरामदायक लगे।

मैं `hjkl` को पसंद करता हूँ क्योंकि मेरा दाहिना हाथ होम रो में रह सकता है। ऐसा करने से मुझे आस-पास की कुंजियों तक छोटी पहुँच मिलती है। `hjkl` की आदत डालने के लिए, मैंने वास्तव में शुरुआत में तीर बटन को अक्षम कर दिया था और इसे `~/.vimrc` में जोड़ दिया था:

```shell
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

इस बुरी आदत को तोड़ने में मदद करने के लिए प्लगइन्स भी हैं। उनमें से एक है [vim-hardtime](https://github.com/takac/vim-hardtime)। मेरी आश्चर्य की बात है कि मुझे `hjkl` की आदत डालने में एक सप्ताह से भी कम समय लगा।

यदि आप सोचते हैं कि Vim `hjkl` का उपयोग क्यों करता है, तो इसका कारण यह है कि Lear-Siegler ADM-3A टर्मिनल जहाँ बिल जॉय ने Vi लिखा था, में तीर कुंजियाँ नहीं थीं और `hjkl` का उपयोग बाईं/नीचे/ऊपर/दाईं ओर के लिए किया गया था।*

## सापेक्ष संख्या

मुझे लगता है कि `number` और `relativenumber` सेट करना सहायक है। आप इसे `.vimrc` में यह जोड़कर कर सकते हैं:

```shell
set relativenumber number
```

यह मेरी वर्तमान पंक्ति संख्या और सापेक्ष पंक्ति संख्याएँ प्रदर्शित करता है।

बाईं कॉलम में संख्या होना उपयोगी है, लेकिन आप में से कुछ पूछ सकते हैं कि बाईं कॉलम में सापेक्ष संख्याएँ होना कैसे उपयोगी हो सकता है। एक सापेक्ष संख्या मुझे जल्दी से यह देखने की अनुमति देती है कि मेरा कर्सर लक्ष्य पाठ से कितनी पंक्तियों की दूरी पर है। इससे, मैं आसानी से देख सकता हूँ कि मेरा लक्ष्य पाठ मुझसे 12 पंक्तियाँ नीचे है ताकि मैं `d12j` कर सकूँ उन्हें हटाने के लिए। अन्यथा, यदि मैं पंक्ति 69 पर हूँ और मेरा लक्ष्य पंक्ति 81 पर है, तो मुझे मानसिक गणना करनी होगी (81 - 69 = 12)। संपादन करते समय गणित करना बहुत अधिक मानसिक संसाधनों की आवश्यकता होती है। जितना कम मुझे यह सोचना पड़े कि मुझे कहाँ जाना है, उतना बेहतर है।

यह 100% व्यक्तिगत पसंद है। `relativenumber` / `norelativenumber`, `number` / `nonumber` के साथ प्रयोग करें और जो भी आपको सबसे उपयोगी लगे उसका उपयोग करें!

## अपनी गति की गणना करें

आइए "गणना" तर्क के बारे में बात करते हैं। Vim गतियाँ एक पूर्ववर्ती संख्यात्मक तर्क को स्वीकार करती हैं। मैंने ऊपर उल्लेख किया कि आप `12j` के साथ 12 पंक्तियों नीचे जा सकते हैं। `12j` में 12 संख्या है।

गति के साथ गणना का उपयोग करने की सिंटैक्स है:

```shell
[count] + motion
```

आप इसे सभी गतियों पर लागू कर सकते हैं। यदि आप दाईं ओर 9 वर्णों की गति करना चाहते हैं, तो `l` को 9 बार दबाने के बजाय, आप `9l` कर सकते हैं।

## शब्द नेविगेशन

आइए एक बड़े गति इकाई की ओर बढ़ते हैं: *शब्द*। आप अगले शब्द के आरंभ (`w`), अगले शब्द के अंत (`e`), पिछले शब्द के आरंभ (`b`), और पिछले शब्द के अंत (`ge`) पर जा सकते हैं।

इसके अलावा, *WORD* है, जो शब्द से भिन्न है। आप अगले WORD के आरंभ (`W`), अगले WORD के अंत (`E`), पिछले WORD के आरंभ (`B`), और पिछले WORD के अंत (`gE`) पर जा सकते हैं। याद रखने में आसान बनाने के लिए, WORD वही अक्षर उपयोग करता है जो शब्द, केवल बड़े अक्षरों में।

```shell
w     अगले शब्द के आरंभ की ओर आगे बढ़ें
W     अगले WORD के आरंभ की ओर आगे बढ़ें
e     अगले शब्द के अंत की ओर एक शब्द आगे बढ़ें
E     अगले WORD के अंत की ओर एक शब्द आगे बढ़ें
b     पिछले शब्द के आरंभ की ओर पीछे बढ़ें
B     पिछले WORD के आरंभ की ओर पीछे बढ़ें
ge    पिछले शब्द के अंत की ओर पीछे बढ़ें
gE    पिछले WORD के अंत की ओर पीछे बढ़ें
```

तो शब्द और WORD के बीच समानताएँ और भिन्नताएँ क्या हैं? दोनों शब्द और WORD खाली वर्णों द्वारा अलग किए जाते हैं। एक शब्द केवल `a-zA-Z0-9_` वर्णों की एक अनुक्रम है। एक WORD सभी वर्णों की एक अनुक्रम है सिवाय सफेद स्थान (सफेद स्थान का अर्थ है या तो स्पेस, टैब, और EOL)। अधिक जानने के लिए, `:h word` और `:h WORD` देखें।

उदाहरण के लिए, मान लीजिए आपके पास है:

```shell
const hello = "world";
```

यदि आपके कर्सर की स्थिति पंक्ति की शुरुआत में है, तो `l` के साथ पंक्ति के अंत तक जाने में आपको 21 कुंजी दबाने की आवश्यकता होगी। `w` का उपयोग करने पर, यह 6 लेगा। `W` का उपयोग करने पर, यह केवल 4 लेगा। दोनों शब्द और WORD छोटे दूरी तय करने के लिए अच्छे विकल्प हैं।

हालांकि, आप "c" से ";" तक एक कीस्ट्रोक में जा सकते हैं वर्तमान पंक्ति नेविगेशन के साथ।

## वर्तमान पंक्ति नेविगेशन

संपादन करते समय, आपको अक्सर एक पंक्ति में क्षैतिज रूप से नेविगेट करने की आवश्यकता होती है। वर्तमान पंक्ति में पहले वर्ण पर कूदने के लिए, `0` का उपयोग करें। वर्तमान पंक्ति में अंतिम वर्ण पर जाने के लिए, `$` का उपयोग करें। इसके अतिरिक्त, आप वर्तमान पंक्ति में पहले गैर-खाली वर्ण पर जाने के लिए `^` का उपयोग कर सकते हैं और वर्तमान पंक्ति में अंतिम गैर-खाली वर्ण पर जाने के लिए `g_` का उपयोग कर सकते हैं। यदि आप वर्तमान पंक्ति में कॉलम `n` पर जाना चाहते हैं, तो आप `n|` का उपयोग कर सकते हैं।

```shell
0     वर्तमान पंक्ति में पहले वर्ण पर जाएँ
^     वर्तमान पंक्ति में पहले गैर-खाली वर्ण पर जाएँ
g_    वर्तमान पंक्ति में अंतिम गैर-खाली वर्ण पर जाएँ
$     वर्तमान पंक्ति में अंतिम वर्ण पर जाएँ
n|    वर्तमान पंक्ति में कॉलम n पर जाएँ
```

आप `f` और `t` के साथ वर्तमान पंक्ति खोज कर सकते हैं। `f` और `t` के बीच का अंतर यह है कि `f` आपको मेल के पहले अक्षर पर ले जाता है और `t` आपको मेल के पहले अक्षर से पहले तक ले जाता है। इसलिए यदि आप "h" के लिए खोज करना चाहते हैं और "h" पर उतरना चाहते हैं, तो `fh` का उपयोग करें। यदि आप पहले "h" के लिए खोज करना चाहते हैं और मेल से ठीक पहले उतरना चाहते हैं, तो `th` का उपयोग करें। यदि आप पिछले वर्तमान पंक्ति खोज की *अगली* घटना पर जाना चाहते हैं, तो `;` का उपयोग करें। पिछले वर्तमान पंक्ति मेल की घटना पर जाने के लिए, `,` का उपयोग करें।

`F` और `T` `f` और `t` के पीछे के समकक्ष हैं। "h" के लिए पीछे की ओर खोजने के लिए, `Fh` चलाएँ। "h" के लिए उसी दिशा में खोज जारी रखने के लिए, `;` का उपयोग करें। ध्यान दें कि `;` के बाद `Fh` पीछे की ओर खोजता है और `,` के बाद `Fh` आगे की ओर खोजता है।

```shell
f    वर्तमान पंक्ति में मेल के लिए आगे खोजें
F    वर्तमान पंक्ति में मेल के लिए पीछे खोजें
t    वर्तमान पंक्ति में मेल के लिए आगे खोजें, मेल से पहले रुकते हुए
T    वर्तमान पंक्ति में मेल के लिए पीछे खोजें, मेल से पहले रुकते हुए
;    पिछले खोज को उसी दिशा में दोहराएँ
,    पिछले खोज को विपरीत दिशा में दोहराएँ
```

पिछले उदाहरण पर वापस:

```shell
const hello = "world";
```

यदि आपके कर्सर की स्थिति पंक्ति की शुरुआत में है, तो आप वर्तमान पंक्ति में अंतिम वर्ण (";") पर एक कीस्ट्रोक के साथ जा सकते हैं: `$`। यदि आप "world" में "w" पर जाना चाहते हैं, तो आप `fw` का उपयोग कर सकते हैं। एक अच्छी टिप यह है कि किसी भी पंक्ति में कहीं भी जाने के लिए, अपने लक्ष्य के पास "j", "x", "z" जैसे कम सामान्य अक्षरों की तलाश करें।

## वाक्य और अनुच्छेद नेविगेशन

अगले दो नेविगेशन इकाइयाँ वाक्य और अनुच्छेद हैं।

पहले हम बात करते हैं कि वाक्य क्या है। एक वाक्य का अंत या तो `. ! ?` से होता है जो एक EOL, एक स्पेस, या एक टैब के बाद आता है। आप अगले वाक्य पर `)` और पिछले वाक्य पर `(` के साथ कूद सकते हैं।

```shell
(    पिछले वाक्य पर कूदें
)    अगले वाक्य पर कूदें
```

आइए कुछ उदाहरणों पर नज़र डालते हैं। आप किस वाक्यांश को वाक्य मानते हैं और किसे नहीं? Vim में `(` और `)` के साथ नेविगेट करने की कोशिश करें!

```shell
I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :

There is an empty line above me.
```

वैसे, यदि आप Vim के साथ वाक्य को गिनने में समस्या का सामना कर रहे हैं जो `.` द्वारा अलग किए गए वाक्यांशों के लिए है जो एक एकल पंक्ति के बाद आता है, तो आप `'compatible'` मोड में हो सकते हैं। `vimrc` में `set nocompatible` जोड़ें। Vi में, एक वाक्य एक `.` है जो **दो** स्पेस के बाद आता है। आपको हमेशा `nocompatible` सेट करना चाहिए।

आइए बात करें कि अनुच्छेद क्या है। एक अनुच्छेद प्रत्येक खाली पंक्ति के बाद शुरू होता है और अनुच्छेद विकल्प में वर्णों के जोड़े द्वारा निर्दिष्ट अनुच्छेद मैक्रो के प्रत्येक सेट पर भी शुरू होता है।

```shell
{    पिछले अनुच्छेद पर कूदें
}    अगले अनुच्छेद पर कूदें
```

यदि आप सुनिश्चित नहीं हैं कि अनुच्छेद मैक्रो क्या है, तो चिंता न करें। महत्वपूर्ण बात यह है कि एक अनुच्छेद एक खाली पंक्ति के बाद शुरू और समाप्त होता है। यह अधिकांश समय सच होना चाहिए।

आइए इस उदाहरण पर नज़र डालते हैं। `}` और `{` के साथ चारों ओर नेविगेट करने की कोशिश करें (साथ ही, चारों ओर जाने के लिए वाक्य नेविगेशन `( )` के साथ भी खेलें!)

```shell
Hello. How are you? I am great, thanks!
Vim is awesome.
It may not easy to learn it at first...- but we are in this together. Good luck!

Hello again.

Try to move around with ), (, }, and {. Feel how they work.
You got this.
```

अधिक जानने के लिए `:h sentence` और `:h paragraph` देखें।

## मेल नेविगेशन

प्रोग्रामर कोड लिखते और संपादित करते हैं। कोड में आमतौर पर कोष्ठक, ब्रेसेस, और ब्रैकेट्स होते हैं। आप इनमें आसानी से खो सकते हैं। यदि आप एक के अंदर हैं, तो आप दूसरे जोड़े पर कूद सकते हैं (यदि यह मौजूद है) `%` के साथ। आप यह यह देखने के लिए भी उपयोग कर सकते हैं कि क्या आपके पास मेल खाने वाले कोष्ठक, ब्रेसेस, और ब्रैकेट्स हैं।

```shell
%    दूसरे मेल पर नेविगेट करें, आमतौर पर () [], {}
```

आइए एक Scheme कोड उदाहरण पर नज़र डालते हैं क्योंकि यह कोष्ठकों का व्यापक रूप से उपयोग करता है। विभिन्न कोष्ठकों के अंदर `%` के साथ चारों ओर चलें।

```shell
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

मैं व्यक्तिगत रूप से `%` को दृश्य संकेतक प्लगइन्स जैसे [vim-rainbow](https://github.com/frazrepo/vim-rainbow) के साथ जोड़ना पसंद करता हूँ। अधिक जानने के लिए, `:h %` देखें।

## पंक्ति संख्या नेविगेशन

आप `nG` के साथ पंक्ति संख्या `n` पर कूद सकते हैं। उदाहरण के लिए, यदि आप पंक्ति 7 पर कूदना चाहते हैं, तो `7G` का उपयोग करें। पहले पंक्ति पर कूदने के लिए, `1G` या `gg` का उपयोग करें। अंतिम पंक्ति पर कूदने के लिए, `G` का उपयोग करें।

अक्सर आप यह नहीं जानते कि आपका लक्ष्य किस पंक्ति संख्या पर है, लेकिन आप जानते हैं कि यह पूरे फ़ाइल का लगभग 70% पर है। इस मामले में, आप `70%` कर सकते हैं। फ़ाइल के मध्य में कूदने के लिए, आप `50%` कर सकते हैं।

```shell
gg    पहले पंक्ति पर जाएँ
G     अंतिम पंक्ति पर जाएँ
nG    पंक्ति n पर जाएँ
n%    फ़ाइल में n% पर जाएँ
```

वैसे, यदि आप फ़ाइल में कुल पंक्तियों को देखना चाहते हैं, तो आप `Ctrl-g` का उपयोग कर सकते हैं।

## विंडो नेविगेशन

अपने *विंडो* के शीर्ष, मध्य, या तल पर जल्दी जाने के लिए, आप `H`, `M`, और `L` का उपयोग कर सकते हैं।

आप `H` और `L` को एक गणना भी दे सकते हैं। यदि आप `10H` का उपयोग करते हैं, तो आप विंडो के शीर्ष से 10 पंक्तियों नीचे जाएंगे। यदि आप `3L` का उपयोग करते हैं, तो आप विंडो की अंतिम पंक्ति से 3 पंक्तियों ऊपर जाएंगे।

```shell
H     स्क्रीन के शीर्ष पर जाएँ
M     मध्य स्क्रीन पर जाएँ
L     स्क्रीन के तल पर जाएँ
nH    शीर्ष से n पंक्तियों पर जाएँ
nL    तल से n पंक्तियों पर जाएँ
```

## स्क्रॉलिंग

स्क्रॉल करने के लिए, आपके पास 3 गति वृद्धि हैं: पूर्ण-स्क्रीन (`Ctrl-F/Ctrl-B`), आधा-स्क्रीन (`Ctrl-D/Ctrl-U`), और पंक्ति (`Ctrl-E/Ctrl-Y`)।

```shell
Ctrl-E    एक पंक्ति नीचे स्क्रॉल करें
Ctrl-D    आधा स्क्रीन नीचे स्क्रॉल करें
Ctrl-F    पूरे स्क्रीन नीचे स्क्रॉल करें
Ctrl-Y    एक पंक्ति ऊपर स्क्रॉल करें
Ctrl-U    आधा स्क्रीन ऊपर स्क्रॉल करें
Ctrl-B    पूरे स्क्रीन ऊपर स्क्रॉल करें
```

आप वर्तमान पंक्ति के सापेक्ष भी स्क्रॉल कर सकते हैं (स्क्रीन दृष्टि को ज़ूम करें):

```shell
zt    वर्तमान पंक्ति को आपकी स्क्रीन के शीर्ष के करीब लाएँ
zz    वर्तमान पंक्ति को आपकी स्क्रीन के मध्य में लाएँ
zb    वर्तमान पंक्ति को आपकी स्क्रीन के तल के करीब लाएँ
```
## खोज नेविगेशन

अक्सर आप जानते हैं कि एक वाक्यांश एक फ़ाइल के अंदर मौजूद है। आप अपने लक्ष्य तक बहुत जल्दी पहुँचने के लिए खोज नेविगेशन का उपयोग कर सकते हैं। किसी वाक्यांश को खोजने के लिए, आप आगे की खोज के लिए `/` और पीछे की खोज के लिए `?` का उपयोग कर सकते हैं। अंतिम खोज को दोहराने के लिए आप `n` का उपयोग कर सकते हैं। अंतिम खोज को विपरीत दिशा में दोहराने के लिए, आप `N` का उपयोग कर सकते हैं।

```shell
/    मिलान के लिए आगे खोजें
?    मिलान के लिए पीछे खोजें
n    पिछले खोज को उसी दिशा में दोहराएं
N    पिछले खोज को विपरीत दिशा में दोहराएं
```

मान लीजिए आपके पास यह पाठ है:

```shell
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

यदि आप "let" के लिए खोज रहे हैं, तो `/let` चलाएँ। "let" के लिए फिर से जल्दी से खोजने के लिए, आप बस `n` कर सकते हैं। विपरीत दिशा में "let" के लिए फिर से खोजने के लिए, `N` चलाएँ। यदि आप `?let` चलाते हैं, तो यह "let" के लिए पीछे खोजेगा। यदि आप `n` का उपयोग करते हैं, तो यह अब "let" के लिए पीछे खोजेगा (`N` अब "let" के लिए आगे खोजेगा)।

आप `set hlsearch` के साथ खोज हाइलाइट सक्षम कर सकते हैं। अब जब आप `/let` के लिए खोजते हैं, तो यह फ़ाइल में *सभी* मिलान करने वाले वाक्यांशों को हाइलाइट करेगा। इसके अलावा, आप `set incsearch` के साथ वृद्धिशील खोज सेट कर सकते हैं। यह टाइप करते समय पैटर्न को हाइलाइट करेगा। डिफ़ॉल्ट रूप से, आपके मिलान करने वाले वाक्यांश तब तक हाइलाइट रहते हैं जब तक आप किसी अन्य वाक्यांश के लिए खोज नहीं करते। यह जल्दी ही एक परेशानी में बदल सकता है। हाइलाइट को बंद करने के लिए, आप `:nohlsearch` या बस `:noh` चला सकते हैं। क्योंकि मैं इस नो-हाइलाइट सुविधा का अक्सर उपयोग करता हूँ, मैंने vimrc में एक मैप बनाया है:

```shell
nnoremap <esc><esc> :noh<return><esc>
```

आप `*` के साथ कर्सर के नीचे पाठ के लिए जल्दी से खोज सकते हैं ताकि आगे की खोज हो और `#` के साथ पीछे की खोज हो। यदि आपका कर्सर "one" स्ट्रिंग पर है, तो `*` दबाने का मतलब होगा जैसे आपने `/\<one\>` किया हो।

`\<` और `\>` दोनों `/\<one\>` में पूरे शब्द की खोज का अर्थ है। यह "one" से मेल नहीं खाता यदि यह एक बड़े शब्द का हिस्सा है। यह "one" शब्द के लिए मेल खाता है लेकिन "onetwo" के लिए नहीं। यदि आपका कर्सर "one" पर है और आप "one" और "onetwo" जैसे पूरे या आंशिक शब्दों से मेल खाने के लिए आगे खोज करना चाहते हैं, तो आपको `*` के बजाय `g*` का उपयोग करना होगा।

```shell
*     कर्सर के नीचे पूरे शब्द के लिए आगे खोजें
#     कर्सर के नीचे पूरे शब्द के लिए पीछे खोजें
g*    कर्सर के नीचे शब्द के लिए आगे खोजें
g#    कर्सर के नीचे शब्द के लिए पीछे खोजें
```

## स्थिति को चिह्नित करना

आप अपने वर्तमान स्थिति को सहेजने और बाद में इस स्थिति पर लौटने के लिए मार्क्स का उपयोग कर सकते हैं। यह पाठ संपादन के लिए एक बुकमार्क की तरह है। आप `mx` के साथ एक मार्क सेट कर सकते हैं, जहाँ `x` कोई भी वर्णमाला का अक्षर `a-zA-Z` हो सकता है। मार्क पर लौटने के दो तरीके हैं: सटीक (लाइन और कॉलम) ` `x` के साथ और लाइनवाइज (`'x`)।

```shell
ma    मार्क "a" के साथ स्थिति को चिह्नित करें
`a    लाइन और कॉलम "a" पर कूदें
'a    लाइन "a" पर कूदें
```

छोटे अक्षरों (a-z) और बड़े अक्षरों (A-Z) के साथ मार्क करने में एक अंतर है। छोटे अक्षर स्थानीय मार्क होते हैं और बड़े अक्षर वैश्विक मार्क होते हैं (कभी-कभी फ़ाइल मार्क के रूप में जाने जाते हैं)।

आइए स्थानीय मार्क्स के बारे में बात करते हैं। प्रत्येक बफर में अपने स्वयं के स्थानीय मार्क्स का एक सेट हो सकता है। यदि मेरे पास दो फ़ाइलें खुली हैं, तो मैं पहली फ़ाइल में एक मार्क "a" (`ma`) सेट कर सकता हूँ और दूसरी फ़ाइल में एक और मार्क "a" (`ma`) सेट कर सकता हूँ।

स्थानीय मार्क्स के विपरीत जहाँ आप प्रत्येक बफर में मार्क्स का एक सेट रख सकते हैं, आपको केवल एक सेट वैश्विक मार्क्स का मिलता है। यदि आप `myFile.txt` के अंदर `mA` सेट करते हैं, तो अगली बार जब आप किसी अलग फ़ाइल में `mA` चलाते हैं, तो यह पहले "A" मार्क को ओवरराइट कर देगा। वैश्विक मार्क्स का एक लाभ यह है कि आप किसी भी वैश्विक मार्क पर कूद सकते हैं भले ही आप पूरी तरह से अलग प्रोजेक्ट के अंदर हों। वैश्विक मार्क्स फ़ाइलों के बीच यात्रा कर सकते हैं।

सभी मार्क्स देखने के लिए, `:marks` का उपयोग करें। आप मार्क्स सूची से देख सकते हैं कि `a-zA-Z` के अलावा और भी मार्क्स हैं। उनमें से कुछ हैं:

```shell
''    कूदने से पहले वर्तमान बफर में अंतिम लाइन पर वापस जाएं
``    कूदने से पहले वर्तमान बफर में अंतिम स्थिति पर वापस जाएं
`[    पिछले बदले गए / यांकेड पाठ की शुरुआत पर कूदें
`]    पिछले बदले गए / यांकेड पाठ के अंत पर कूदें
`<    अंतिम दृश्य चयन की शुरुआत पर कूदें
`>    अंतिम दृश्य चयन के अंत पर कूदें
`0    vim से बाहर निकलते समय अंतिम संपादित फ़ाइल पर वापस जाएं
```

उपरोक्त सूची में और भी मार्क्स हैं। मैं उन्हें यहाँ कवर नहीं करूंगा क्योंकि मुझे लगता है कि उनका उपयोग शायद ही कभी होता है, लेकिन यदि आप जिज्ञासु हैं, तो `:h marks` देखें।

## कूदना

Vim में, आप कुछ गति के साथ एक अलग फ़ाइल या फ़ाइल के एक अलग भाग पर "कूद" सकते हैं। हालांकि, सभी गति को कूद के रूप में नहीं गिना जाता है। `j` के साथ नीचे जाना कूद के रूप में नहीं गिना जाता है। `10G` के साथ लाइन 10 पर जाना कूद के रूप में गिना जाता है।

यहाँ वे कमांड हैं जिन्हें Vim "कूद" कमांड के रूप में मानता है:

```shell
'       चिह्नित लाइन पर जाएं
`       चिह्नित स्थिति पर जाएं
G       लाइन पर जाएं
/       आगे खोजें
?       पीछे खोजें
n       अंतिम खोज को दोहराएं, वही दिशा
N       अंतिम खोज को दोहराएं, विपरीत दिशा
%       मिलान खोजें
(       अंतिम वाक्य पर जाएं
)       अगले वाक्य पर जाएं
{       अंतिम पैराग्राफ पर जाएं
}       अगले पैराग्राफ पर जाएं
L       प्रदर्शित विंडो की अंतिम लाइन पर जाएं
M       प्रदर्शित विंडो की मध्य लाइन पर जाएं
H       प्रदर्शित विंडो की शीर्ष लाइन पर जाएं
[[      पिछले अनुभाग पर जाएं
]]      अगले अनुभाग पर जाएं
:s      प्रतिस्थापित करें
:tag    टैग परिभाषा पर कूदें
```

मैं इस सूची को याद करने की सिफारिश नहीं करता। एक अच्छा नियम यह है कि, कोई भी गति जो एक शब्द और वर्तमान लाइन नेविगेशन से आगे बढ़ती है, शायद एक कूद है। Vim ट्रैक रखता है कि आप कहाँ गए हैं जब आप चारों ओर चलते हैं और आप इस सूची को `:jumps` के अंदर देख सकते हैं।

अधिक जानकारी के लिए, `:h jump-motions` देखें।

कूद क्यों उपयोगी हैं? क्योंकि आप कूद सूची के साथ `Ctrl-O` का उपयोग करके कूद सूची में ऊपर जा सकते हैं और `Ctrl-I` का उपयोग करके कूद सूची में नीचे जा सकते हैं। `hjkl` "कूद" कमांड नहीं हैं, लेकिन आप गति से पहले वर्तमान स्थान को कूद सूची में मैन्युअल रूप से जोड़ सकते हैं `m'` के साथ। उदाहरण के लिए, `m'5j` वर्तमान स्थान को कूद सूची में जोड़ता है और 5 लाइनों नीचे जाता है, और आप `Ctrl-O` के साथ वापस आ सकते हैं। आप विभिन्न फ़ाइलों के बीच कूद सकते हैं, जिसके बारे में मैं अगले भाग में अधिक चर्चा करूंगा।

## स्मार्ट तरीके से नेविगेशन सीखें

यदि आप Vim में नए हैं, तो यह बहुत कुछ सीखने के लिए है। मैं नहीं चाहता कि कोई भी तुरंत सब कुछ याद रखे। आपको बिना सोचे-समझे उन्हें निष्पादित करने में समय लगेगा।

मुझे लगता है कि शुरुआत करने का सबसे अच्छा तरीका कुछ आवश्यक गति को याद करना है। मैं इन 10 गति से शुरू करने की सिफारिश करता हूँ: `h, j, k, l, w, b, G, /, ?, n`। उन्हें पर्याप्त बार दोहराएं जब तक आप उन्हें बिना सोचे-समझे उपयोग नहीं कर सकते।

आपकी नेविगेशन कौशल में सुधार के लिए, यहाँ मेरी सुझाव हैं:
1. दोहराए गए कार्यों पर ध्यान दें। यदि आप खुद को बार-बार `l` करते हुए पाते हैं, तो एक गति देखें जो आपको तेजी से आगे ले जाएगी। आप पाएंगे कि आप `w` का उपयोग कर सकते हैं। यदि आप खुद को बार-बार `w` करते हुए पाते हैं, तो देखें कि क्या कोई गति है जो आपको वर्तमान लाइन के पार जल्दी ले जाएगी। आप पाएंगे कि आप `f` का उपयोग कर सकते हैं। यदि आप अपनी आवश्यकता को संक्षेप में वर्णन कर सकते हैं, तो संभावना है कि Vim का एक तरीका है।
2. जब भी आप एक नई चाल सीखें, कुछ समय बिताएं जब तक आप इसे बिना सोचे नहीं कर सकते।

अंत में, यह समझें कि आपको उत्पादक होने के लिए हर एक Vim कमांड को जानने की आवश्यकता नहीं है। अधिकांश Vim उपयोगकर्ता ऐसा नहीं करते। मैं भी नहीं करता। उन कमांड को सीखें जो आपको उस क्षण में अपना कार्य पूरा करने में मदद करें।

अपना समय लें। नेविगेशन कौशल Vim में एक बहुत महत्वपूर्ण कौशल है। हर दिन एक छोटी चीज़ सीखें और उसे अच्छी तरह से सीखें।