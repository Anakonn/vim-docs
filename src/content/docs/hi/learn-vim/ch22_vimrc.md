---
description: इस दस्तावेज़ में, आप Vim के उपयोग को व्यवस्थित करने और vimrc को कॉन्फ़िगर
  करने के तरीके के बारे में जानेंगे।
title: Ch22. Vimrc
---

पिछले अध्यायों में, आपने Vim का उपयोग करना सीखा। इस अध्याय में, आप vimrc को व्यवस्थित और कॉन्फ़िगर करना सीखेंगे।

## Vim vimrc को कैसे खोजता है

vimrc के लिए पारंपरिक ज्ञान यह है कि होम डायरेक्टरी में एक `.vimrc` डॉटफाइल जोड़ी जाए `~/.vimrc` (यह आपके OS के आधार पर भिन्न हो सकता है)।

पर्दे के पीछे, Vim एक vimrc फ़ाइल के लिए कई स्थानों पर देखता है। यहाँ वे स्थान हैं जहाँ Vim जाँच करता है:
- `$VIMINIT`
- `$HOME/.vimrc`
- `$HOME/.vim/vimrc`
- `$EXINIT`
- `$HOME/.exrc`
- `$VIMRUNTIME/defaults.vim`

जब आप Vim शुरू करते हैं, तो यह ऊपर दिए गए छह स्थानों की जांच करेगा उस क्रम में एक vimrc फ़ाइल के लिए। पहली मिली vimrc फ़ाइल का उपयोग किया जाएगा और बाकी को नजरअंदाज किया जाएगा।

पहले Vim `$VIMINIT` के लिए देखेगा। यदि वहाँ कुछ नहीं है, तो Vim `$HOME/.vimrc` की जांच करेगा। यदि वहाँ कुछ नहीं है, तो Vim `$HOME/.vim/vimrc` की जांच करेगा। यदि Vim इसे पाता है, तो यह देखना बंद कर देगा और `$HOME/.vim/vimrc` का उपयोग करेगा।

पहला स्थान, `$VIMINIT`, एक पर्यावरण चर है। डिफ़ॉल्ट रूप से यह अपरिभाषित है। यदि आप `~/dotfiles/testvimrc` को अपने `$VIMINIT` मान के रूप में उपयोग करना चाहते हैं, तो आप उस vimrc के पथ को शामिल करते हुए एक पर्यावरण चर बना सकते हैं। जब आप `export VIMINIT='let $MYVIMRC="$HOME/dotfiles/testvimrc" | source $MYVIMRC'` चलाते हैं, तो Vim अब `~/dotfiles/testvimrc` को आपके vimrc फ़ाइल के रूप में उपयोग करेगा।

दूसरा स्थान, `$HOME/.vimrc`, कई Vim उपयोगकर्ताओं के लिए पारंपरिक पथ है। `$HOME` कई मामलों में आपकी होम डायरेक्टरी (`~`) है। यदि आपके पास एक `~/.vimrc` फ़ाइल है, तो Vim इसे आपके vimrc फ़ाइल के रूप में उपयोग करेगा।

तीसरा, `$HOME/.vim/vimrc`, `~/.vim` डायरेक्टरी के अंदर स्थित है। आपके पास पहले से ही अपने प्लगइन्स, कस्टम स्क्रिप्ट, या व्यू फ़ाइलों के लिए `~/.vim` डायरेक्टरी हो सकती है। ध्यान दें कि vimrc फ़ाइल के नाम में कोई डॉट नहीं है (`$HOME/.vim/.vimrc` काम नहीं करेगा, लेकिन `$HOME/.vim/vimrc` करेगा)।

चौथा, `$EXINIT` `$VIMINIT` के समान काम करता है।

पाँचवाँ, `$HOME/.exrc` `$HOME/.vimrc` के समान काम करता है।

छठा, `$VIMRUNTIME/defaults.vim` वह डिफ़ॉल्ट vimrc है जो आपके Vim निर्माण के साथ आता है। मेरे मामले में, मैंने Homebrew का उपयोग करके Vim 8.2 स्थापित किया है, इसलिए मेरा पथ है (`/usr/local/share/vim/vim82`)। यदि Vim पिछले छह vimrc फ़ाइलों में से कोई नहीं पाता है, तो यह इस फ़ाइल का उपयोग करेगा।

इस अध्याय के शेष भाग के लिए, मैं मान रहा हूँ कि vimrc `~/.vimrc` पथ का उपयोग करता है।

## मुझे अपने Vimrc में क्या डालना चाहिए?

जब मैंने शुरुआत की थी, तो मैंने एक सवाल पूछा था, "मुझे अपने vimrc में क्या डालना चाहिए?"

उत्तर है, "जो चाहें"। दूसरों के vimrc को कॉपी-पेस्ट करने का प्रलोभन वास्तविक है, लेकिन आपको इसका विरोध करना चाहिए। यदि आप किसी और के vimrc का उपयोग करने पर जोर देते हैं, तो सुनिश्चित करें कि आप जानते हैं कि यह क्या करता है, क्यों और कैसे वह इसका उपयोग करता है, और सबसे महत्वपूर्ण, क्या यह आपके लिए प्रासंगिक है। सिर्फ इसलिए कि कोई इसका उपयोग करता है, इसका मतलब यह नहीं है कि आप भी इसका उपयोग करेंगे।

## बुनियादी Vimrc सामग्री

संक्षेप में, एक vimrc एक संग्रह है:
- प्लगइन्स
- सेटिंग्स
- कस्टम फ़ंक्शन
- कस्टम कमांड
- मैपिंग्स

अन्य चीजें हैं जो ऊपर नहीं बताई गई हैं, लेकिन सामान्यतः, यह अधिकांश उपयोग के मामलों को कवर करता है।

### प्लगइन्स

पिछले अध्यायों में, मैंने विभिन्न प्लगइन्स का उल्लेख किया है, जैसे [fzf.vim](https://github.com/junegunn/fzf.vim), [vim-mundo](https://github.com/simnalamburt/vim-mundo), और [vim-fugitive](https://github.com/tpope/vim-fugitive)।

दस साल पहले, प्लगइन्स का प्रबंधन एक बुरा सपना था। हालाँकि, आधुनिक प्लगइन प्रबंधकों के उदय के साथ, अब प्लगइन्स को सेकंडों में स्थापित किया जा सकता है। मैं वर्तमान में [vim-plug](https://github.com/junegunn/vim-plug) का उपयोग कर रहा हूँ, इसलिए मैं इस अनुभाग में इसका उपयोग करूंगा। अन्य लोकप्रिय प्लगइन प्रबंधकों के साथ अवधारणा समान होनी चाहिए। मैं आपको विभिन्न लोगों को देखने की सिफारिश करूंगा, जैसे:
- [vundle.vim](https://github.com/VundleVim/Vundle.vim)
- [vim-pathogen](https://github.com/tpope/vim-pathogen)
- [dein.vim](https://github.com/Shougo/dein.vim)

उपरोक्त सूचीबद्ध लोगों से अधिक प्लगइन प्रबंधक हैं, चारों ओर देखने में संकोच न करें। vim-plug स्थापित करने के लिए, यदि आपके पास एक यूनिक्स मशीन है, तो चलाएँ:

```shell
curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```

नए प्लगइन्स जोड़ने के लिए, अपने प्लगइन नामों को (`Plug 'github-username/repository-name'`) `call plug#begin()` और `call plug#end()` लाइनों के बीच डालें। तो यदि आप `emmet-vim` और `nerdtree` स्थापित करना चाहते हैं, तो अपने vimrc में निम्नलिखित स्निपेट डालें:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

परिवर्तनों को सहेजें, इसे स्रोत करें (`:source %`), और उन्हें स्थापित करने के लिए `:PlugInstall` चलाएँ।

भविष्य में यदि आपको अप्रयुक्त प्लगइन्स को हटाने की आवश्यकता हो, तो आपको बस `call` ब्लॉक से प्लगइन नामों को हटाना है, सहेजना और स्रोत करना है, और अपने मशीन से हटाने के लिए `:PlugClean` कमांड चलाना है।

Vim 8 में अपने स्वयं के अंतर्निहित पैकेज प्रबंधक हैं। अधिक जानकारी के लिए आप `:h packages` देख सकते हैं। अगले अध्याय में, मैं आपको इसका उपयोग करना सिखाऊंगा।

### सेटिंग्स

किसी भी vimrc में बहुत सारे `set` विकल्प देखना सामान्य है। यदि आप कमांड-लाइन मोड से सेट कमांड चलाते हैं, तो यह स्थायी नहीं है। जब आप Vim बंद करते हैं तो आप इसे खो देंगे। उदाहरण के लिए, हर बार जब आप Vim चलाते हैं, तो `:set relativenumber number` चलाने के बजाय, आप बस इसे vimrc के अंदर डाल सकते हैं:

```shell
set relativenumber number
```

कुछ सेटिंग्स को आपको एक मान पास करने की आवश्यकता होती है, जैसे `set tabstop=2`। प्रत्येक सेटिंग के लिए हेल्प पृष्ठ देखें ताकि आप जान सकें कि यह किस प्रकार के मान स्वीकार करता है।

आप `set` के बजाय `let` का भी उपयोग कर सकते हैं (सुनिश्चित करें कि इसे `&` के साथ पहले जोड़ा गया है)। `let` के साथ, आप एक अभिव्यक्ति को मान के रूप में उपयोग कर सकते हैं। उदाहरण के लिए, `'dictionary'` विकल्प को केवल तभी एक पथ पर सेट करने के लिए यदि पथ मौजूद है:

```shell
let s:english_dict = "/usr/share/dict/words"

if filereadable(s:english_dict)
  let &dictionary=s:english_dict
endif
```

आप Vimscript असाइनमेंट और कंडीशनल के बारे में बाद के अध्यायों में जानेंगे।

Vim में सभी संभावित विकल्पों की सूची के लिए, `:h E355` देखें।

### कस्टम फ़ंक्शन

Vimrc कस्टम फ़ंक्शंस के लिए एक अच्छा स्थान है। आप बाद के अध्याय में अपने स्वयं के Vimscript फ़ंक्शंस लिखना सीखेंगे।

### कस्टम कमांड

आप `command` के साथ एक कस्टम कमांड-लाइन कमांड बना सकते हैं।

आज की तारीख दिखाने के लिए एक बुनियादी कमांड `GimmeDate` बनाने के लिए:

```shell
:command! GimmeDate echo call("strftime", ["%F"])
```

जब आप `:GimmeDate` चलाते हैं, तो Vim "2021-01-1" जैसी एक तारीख दिखाएगा।

एक इनपुट के साथ एक बुनियादी कमांड बनाने के लिए, आप `<args>` का उपयोग कर सकते हैं। यदि आप `GimmeDate` को एक विशिष्ट समय/तारीख प्रारूप पास करना चाहते हैं:

```shell
:command! GimmeDate echo call("strftime", [<args>])

:GimmeDate "%F"
" 2020-01-01

:GimmeDate "%H:%M"
" 11:30
```

यदि आप तर्कों की संख्या को प्रतिबंधित करना चाहते हैं, तो आप इसे `-nargs` ध्वज पास कर सकते हैं। कोई तर्क न पास करने के लिए `-nargs=0`, एक तर्क पास करने के लिए `-nargs=1`, कम से कम एक तर्क पास करने के लिए `-nargs=+`, किसी भी संख्या के तर्क पास करने के लिए `-nargs=*`, और 0 या एक तर्क पास करने के लिए `-nargs=?` का उपयोग करें। यदि आप nth तर्क पास करना चाहते हैं, तो `-nargs=n` का उपयोग करें (जहाँ `n` कोई भी पूर्णांक है)।

`<args>` के दो रूप हैं: `<f-args>` और `<q-args>`। पहला Vimscript फ़ंक्शंस को तर्क पास करने के लिए उपयोग किया जाता है। दूसरा उपयोगकर्ता इनपुट को स्वचालित रूप से स्ट्रिंग में परिवर्तित करने के लिए उपयोग किया जाता है।

`args` का उपयोग करते हुए:

```shell
:command! -nargs=1 Hello echo "Hello " . <args>
:Hello "Iggy"
" returns 'Hello Iggy'

:Hello Iggy
" Undefined variable error
```

`q-args` का उपयोग करते हुए:

```shell
:command! -nargs=1 Hello echo "Hello " . <q-args>
:Hello Iggy
" returns 'Hello Iggy'
```

`f-args` का उपयोग करते हुए:

```shell
:function! PrintHello(person1, person2)
:  echo "Hello " . a:person1 . " and " . a:person2
:endfunction

:command! -nargs=* Hello call PrintHello(<f-args>)

:Hello Iggy1 Iggy2
" returns "Hello Iggy1 and Iggy2"
```

उपरोक्त फ़ंक्शंस तब बहुत अधिक समझ में आएंगे जब आप Vimscript फ़ंक्शंस अध्याय में पहुँचेंगे।

कमांड और args के बारे में अधिक जानने के लिए, `:h command` और `:args` देखें।
### मानचित्र

यदि आप बार-बार एक ही जटिल कार्य कर रहे हैं, तो यह एक अच्छा संकेत है कि आपको उस कार्य के लिए एक मैपिंग बनानी चाहिए।

उदाहरण के लिए, मेरे vimrc में ये दो मैपिंग हैं:

```shell
nnoremap <silent> <C-f> :GFiles<CR>

nnoremap <Leader>tn :call ToggleNumber()<CR>
```

पहली में, मैंने `Ctrl-F` को [fzf.vim](https://github.com/junegunn/fzf.vim) प्लगइन के `:Gfiles` कमांड (Git फ़ाइलों के लिए जल्दी से खोजें) से मैप किया है। दूसरी में, मैंने `<Leader>tn` को एक कस्टम फ़ंक्शन `ToggleNumber` को कॉल करने के लिए मैप किया है (यह `norelativenumber` और `relativenumber` विकल्पों को टॉगल करता है)। `Ctrl-F` मैपिंग Vim के मूल पृष्ठ स्क्रॉल को ओवरराइट करती है। आपकी मैपिंग ओवरराइट करेगी यदि वे टकराती हैं। चूंकि मैंने लगभग कभी उस फ़ीचर का उपयोग नहीं किया, मैंने तय किया कि इसे ओवरराइट करना सुरक्षित है।

वैसे, `<Leader>tn` में यह "लीडर" कुंजी क्या है?

Vim में मैपिंग के लिए एक लीडर कुंजी है। उदाहरण के लिए, मैंने `<Leader>tn` को `ToggleNumber()` फ़ंक्शन चलाने के लिए मैप किया। बिना लीडर कुंजी के, मैं `tn` का उपयोग कर रहा होता, लेकिन Vim के पास पहले से ही `t` है (जो "till" खोज नेविगेशन है)। लीडर कुंजी के साथ, मैं अब लीडर के रूप में असाइन की गई कुंजी दबा सकता हूं, फिर `tn` बिना मौजूदा कमांड में हस्तक्षेप किए। लीडर कुंजी एक कुंजी है जिसे आप अपनी मैपिंग कॉम्बो शुरू करने के लिए सेटअप कर सकते हैं। डिफ़ॉल्ट रूप से Vim बैकस्लैश को लीडर कुंजी के रूप में उपयोग करता है (इसलिए `<Leader>tn` "बैकस्लैश-t-n" बन जाता है)।

मैं व्यक्तिगत रूप से बैकस्लैश डिफ़ॉल्ट के बजाय `<Space>` को लीडर कुंजी के रूप में उपयोग करना पसंद करता हूं। अपनी लीडर कुंजी बदलने के लिए, इसे अपने vimrc में जोड़ें:

```shell
let mapleader = "\<space>"
```

उपरोक्त में उपयोग की गई `nnoremap` कमांड को तीन भागों में विभाजित किया जा सकता है:
- `n` सामान्य मोड का प्रतिनिधित्व करता है।
- `nore` गैर-आवर्ती का अर्थ है।
- `map` मैप कमांड है।

न्यूनतम, आप `nnoremap` के बजाय `nmap` का उपयोग कर सकते थे (`nmap <silent> <C-f> :Gfiles<CR>`)। हालाँकि, संभावित अनंत लूप से बचने के लिए गैर-आवर्ती रूप का उपयोग करना एक अच्छा अभ्यास है।

यदि आप गैर-आवर्ती रूप से मैप नहीं करते हैं तो क्या हो सकता है। मान लीजिए कि आप `B` के लिए एक मैपिंग जोड़ना चाहते हैं ताकि लाइन के अंत में एक सेमी-कोलन जोड़ें, फिर एक WORD पीछे जाएं (याद रखें कि `B` n Vim में एक सामान्य-मोड नेविगेशन कुंजी है जो एक WORD पीछे जाती है)।

```shell
nmap B A;<esc>B
```

जब आप `B` दबाते हैं... ओह नहीं! Vim अनियंत्रित रूप से `;` जोड़ता है (इसे `Ctrl-C` से रोकें)। ऐसा क्यों हुआ? क्योंकि मैपिंग `A;<esc>B` में, `B` Vim के मूल `B` फ़ंक्शन (एक WORD पीछे जाना) को संदर्भित नहीं करता है, बल्कि यह मैप की गई फ़ंक्शन को संदर्भित करता है। आपके पास वास्तव में यह है:

```shell
A;<esc>A;<esc>A;<esc>A;esc>...
```

इस समस्या को हल करने के लिए, आपको एक गैर-आवर्ती मैप जोड़ने की आवश्यकता है:

```shell
nnoremap B A;<esc>B
```

अब फिर से `B` कॉल करने का प्रयास करें। इस बार यह सफलतापूर्वक लाइन के अंत में `;` जोड़ता है और एक WORD पीछे जाता है। इस मैपिंग में `B` Vim की मूल `B` कार्यक्षमता का प्रतिनिधित्व करता है।

Vim के विभिन्न मोड के लिए विभिन्न मैप होते हैं। यदि आप इनसर्ट मोड के लिए एक मैप बनाना चाहते हैं ताकि जब आप `jk` दबाएं तो इनसर्ट मोड से बाहर निकल जाएं:

```shell
inoremap jk <esc>
```

अन्य मैप मोड हैं: `map` (सामान्य, दृश्य, चयन, और ऑपरेटर-लंबित), `vmap` (दृश्य और चयन), `smap` (चयन), `xmap` (दृश्य), `omap` (ऑपरेटर-लंबित), `map!` (इनसर्ट और कमांड-लाइन), `lmap` (इनसर्ट, कमांड-लाइन, लैंग-आर्ग), `cmap` (कमांड-लाइन), और `tmap` (टर्मिनल-कार्य)। मैं उन्हें विस्तार से नहीं कवर करूंगा। अधिक जानने के लिए, `:h map.txt` देखें।

एक ऐसा मैप बनाएं जो सबसे सहज, सुसंगत, और याद रखने में आसान हो।

## Vimrc का आयोजन

समय के साथ, आपका vimrc बड़ा हो जाएगा और जटिल हो जाएगा। आपके vimrc को साफ-सुथरा रखने के दो तरीके हैं:
- अपने vimrc को कई फ़ाइलों में विभाजित करें।
- अपने vimrc फ़ाइल को फोल्ड करें।

### अपने Vimrc को विभाजित करना

आप Vim के `source` कमांड का उपयोग करके अपने vimrc को कई फ़ाइलों में विभाजित कर सकते हैं। यह कमांड दिए गए फ़ाइल तर्क से कमांड-लाइन कमांड पढ़ता है।

आइए `~/.vim` निर्देशिका के अंदर एक फ़ाइल बनाते हैं और इसे `/settings` नाम देते हैं (`~/.vim/settings`)। नाम स्वयं मनमाना है और आप इसे जो चाहें नाम दे सकते हैं।

आप इसे चार घटकों में विभाजित करने जा रहे हैं:
- तृतीय-पक्ष प्लगइन्स (`~/.vim/settings/plugins.vim`)।
- सामान्य सेटिंग्स (`~/.vim/settings/configs.vim`)।
- कस्टम फ़ंक्शन (`~/.vim/settings/functions.vim`)।
- कुंजी मैपिंग (`~/.vim/settings/mappings.vim`)।

`~/.vimrc` के अंदर:

```shell
source $HOME/.vim/settings/plugins.vim
source $HOME/.vim/settings/configs.vim
source $HOME/.vim/settings/functions.vim
source $HOME/.vim/settings/mappings.vim
```

आप इन फ़ाइलों को पथ के नीचे अपने कर्सर को रखकर और `gf` दबाकर संपादित कर सकते हैं।

`~/.vim/settings/plugins.vim` के अंदर:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

`~/.vim/settings/configs.vim` के अंदर:

```shell
set nocompatible
set relativenumber
set number
```

`~/.vim/settings/functions.vim` के अंदर:

```shell
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
```

`~/.vim/settings/mappings.vim` के अंदर:

```shell
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
```

आपका vimrc सामान्य रूप से काम करना चाहिए, लेकिन अब यह केवल चार पंक्तियों लंबा है!

इस सेटअप के साथ, आप आसानी से जान सकते हैं कि कहाँ जाना है। यदि आपको अधिक मैपिंग जोड़ने की आवश्यकता है, तो उन्हें `/mappings.vim` फ़ाइल में जोड़ें। भविष्य में, जैसे-जैसे आपका vimrc बढ़ता है, आप हमेशा अधिक निर्देशिकाएँ जोड़ सकते हैं। उदाहरण के लिए, यदि आपको अपने रंग योजनाओं के लिए एक सेटिंग बनाने की आवश्यकता है, तो आप `~/.vim/settings/themes.vim` जोड़ सकते हैं।

### एक Vimrc फ़ाइल रखना

यदि आप इसे पोर्टेबल रखने के लिए एक vimrc फ़ाइल रखना पसंद करते हैं, तो आप इसे व्यवस्थित रखने के लिए मार्कर फोल्ड का उपयोग कर सकते हैं। अपने vimrc के शीर्ष पर यह जोड़ें:

```shell
" सेटअप फोल्ड {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}
```

Vim यह पहचान सकता है कि वर्तमान बफर का किस प्रकार का फ़ाइल प्रकार है (`:set filetype?`)। यदि यह एक `vim` फ़ाइल प्रकार है, तो आप मार्कर फोल्ड विधि का उपयोग कर सकते हैं। याद रखें कि एक मार्कर फोल्ड `{{{` और `}}}` का उपयोग करता है ताकि प्रारंभ और समाप्ति फोल्ड को इंगित किया जा सके।

अपने vimrc के बाकी हिस्सों में `{{{` और `}}}` फोल्ड जोड़ें (उन्हें `"` के साथ टिप्पणी करना न भूलें):

```shell
" सेटअप फोल्ड {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

" प्लगइन्स {{{
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
" }}}

" कॉन्फ़िग्स {{{
set nocompatible
set relativenumber
set number
" }}}

" फ़ंक्शंस {{{
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
" }}}

" मैपिंग्स {{{
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
" }}}
```

आपका vimrc इस तरह दिखना चाहिए:

```shell
+-- 6 पंक्तियाँ: सेटअप फोल्ड -----

+-- 6 पंक्तियाँ: प्लगइन्स ---------

+-- 5 पंक्तियाँ: कॉन्फ़िग्स ---------

+-- 9 पंक्तियाँ: फ़ंक्शंस -------

+-- 5 पंक्तियाँ: मैपिंग्स --------
```

## Vim को Vimrc और प्लगइन्स के बिना चलाना

यदि आपको Vim को दोनों vimrc और प्लगइन्स के बिना चलाने की आवश्यकता है, तो चलाएँ:

```shell
vim -u NONE
```

यदि आपको vimrc के बिना लेकिन प्लगइन्स के साथ Vim लॉन्च करने की आवश्यकता है, तो चलाएँ:

```shell
vim -u NORC
```

यदि आपको vimrc के साथ लेकिन प्लगइन्स के बिना Vim चलाने की आवश्यकता है, तो चलाएँ:

```shell
vim --noplugin
```

यदि आपको एक *अलग* vimrc के साथ Vim चलाने की आवश्यकता है, जैसे `~/.vimrc-backup`, तो चलाएँ:

```shell
vim -u ~/.vimrc-backup
```

यदि आपको केवल `defaults.vim` के साथ और बिना प्लगइन्स के Vim चलाने की आवश्यकता है, जो टूटे हुए vimrc को ठीक करने में सहायक है, तो चलाएँ:

```shell
vim --clean
```

## स्मार्ट तरीके से Vimrc को कॉन्फ़िगर करें

Vimrc Vim कस्टमाइजेशन का एक महत्वपूर्ण घटक है। अपने vimrc का निर्माण शुरू करने का एक अच्छा तरीका है अन्य लोगों के vimrc को पढ़ना और धीरे-धीरे इसे समय के साथ बनाना। सबसे अच्छा vimrc वह नहीं है जो डेवलपर X उपयोग करता है, बल्कि वह है जो ठीक उसी तरह से आपके सोचने के ढांचे और संपादन शैली के अनुसार तैयार किया गया है।