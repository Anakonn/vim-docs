---
description: В этой главе вы узнаете, как компилировать программы из Vim, используя
  команду `:make` и возможности makefile для упрощения процесса компиляции.
title: Ch19. Compile
---

Компиляция — важная тема для многих языков. В этой главе вы узнаете, как компилировать из Vim. Вы также рассмотрите способы использования команды Vim `:make`.

## Компиляция из командной строки

Вы можете использовать оператор bang (`!`) для компиляции. Если вам нужно скомпилировать ваш `.cpp` файл с помощью `g++`, выполните:

```shell
:!g++ hello.cpp -o hello
```

Однако необходимость каждый раз вручную вводить имя файла и имя выходного файла подвержена ошибкам и утомительна. Лучше использовать makefile.

## Команда Make

Vim имеет команду `:make` для выполнения makefile. Когда вы её запускаете, Vim ищет makefile в текущем каталоге для выполнения.

Создайте файл с именем `makefile` в текущем каталоге и добавьте в него следующее:

```shell
all:
	echo "Hello all"
foo:
	echo "Hello foo"
list_pls:
	ls
```

Запустите это из Vim:

```shell
:make
```

Vim выполняет его так же, как если бы вы запускали его из терминала. Команда `:make` принимает параметры так же, как команда make в терминале. Выполните:

```shell
:make foo
" Выводит "Hello foo"

:make list_pls
" Выводит результат команды ls
```

Команда `:make` использует quickfix Vim для хранения любых ошибок, если вы запускаете неправильную команду. Давайте запустим несуществующую цель:

```shell
:make dontexist
```

Вы должны увидеть ошибку при выполнении этой команды. Чтобы просмотреть эту ошибку, выполните команду quickfix `:copen`, чтобы открыть окно quickfix:

```shell
|| make: *** No rule to make target `dontexist'.  Stop.
```

## Компиляция с помощью Make

Давайте используем makefile для компиляции базовой программы `.cpp`. Сначала создадим файл `hello.cpp`:

```shell
#include <iostream>

int main() {
    std::cout << "Hello!\n";
    return 0;
}
```

Обновите ваш makefile для сборки и запуска `.cpp` файла:

```shell
all:
	echo "build, run"
build:
	g++ hello.cpp -o hello
run:
	./hello
```

Теперь выполните:

```shell
:make build
```

Команда `g++` компилирует `./hello.cpp` и создает `./hello`. Затем выполните:

```shell
:make run
```

Вы должны увидеть `"Hello!"`, напечатанное в терминале.

## Разные программы Make

Когда вы запускаете `:make`, Vim фактически выполняет любую команду, которая установлена в параметре `makeprg`. Если вы выполните `:set makeprg?`, вы увидите:

```shell
makeprg=make
```

Команда по умолчанию `:make` — это внешняя команда `make`. Чтобы изменить команду `:make` на выполнение `g++ {имя-вашего-файла}` каждый раз, когда вы её запускаете, выполните:

```shell
:set makeprg=g++\ %
```

` \` используется для экранирования пробела после `g++`. Символ `%` в Vim представляет текущий файл. Команда `g++\\ %` эквивалентна выполнению `g++ hello.cpp`.

Перейдите в `./hello.cpp`, затем выполните `:make`. Vim компилирует `hello.cpp` и создает `a.out`, потому что вы не указали выходной файл. Давайте изменим это так, чтобы скомпилированный выходной файл назывался так же, как и оригинальный файл, без расширения. Выполните или добавьте это в vimrc:

```shell
set makeprg=g++\ %\ -o\ %<
```

Разбор:
- `g++\ %` то же самое, что и выше. Это эквивалентно выполнению `g++ <ваш-файл>`.
- `-o` — это опция вывода.
- `%<` в Vim представляет имя текущего файла без расширения (`hello.cpp` становится `hello`).

Когда вы выполняете `:make` из `./hello.cpp`, он компилируется в `./hello`. Чтобы быстро выполнить `./hello` из `./hello.cpp`, выполните `:!./%<`. Снова, это то же самое, что и выполнение `:!./{имя-текущего-файла-без-расширения}`.

Для получения дополнительной информации посмотрите `:h :compiler` и `:h write-compiler-plugin`.

## Автоматическая компиляция при сохранении

Вы можете упростить жизнь, автоматизировав компиляцию. Напомню, что вы можете использовать `autocmd` Vim для запуска автоматических действий на основе определенных событий. Чтобы автоматически компилировать `.cpp` файлы при каждом сохранении, добавьте это в ваш vimrc:

```shell
autocmd BufWritePost *.cpp make
```

Каждый раз, когда вы сохраняете файл `.cpp`, Vim выполняет команду `make`.

## Переключение компилятора

Vim имеет команду `:compiler` для быстрого переключения компиляторов. Ваша сборка Vim, вероятно, поставляется с несколькими предустановленными конфигурациями компиляторов. Чтобы проверить, какие компиляторы у вас есть, выполните:

```shell
:e $VIMRUNTIME/compiler/<Tab>
```

Вы должны увидеть список компиляторов для разных языков программирования.

Чтобы использовать команду `:compiler`, предположим, у вас есть ruby файл `hello.rb`, и внутри него есть:

```shell
puts "Hello ruby"
```

Напомню, что если вы выполните `:make`, Vim выполняет любую команду, назначенную `makeprg` (по умолчанию это `make`). Если вы выполните:

```shell
:compiler ruby
```

Vim выполнит скрипт `$VIMRUNTIME/compiler/ruby.vim` и изменит `makeprg` на использование команды `ruby`. Теперь, если вы выполните `:set makeprg?`, он должен сказать `makeprg=ruby` (это зависит от того, что находится в вашем `$VIMRUNTIME/compiler/ruby.vim` файле или если у вас есть другие пользовательские компиляторы ruby. У вас может быть по-другому). Команда `:compiler {ваш-язык}` позволяет вам быстро переключаться между разными компиляторами. Это полезно, если ваш проект использует несколько языков.

Вам не обязательно использовать `:compiler` и `makeprg` для компиляции программы. Вы можете запустить тестовый скрипт, проверить файл на ошибки, отправить сигнал или сделать что-то еще.

## Создание пользовательского компилятора

Давайте создадим простой компилятор Typescript. Установите Typescript (`npm install -g typescript`) на ваш компьютер. Теперь у вас должна быть команда `tsc`. Если вы еще не работали с typescript, `tsc` компилирует файл Typescript в файл Javascript. Предположим, у вас есть файл `hello.ts`:

```shell
const hello = "hello";
console.log(hello);
```

Если вы выполните `tsc hello.ts`, он скомпилируется в `hello.js`. Однако, если у вас есть следующие выражения внутри `hello.ts`:

```shell
const hello = "hello";
hello = "hello again";
console.log(hello);
```

Это вызовет ошибку, потому что вы не можете изменять переменную `const`. Выполнение `tsc hello.ts` вызовет ошибку:

```shell
hello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.

2 person = "hello again";
  ~~~~~~


Found 1 error.
```

Чтобы создать простой компилятор Typescript, в вашем каталоге `~/.vim/` добавьте каталог `compiler` (`~/.vim/compiler/`), затем создайте файл `typescript.vim` (`~/.vim/compiler/typescript.vim`). Добавьте это внутрь:

```shell
CompilerSet makeprg=tsc
CompilerSet errorformat=%f:\ %m
```

Первая строка устанавливает `makeprg` для выполнения команды `tsc`. Вторая строка устанавливает формат ошибки для отображения файла (`%f`), за которым следует литерал двоеточия (`:`) и экранированный пробел (`\ `), за которым следует сообщение об ошибке (`%m`). Чтобы узнать больше о форматировании ошибок, посмотрите `:h errorformat`.

Вам также следует прочитать некоторые предустановленные компиляторы, чтобы увидеть, как это делают другие. Посмотрите `:e $VIMRUNTIME/compiler/<некоторый-язык>.vim`.

Поскольку некоторые плагины могут мешать работе с файлом Typescript, давайте откроем `hello.ts` без каких-либо плагинов, используя флаг `--noplugin`:

```shell
vim --noplugin hello.ts
```

Проверьте `makeprg`:

```shell
:set makeprg?
```

Он должен сказать, что это программа по умолчанию `make`. Чтобы использовать новый компилятор Typescript, выполните:

```shell
:compiler typescript
```

Когда вы выполните `:set makeprg?`, он теперь должен сказать `tsc`. Давайте проверим это. Выполните:

```shell
:make %
```

Напомню, что `%` означает текущий файл. Наблюдайте, как ваш компилятор Typescript работает как ожидалось! Чтобы увидеть список ошибок, выполните `:copen`.

## Асинхронный компилятор

Иногда компиляция может занять много времени. Вам не хочется смотреть на зависший Vim, ожидая завершения процесса компиляции. Разве не было бы здорово, если бы вы могли компилировать асинхронно, чтобы продолжать использовать Vim во время компиляции?

К счастью, существуют плагины для выполнения асинхронных процессов. Два основных из них:

- [vim-dispatch](https://github.com/tpope/vim-dispatch)
- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)

В оставшейся части этой главы я расскажу о vim-dispatch, но я настоятельно рекомендую вам попробовать все доступные варианты.

*Vim и NeoVim на самом деле поддерживают асинхронные задачи, но это выходит за рамки этой главы. Если вам интересно, посмотрите `:h job-channel-overview.txt`.*

## Плагин: Vim-dispatch

Vim-dispatch имеет несколько команд, но две основные — это команды `:Make` и `:Dispatch`.

### Асинхронная компиляция

Команда `:Make` vim-dispatch аналогична команде `:make` в Vim, но выполняется асинхронно. Если вы находитесь в проекте Javascript и вам нужно выполнить `npm t`, вы можете попытаться установить ваш makeprg как:

```shell
:set makeprg=npm\\ t
```

Если вы выполните:

```shell
:make
```

Vim выполнит `npm t`, но вы будете смотреть на зависший экран, пока ваши тесты JavaScript выполняются. С помощью vim-dispatch вы можете просто выполнить:

```shell
:Make
```

Vim выполнит `npm t` асинхронно. Таким образом, пока `npm t` выполняется в фоновом процессе, вы можете продолжать делать то, что делали. Здорово!

### Асинхронный Dispatch

Команда `:Dispatch` похожа на `:compiler` и команду `:!`. Она может выполнять любую внешнюю команду асинхронно в Vim.

Предположим, вы находитесь внутри ruby spec файла и вам нужно выполнить тест. Выполните:

```shell
:Dispatch bundle exec rspec %
```

Vim асинхронно выполнит команду `rspec` для текущего файла (`%`).

### Автоматизация Dispatch

Vim-dispatch имеет переменную буфера `b:dispatch`, которую вы можете настроить для автоматической оценки конкретной команды. Вы можете использовать её с `autocmd`. Если вы добавите это в ваш vimrc:

```shell
autocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'
```

Теперь каждый раз, когда вы входите в файл (`BufEnter`), который заканчивается на `_spec.rb`, выполнение `:Dispatch` автоматически выполняет `bundle exec rspec {ваш-текущий-ruby-spec-файл}`.

## Учитесь компилировать умно

В этой главе вы узнали, что можете использовать команды `make` и `compiler` для выполнения *любого* процесса из Vim асинхронно, чтобы дополнить ваш рабочий процесс программирования. Возможность Vim расширять себя с помощью других программ делает его мощным.