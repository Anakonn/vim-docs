---
description: В этом документе вы узнаете основные движения в Vim, чтобы быстро и эффективно
  перемещаться по файлам, используя клавиатуру вместо мыши.
title: Ch05. Moving in a File
---

В начале, перемещение с помощью клавиатуры кажется медленным и неловким, но не сдавайтесь! Как только вы к этому привыкнете, вы сможете перемещаться по файлу быстрее, чем с помощью мыши.

В этой главе вы узнаете основные движения и как использовать их эффективно. Имейте в виду, что это **не** все движения, которые есть в Vim. Цель здесь — представить полезные движения, чтобы быстро стать продуктивным. Если вам нужно узнать больше, посмотрите `:h motion.txt`.

## Навигация по символам

Самая базовая единица движения — это перемещение на один символ влево, вниз, вверх и вправо.

```shell
h   Влево
j   Вниз
k   Вверх
l   Вправо
gj  Вниз в строке с мягким переносом
gk  Вверх в строке с мягким переносом
```

Вы также можете перемещаться с помощью стрелок. Если вы только начинаете, не стесняйтесь использовать любой метод, который вам удобен.

Я предпочитаю `hjkl`, потому что моя правая рука может оставаться на домашнем ряду. Это дает мне более короткий доступ к окружающим клавишам. Чтобы привыкнуть к `hjkl`, я на самом деле отключил кнопки стрелок, когда начинал, добавив это в `~/.vimrc`:

```shell
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

Существуют также плагины, которые помогают избавиться от этой плохой привычки. Один из них — [vim-hardtime](https://github.com/takac/vim-hardtime). К моему удивлению, мне потребовалось менее недели, чтобы привыкнуть к `hjkl`.

Если вы задаетесь вопросом, почему Vim использует `hjkl` для перемещения, это связано с терминалом Lear-Siegler ADM-3A, в котором Билл Джой написал Vi, не имевшим стрелок и использовавшим `hjkl` как влево/вниз/вверх/вправо.*

## Относительная нумерация

Я считаю полезным установить `number` и `relativenumber`. Вы можете сделать это, добавив следующее в `.vimrc`:

```shell
set relativenumber number
```

Это отображает мой текущий номер строки и относительные номера строк.

Легко понять, почему наличие номера в левом столбце полезно, но некоторые из вас могут спросить, как наличие относительных номеров в левом столбце может быть полезным. Наличие относительного номера позволяет мне быстро увидеть, на сколько строк мой курсор удален от целевого текста. С этим я могу легко заметить, что мой целевой текст находится на 12 строк ниже, поэтому я могу сделать `d12j`, чтобы удалить их. В противном случае, если я на строке 69, а мой целевой текст на строке 81, мне придется делать умственные вычисления (81 - 69 = 12). Делать математику во время редактирования требует слишком много умственных ресурсов. Чем меньше мне нужно думать о том, куда мне нужно идти, тем лучше.

Это 100% личное предпочтение. Экспериментируйте с `relativenumber` / `norelativenumber`, `number` / `nonumber` и используйте то, что вам кажется наиболее полезным!

## Считайте свои движения

Давайте поговорим о аргументе "счет". Движения Vim принимают предшествующий числовой аргумент. Я упоминал выше, что вы можете опуститься на 12 строк с помощью `12j`. Число 12 в `12j` — это число счета.

Синтаксис для использования счета с вашим движением:

```shell
[count] + motion
```

Вы можете применить это ко всем движениям. Если вы хотите переместиться на 9 символов вправо, вместо того чтобы нажимать `l` 9 раз, вы можете сделать `9l`.

## Навигация по словам

Давайте перейдем к более крупной единице движения: *слову*. Вы можете перемещаться к началу следующего слова (`w`), к концу следующего слова (`e`), к началу предыдущего слова (`b`) и к концу предыдущего слова (`ge`).

Кроме того, есть *WORD*, отличное от слова. Вы можете перемещаться к началу следующего WORD (`W`), к концу следующего WORD (`E`), к началу предыдущего WORD (`B`) и к концу предыдущего WORD (`gE`). Чтобы было легче запомнить, WORD использует те же буквы, что и слово, только в верхнем регистре.

```shell
w     Переместиться вперед к началу следующего слова
W     Переместиться вперед к началу следующего WORD
e     Переместиться вперед на одно слово к концу следующего слова
E     Переместиться вперед на одно слово к концу следующего WORD
b     Переместиться назад к началу предыдущего слова
B     Переместиться назад к началу предыдущего WORD
ge    Переместиться назад к концу предыдущего слова
gE    Переместиться назад к концу предыдущего WORD
```

Итак, в чем сходства и различия между словом и WORD? И слово, и WORD разделяются пробелами. Слово — это последовательность символов, содержащая *только* `a-zA-Z0-9_`. WORD — это последовательность всех символов, кроме пробелов (пробел означает либо пробел, табуляцию, либо конец строки). Чтобы узнать больше, посмотрите `:h word` и `:h WORD`.

Например, предположим, у вас есть:

```shell
const hello = "world";
```

С курсором в начале строки, чтобы добраться до конца строки с помощью `l`, вам потребуется 21 нажатие клавиш. Используя `w`, вам потребуется 6. Используя `W`, вам потребуется всего 4. И слово, и WORD — это хорошие варианты для короткого перемещения.

Тем не менее, вы можете добраться от "c" до ";" за одно нажатие клавиши с помощью навигации по текущей строке.

## Навигация по текущей строке

При редактировании вам часто нужно перемещаться горизонтально в строке. Чтобы прыгнуть к первому символу в текущей строке, используйте `0`. Чтобы перейти к последнему символу в текущей строке, используйте `$`. Кроме того, вы можете использовать `^`, чтобы перейти к первому не пустому символу в текущей строке, и `g_`, чтобы перейти к последнему не пустому символу в текущей строке. Если вы хотите перейти к столбцу `n` в текущей строке, вы можете использовать `n|`.

```shell
0     Перейти к первому символу в текущей строке
^     Перейти к первому непустому символу в текущей строке
g_    Перейти к последнему непустому символу в текущей строке
$     Перейти к последнему символу в текущей строке
n|    Перейти к столбцу n в текущей строке
```

Вы можете выполнять поиск по текущей строке с помощью `f` и `t`. Разница между `f` и `t` заключается в том, что `f` приводит вас к первой букве совпадения, а `t` — к (перед) первой букве совпадения. Так что, если вы хотите искать "h" и приземлиться на "h", используйте `fh`. Если вы хотите найти первую "h" и приземлиться прямо перед совпадением, используйте `th`. Если вы хотите перейти к *следующему* вхождению последнего поиска по текущей строке, используйте `;`. Чтобы перейти к предыдущему вхождению последнего совпадения в текущей строке, используйте `,`.

`F` и `T` — это обратные аналоги `f` и `t`. Чтобы искать "h" назад, выполните `Fh`. Чтобы продолжить поиск "h" в том же направлении, используйте `;`. Обратите внимание, что `;` после `Fh` ищет назад, а `,` после `Fh` ищет вперед.

```shell
f    Искать вперед совпадение в той же строке
F    Искать назад совпадение в той же строке
t    Искать вперед совпадение в той же строке, останавливаясь перед совпадением
T    Искать назад совпадение в той же строке, останавливаясь перед совпадением
;    Повторить последний поиск в той же строке, используя то же направление
,    Повторить последний поиск в той же строке, используя противоположное направление
```

Вернемся к предыдущему примеру:

```shell
const hello = "world";
```

С курсором в начале строки, вы можете перейти к последнему символу в текущей строке (";") за одно нажатие клавиши: `$`. Если вы хотите перейти к "w" в "world", вы можете использовать `fw`. Хороший совет, чтобы добраться куда угодно в строке — это искать наименее распространенные буквы, такие как "j", "x", "z", рядом с вашей целью.

## Навигация по предложениям и абзацам

Следующие две единицы навигации — это предложение и абзац.

Сначала давайте поговорим о том, что такое предложение. Предложение заканчивается либо на `. ! ?`, за которым следует конец строки, пробел или табуляция. Вы можете прыгнуть к следующему предложению с помощью `)` и к предыдущему предложению с помощью `(`.

```shell
(    Перейти к предыдущему предложению
)    Перейти к следующему предложению
```

Давайте посмотрим на несколько примеров. Какие фразы, по вашему мнению, являются предложениями, а какие нет? Попробуйте перемещаться с помощью `(` и `)` в Vim!

```shell
Я — предложение. Я — еще одно предложение, потому что заканчиваюсь точкой. Я все еще предложение, когда заканчиваюсь восклицательным знаком! А что насчет вопросительного знака? Я не совсем предложение из-за дефиса - и ни точка с запятой ;, ни двоеточие :

Сверху меня есть пустая строка.
```

Кстати, если у вас возникают проблемы с тем, что Vim не считает предложение для фраз, разделенных `.` и следующей строкой, возможно, вы находитесь в режиме `'compatible'`. Добавьте `set nocompatible` в vimrc. В Vi предложение — это `.`, за которым следуют **две** пробелы. У вас всегда должно быть установлено `nocompatible`.

Давайте поговорим о том, что такое абзац. Абзац начинается после каждой пустой строки, а также в каждом наборе макроса абзаца, указанного парами символов в опции абзацев.

```shell
{    Перейти к предыдущему абзацу
}    Перейти к следующему абзацу
```

Если вы не уверены, что такое макрос абзаца, не беспокойтесь. Важно то, что абзац начинается и заканчивается после пустой строки. Это должно быть верно большую часть времени.

Давайте посмотрим на этот пример. Попробуйте перемещаться с помощью `}` и `{` (также поиграйте с навигацией по предложениям `( )`, чтобы перемещаться тоже!)

```shell
Привет. Как дела? Я отлично, спасибо!
Vim потрясающий.
Может быть, это не легко учить в начале...- но мы вместе в этом. Удачи!

Привет снова.

Попробуйте перемещаться с помощью ), (, }, и {. Почувствуйте, как они работают.
Вы справитесь.
```

Посмотрите `:h sentence` и `:h paragraph`, чтобы узнать больше.

## Навигация по совпадениям

Программисты пишут и редактируют коды. Код обычно использует круглые скобки, фигурные скобки и квадратные скобки. Вы можете легко потеряться в них. Если вы находитесь внутри одной, вы можете прыгнуть к другой паре (если она существует) с помощью `%`. Вы также можете использовать это, чтобы выяснить, есть ли у вас совпадающие круглые скобки, фигурные скобки и квадратные скобки.

```shell
%    Перейти к другому совпадению, обычно работает для (), [], {}
```

Давайте посмотрим на пример кода на Scheme, потому что он широко использует круглые скобки. Перемещайтесь с помощью `%` внутри разных круглых скобок.

```shell
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

Я лично люблю дополнять `%` плагинами визуальных индикаторов, такими как [vim-rainbow](https://github.com/frazrepo/vim-rainbow). Для получения дополнительной информации посмотрите `:h %`.

## Навигация по номерам строк

Вы можете перейти к номеру строки `n` с помощью `nG`. Например, если вы хотите перейти к строке 7, используйте `7G`. Чтобы перейти к первой строке, используйте либо `1G`, либо `gg`. Чтобы перейти к последней строке, используйте `G`.

Часто вы не знаете точно, какой номер строки у вашей цели, но вы знаете, что он примерно на 70% от всего файла. В этом случае вы можете сделать `70%`. Чтобы перейти на середину файла, вы можете сделать `50%`.

```shell
gg    Перейти к первой строке
G     Перейти к последней строке
nG    Перейти к строке n
n%    Перейти к n% в файле
```

Кстати, если вы хотите увидеть общее количество строк в файле, вы можете использовать `Ctrl-g`.

## Навигация по окнам

Чтобы быстро перейти к верху, середине или низу вашего *окна*, вы можете использовать `H`, `M` и `L`.

Вы также можете передать счет в `H` и `L`. Если вы используете `10H`, вы перейдете на 10 строк ниже верхней части окна. Если вы используете `3L`, вы перейдете на 3 строки выше последней строки окна.

```shell
H     Перейти к верху экрана
M     Перейти к средней части экрана
L     Перейти к низу экрана
nH    Перейти n строк сверху
nL    Перейти n строк снизу
```

## Прокрутка

Чтобы прокрутить, у вас есть 3 скорости: полный экран (`Ctrl-F/Ctrl-B`), половина экрана (`Ctrl-D/Ctrl-U`) и строка (`Ctrl-E/Ctrl-Y`).

```shell
Ctrl-E    Прокрутить вниз на строку
Ctrl-D    Прокрутить вниз на половину экрана
Ctrl-F    Прокрутить вниз на весь экран
Ctrl-Y    Прокрутить вверх на строку
Ctrl-U    Прокрутить вверх на половину экрана
Ctrl-B    Прокрутить вверх на весь экран
```

Вы также можете прокручивать относительно текущей строки (увеличивая видимость экрана):

```shell
zt    Принести текущую строку ближе к верху экрана
zz    Принести текущую строку в середину экрана
zb    Принести текущую строку ближе к низу экрана
```
## Поиск Навигация

Часто вы знаете, что фраза существует внутри файла. Вы можете использовать навигацию по поиску, чтобы очень быстро достичь своей цели. Чтобы искать фразу, вы можете использовать `/` для поиска вперед и `?` для поиска назад. Чтобы повторить последний поиск, вы можете использовать `n`. Чтобы повторить последний поиск в противоположном направлении, вы можете использовать `N`.

```shell
/    Поиск вперед для совпадения
?    Поиск назад для совпадения
n    Повторить последний поиск в том же направлении, что и предыдущий поиск
N    Повторить последний поиск в противоположном направлении от предыдущего поиска
```

Предположим, у вас есть следующий текст:

```shell
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

Если вы ищете "let", выполните `/let`. Чтобы быстро снова найти "let", вы можете просто сделать `n`. Чтобы снова искать "let" в противоположном направлении, выполните `N`. Если вы выполните `?let`, это будет поиск "let" назад. Если вы используете `n`, это теперь будет поиск "let" назад (`N` будет искать "let" вперед).

Вы можете включить подсветку поиска с помощью `set hlsearch`. Теперь, когда вы ищете `/let`, он подсветит *все* совпадающие фразы в файле. Кроме того, вы можете установить инкрементальный поиск с помощью `set incsearch`. Это будет подсвечивать шаблон во время ввода. По умолчанию ваши совпадающие фразы останутся подсвеченными, пока вы не начнете поиск другой фразы. Это может быстро стать раздражающим. Чтобы отключить подсветку, вы можете выполнить `:nohlsearch` или просто `:noh`. Поскольку я часто использую эту функцию без подсветки, я создал сопоставление в vimrc:

```shell
nnoremap <esc><esc> :noh<return><esc>
```

Вы можете быстро искать текст под курсором с помощью `*` для поиска вперед и `#` для поиска назад. Если ваш курсор находится на строке "one", нажатие `*` будет таким же, как если бы вы выполнили `/\<one\>`.

Оба `\<` и `\>` в `/\<one\>` означают поиск целого слова. Это не совпадает с "one", если оно является частью более длинного слова. Это будет совпадать со словом "one", но не с "onetwo". Если ваш курсор находится над "one" и вы хотите искать вперед, чтобы совпадать с целыми или частичными словами, такими как "one" и "onetwo", вам нужно использовать `g*` вместо `*`.

```shell
*     Поиск целого слова под курсором вперед
#     Поиск целого слова под курсором назад
g*    Поиск слова под курсором вперед
g#    Поиск слова под курсором назад
```

## Установка Позиции

Вы можете использовать метки, чтобы сохранить вашу текущую позицию и вернуться к этой позиции позже. Это как закладка для редактирования текста. Вы можете установить метку с помощью `mx`, где `x` может быть любой буквой алфавита `a-zA-Z`. Есть два способа вернуться к метке: точный (строка и столбец) с помощью `` `x `` и по строкам (`'x`).

```shell
ma    Установить позицию с меткой "a"
`a    Перейти к строке и столбцу "a"
'a    Перейти к строке "a"
```

Существует разница между установкой меток с помощью строчных букв (a-z) и заглавных букв (A-Z). Строчные буквы являются локальными метками, а заглавные буквы — глобальными метками (иногда известными как метки файла).

Давайте поговорим о локальных метках. Каждый буфер может иметь свой собственный набор локальных меток. Если у меня открыты два файла, я могу установить метку "a" (`ma`) в первом файле и другую метку "a" (`ma`) во втором файле.

В отличие от локальных меток, где вы можете иметь набор меток в каждом буфере, вы получаете только один набор глобальных меток. Если вы установите `mA` внутри `myFile.txt`, в следующий раз, когда вы выполните `mA` в другом файле, это перезапишет первую метку "A". Одно из преимуществ глобальных меток заключается в том, что вы можете перейти к любой глобальной метке, даже если находитесь в совершенно другом проекте. Глобальные метки могут перемещаться между файлами.

Чтобы просмотреть все метки, используйте `:marks`. Вы можете заметить из списка меток, что есть больше меток, чем `a-zA-Z`. Некоторые из них:

```shell
''    Вернуться к последней строке в текущем буфере перед переходом
``    Вернуться к последней позиции в текущем буфере перед переходом
`[    Перейти к началу ранее измененного / вырезанного текста
`]    Перейти к концу ранее измененного / вырезанного текста
`<    Перейти к началу последнего визуального выделения
`>    Перейти к концу последнего визуального выделения
`0    Вернуться к последнему отредактированному файлу при выходе из vim
```

Существует больше меток, чем перечисленные выше. Я не буду их здесь рассматривать, потому что считаю, что они редко используются, но если вам интересно, посмотрите `:h marks`.

## Прыжок

В Vim вы можете "прыгать" к другому файлу или другой части файла с помощью некоторых движений. Однако не все движения считаются прыжком. Спуск вниз с помощью `j` не считается прыжком. Переход к строке 10 с помощью `10G` считается прыжком.

Вот команды, которые Vim считает командами "прыжка":

```shell
'       Перейти к отмеченной строке
`       Перейти к отмеченной позиции
G       Перейти к строке
/       Поиск вперед
?       Поиск назад
n       Повторить последний поиск, в том же направлении
N       Повторить последний поиск, в противоположном направлении
%       Найти совпадение
(       Перейти к последнему предложению
)       Перейти к следующему предложению
{       Перейти к последнему абзацу
}       Перейти к следующему абзацу
L       Перейти к последней строке отображаемого окна
M       Перейти к средней строке отображаемого окна
H       Перейти к верхней строке отображаемого окна
[[      Перейти к предыдущему разделу
]]      Перейти к следующему разделу
:s      Заменить
:tag    Перейти к определению тега
```

Я не рекомендую запоминать этот список. Хорошее правило — любое движение, которое перемещается дальше, чем слово и навигация по текущей строке, вероятно, является прыжком. Vim отслеживает, где вы были, когда перемещаетесь, и вы можете увидеть этот список внутри `:jumps`.

Для получения дополнительной информации посмотрите `:h jump-motions`.

Почему прыжки полезны? Потому что вы можете перемещаться по списку прыжков с помощью `Ctrl-O`, чтобы подняться по списку прыжков, и `Ctrl-I`, чтобы спуститься по списку прыжков. `hjkl` не являются командами "прыжка", но вы можете вручную добавить текущее местоположение в список прыжков с помощью `m'` перед движением. Например, `m'5j` добавляет текущее местоположение в список прыжков и спускается на 5 строк, и вы можете вернуться с помощью `Ctrl-O`. Вы можете прыгать между разными файлами, о чем я расскажу больше в следующей части.

## Учите Навигацию Умным Способом

Если вы новичок в Vim, это много для изучения. Я не ожидаю, что кто-то запомнит все сразу. Потребуется время, прежде чем вы сможете выполнять их, не задумываясь.

Я думаю, что лучший способ начать — запомнить несколько основных движений. Я рекомендую начать с этих 10 движений: `h, j, k, l, w, b, G, /, ?, n`. Повторяйте их достаточно, пока не сможете использовать их, не задумываясь.

Чтобы улучшить свои навыки навигации, вот мои предложения:
1. Следите за повторяющимися действиями. Если вы обнаружите, что постоянно выполняете `l`, ищите движение, которое позволит вам двигаться вперед быстрее. Вы обнаружите, что можете использовать `w`. Если вы поймаете себя на том, что постоянно делаете `w`, посмотрите, есть ли движение, которое позволит вам быстро перейти через текущую строку. Вы обнаружите, что можете использовать `f`. Если вы можете кратко описать свою потребность, есть большая вероятность, что в Vim есть способ это сделать.
2. Каждый раз, когда вы учите новое движение, потратьте немного времени, пока не сможете делать это, не задумываясь.

Наконец, поймите, что вам не нужно знать каждую команду Vim, чтобы быть продуктивным. Большинство пользователей Vim этого не делают. Я тоже. Учите команды, которые помогут вам выполнить вашу задачу в данный момент.

Не торопитесь. Навигационные навыки — это очень важный навык в Vim. Учите одну небольшую вещь каждый день и учите ее хорошо.