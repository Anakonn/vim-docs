---
description: Этот документ охватывает поиск и замену в Vim, включая использование
  регулярных выражений и настройку чувствительности к регистру для эффективного редактирования.
title: Ch12. Search and Substitute
---

Эта глава охватывает две отдельные, но связанные концепции: поиск и замену. Часто при редактировании вам нужно искать несколько текстов на основе их наименее общего знаменателя. Изучив, как использовать регулярные выражения в поиске и замене вместо буквальных строк, вы сможете быстро находить любой текст.

К слову, в этой главе я буду использовать `/`, когда буду говорить о поиске. Все, что вы можете сделать с `/`, можно также сделать с `?`.

## Умная чувствительность к регистру

Сложно сопоставить регистр искомого термина. Если вы ищете текст "Learn Vim", вы можете легко ошибиться в регистре одной буквы и получить ложный результат поиска. Разве не было бы проще и безопаснее, если бы вы могли сопоставлять любой регистр? Здесь опция `ignorecase` оказывается полезной. Просто добавьте `set ignorecase` в ваш vimrc, и все ваши поисковые термины станут нечувствительными к регистру. Теперь вам не нужно больше делать `/Learn Vim`, `/learn vim` будет работать.

Тем не менее, бывают случаи, когда вам нужно искать фразу с конкретным регистром. Один из способов сделать это — отключить опцию `ignorecase`, выполнив `set noignorecase`, но это много работы, чтобы включать и выключать каждый раз, когда вам нужно искать фразу с учетом регистра.

Чтобы избежать переключения `ignorecase`, Vim имеет опцию `smartcase`, которая ищет нечувствительную к регистру строку, если шаблон поиска *содержит хотя бы один заглавный символ*. Вы можете комбинировать `ignorecase` и `smartcase`, чтобы выполнять нечувствительный к регистру поиск, когда вы вводите все строчные символы, и чувствительный к регистру поиск, когда вы вводите один или несколько заглавных символов.

В вашем vimrc добавьте:

```shell
set ignorecase smartcase
```

Если у вас есть следующие тексты:

```shell
hello
HELLO
Hello
```

- `/hello` соответствует "hello", "HELLO" и "Hello".
- `/HELLO` соответствует только "HELLO".
- `/Hello` соответствует только "Hello".

Есть один недостаток. Что если вам нужно искать только строчную строку? Когда вы делаете `/hello`, Vim теперь выполняет нечувствительный к регистру поиск. Вы можете использовать шаблон `\C` в любом месте вашего поискового термина, чтобы сказать Vim, что последующий поисковый термин будет чувствительным к регистру. Если вы сделаете `/\Chello`, это будет строго соответствовать "hello", а не "HELLO" или "Hello".

## Первый и последний символ в строке

Вы можете использовать `^`, чтобы сопоставить первый символ в строке, и `$`, чтобы сопоставить последний символ в строке.

Если у вас есть этот текст:

```shell
hello hello
```

Вы можете нацелиться на первое "hello" с помощью `/^hello`. Символ, который следует за `^`, должен быть первым символом в строке. Чтобы нацелиться на последнее "hello", выполните `/hello$`. Символ перед `$` должен быть последним символом в строке.

Если у вас есть этот текст:

```shell
hello hello friend
```

Выполнение `/hello$` не даст совпадения, потому что "friend" является последним термином в этой строке, а не "hello".

## Повторение поиска

Вы можете повторить предыдущий поиск с помощью `//`. Если вы только что искали `/hello`, выполнение `//` эквивалентно выполнению `/hello`. Этот ярлык может сэкономить вам несколько нажатий клавиш, особенно если вы только что искали длинную строку. Также помните, что вы можете использовать `n` и `N`, чтобы повторить последний поиск в том же направлении и в противоположном направлении соответственно.

Что если вы хотите быстро вспомнить *n* последних поисковых терминов? Вы можете быстро просмотреть историю поиска, сначала нажав `/`, затем нажимая клавиши стрелок `вверх`/`вниз` (или `Ctrl-N`/`Ctrl-P`), пока не найдете нужный поисковый термин. Чтобы увидеть всю вашу историю поиска, вы можете выполнить `:history /`.

Когда вы достигаете конца файла во время поиска, Vim выдает ошибку: `"Search hit the BOTTOM without match for: {your-search}"`. Иногда это может быть хорошей защитой от чрезмерного поиска, но в других случаях вы хотите снова прокрутить поиск к началу. Вы можете использовать опцию `set wrapscan`, чтобы заставить Vim искать снова в начале файла, когда вы достигаете конца файла. Чтобы отключить эту функцию, выполните `set nowrapscan`.

## Поиск альтернативных слов

Обычно нужно искать несколько слов одновременно. Если вам нужно искать *либо* "hello vim", либо "hola vim", но не "salve vim" или "bonjour vim", вы можете использовать шаблон `|`.

Учитывая этот текст:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

Чтобы сопоставить как "hello", так и "hola", вы можете сделать `/hello\|hola`. Вам нужно экранировать (`\`) оператор или (`|`), иначе Vim будет буквально искать строку "|".

Если вы не хотите каждый раз вводить `\|`, вы можете использовать синтаксис `magic` (`\v`) в начале поиска: `/\vhello|hola`. Я не буду рассматривать `magic` в этом руководстве, но с `\v` вам больше не нужно экранировать специальные символы. Чтобы узнать больше о `\v`, не стесняйтесь ознакомиться с `:h \v`.

## Установка начала и конца совпадения

Возможно, вам нужно искать текст, который является частью составного слова. Если у вас есть следующие тексты:

```shell
11vim22
vim22
11vim
vim
```

Если вам нужно выбрать "vim", но только когда он начинается с "11" и заканчивается на "22", вы можете использовать операторы `\zs` (начало совпадения) и `\ze` (конец совпадения). Выполните:

```shell
/11\zsvim\ze22
```

Vim все еще должен сопоставить весь шаблон "11vim22", но только выделяет шаблон, заключенный между `\zs` и `\ze`. Другой пример:

```shell
foobar
foobaz
```

Если вам нужно сопоставить "foo" в "foobaz", но не в "foobar", выполните:

```shell
/foo\zebaz
```

## Поиск диапазонов символов

Все ваши поисковые термины до этого момента были буквальным поиском слов. В реальной жизни вам может понадобиться использовать общий шаблон, чтобы найти ваш текст. Самый простой шаблон — это диапазон символов, `[ ]`.

Если вам нужно искать любую цифру, вы, вероятно, не хотите каждый раз вводить `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0`. Вместо этого используйте `/[0-9]`, чтобы сопоставить одну цифру. Выражение `0-9` представляет собой диапазон чисел от 0 до 9, который Vim будет пытаться сопоставить, так что если вы ищете цифры от 1 до 5, используйте `/[1-5]`.

Цифры не единственные типы данных, которые Vim может искать. Вы также можете использовать `/[a-z]`, чтобы искать строчные буквы, и `/[A-Z]`, чтобы искать заглавные буквы.

Вы можете комбинировать эти диапазоны вместе. Если вам нужно искать цифры от 0 до 9 и как строчные, так и заглавные буквы от "a" до "f" (например, шестнадцатеричные), вы можете сделать `/[0-9a-fA-F]`.

Чтобы выполнить отрицательный поиск, вы можете добавить `^` внутри квадратных скобок диапазона. Чтобы искать нецифру, выполните `/[^0-9]`. Vim будет сопоставлять любой символ, если он не является цифрой. Имейте в виду, что каретка (`^`) внутри квадратных скобок отличается от каретки в начале строки (например, `/^hello`). Если каретка находится вне пары скобок и является первым символом в поисковом термине, это означает "первый символ в строке". Если каретка находится внутри пары скобок и является первым символом внутри скобок, это означает оператор отрицательного поиска. `/^abc` соответствует первому "abc" в строке, а `/[^abc]` соответствует любому символу, кроме "a", "b" или "c".

## Поиск повторяющихся символов

Если вам нужно искать двойные цифры в этом тексте:

```shell
1aa
11a
111
```

Вы можете использовать `/[0-9][0-9]`, чтобы сопоставить двухзначный символ, но этот метод не масштабируем. Что если вам нужно сопоставить двадцать цифр? Вводить `[0-9]` двадцать раз — это не самое приятное занятие. Вот почему вам нужен аргумент `count`.

Вы можете передать `count` в ваш поиск. Он имеет следующий синтаксис:

```shell
{n,m}
```

Кстати, эти фигурные скобки `count` нужно экранировать, когда вы используете их в Vim. Оператор `count` ставится после одного символа, который вы хотите увеличить.

Вот четыре различные вариации синтаксиса `count`:
- `{n}` — это точное совпадение. `/[0-9]\{2\}` соответствует двум цифрам: "11" и "11" в "111".
- `{n,m}` — это диапазон совпадений. `/[0-9]\{2,3\}` соответствует числам от 2 до 3 цифр: "11" и "111".
- `{,m}` — это совпадение до. `/[0-9]\{,3\}` соответствует числам до 3 цифр: "1", "11" и "111".
- `{n,}` — это совпадение как минимум. `/[0-9]\{2,\}` соответствует числам с 2 или более цифрами: "11" и "111".

Аргументы count `\{0,\}` (ноль или более) и `\{1,\}` (один или более) являются общими шаблонами поиска, и у Vim есть специальные операторы для них: `*` и `+` (при этом `+` нужно экранировать, а `*` работает нормально без экранирования). Если вы выполните `/[0-9]*`, это то же самое, что и `/[0-9]\{0,\}`. Это ищет ноль или более цифр. Это будет соответствовать "", "1", "123". Кстати, это также будет соответствовать нецифрам, таким как "a", потому что в букве "a" технически ноль цифр. Подумайте дважды, прежде чем использовать `*`. Если вы выполните `/[0-9]\+`, это то же самое, что и `/[0-9]\{1,\}`. Это ищет одну или более цифр. Это будет соответствовать "1" и "12".

## Предопределенные диапазоны символов

У Vim есть предопределенные диапазоны для общих символов, таких как цифры и буквы. Я не буду перечислять их все здесь, но вы можете найти полный список в `:h /character-classes`. Вот полезные:

```shell
\d    Цифра [0-9]
\D    Нецифра [^0-9]
\s    Пробельный символ (пробел и табуляция)
\S    Непробельный символ (все, кроме пробела и табуляции)
\w    Символ слова [0-9A-Za-z_]
\l    Строчные буквы [a-z]
\u    Заглавный символ [A-Z]
```

Вы можете использовать их так же, как и диапазоны символов. Чтобы искать любую одну цифру, вместо использования `/[0-9]`, вы можете использовать `/\d` для более краткого синтаксиса.

## Пример поиска: Захват текста между парой одинаковых символов

Если вы хотите искать фразу, окруженную парой двойных кавычек:

```shell
"Vim is awesome!"
```

Выполните это:

```shell
/"[^"]\+"
```

Давайте разберем:
- `"` — это буквальная двойная кавычка. Она соответствует первой двойной кавычке.
- `[^"]` означает любой символ, кроме двойной кавычки. Она соответствует любому алфавитно-цифровому и пробельному символу, если это не двойная кавычка.
- `\+` означает один или более. Поскольку перед ним стоит `[^"]`, Vim ищет один или более символов, которые не являются двойной кавычкой.
- `"` — это буквальная двойная кавычка. Она соответствует закрывающей двойной кавычке.

Когда Vim видит первую `"`, он начинает захват шаблона. В момент, когда он видит вторую двойную кавычку в строке, он сопоставляет второй шаблон `"` и останавливает захват шаблона. Тем временем все символы, не являющиеся двойными кавычками, между ними захватываются шаблоном `[^"]\+`, в данном случае фраза `Vim is awesome!`. Это распространенный шаблон для захвата фразы, окруженной парой одинаковых разделителей.

- Чтобы захватить фразу, окруженную одинарными кавычками, вы можете использовать `/'[^']\+'`.
- Чтобы захватить фразу, окруженную нулями, вы можете использовать `/0[^0]\+0`.

## Пример поиска: Захват номера телефона

Если вы хотите сопоставить номер телефона США, разделенный дефисом (`-`), например `123-456-7890`, вы можете использовать:

```shell
/\d\{3\}-\d\{3\}-\d\{4\}
```

Номер телефона США состоит из набора трехзначного числа, за которым следует еще три цифры, а затем четыре цифры. Давайте разберем:
- `\d\{3\}` соответствует цифре, повторенной ровно три раза
- `-` — это буквальный дефис

Вы можете избежать ввода экранирования с помощью `\v`:

```shell
/\v\d{3}-\d{3}-\d{4}
```

Этот шаблон также полезен для захвата любых повторяющихся цифр, таких как IP-адреса и почтовые индексы.

Это охватывает часть поиска в этой главе. Теперь давайте перейдем к замене.

## Основная замена

Команда замены Vim — это полезная команда для быстрого поиска и замены любого шаблона. Синтаксис замены:

```shell
:s/{старый-шаблон}/{новый-шаблон}/
```

Давайте начнем с базового использования. Если у вас есть этот текст:

```shell
vim is good
```

Давайте заменим "good" на "awesome", потому что Vim великолепен. Выполните `:s/good/awesome/`. Вы должны увидеть:

```shell
vim is awesome
```
## Повторение Последней Замены

Вы можете повторить последнюю команду замены с помощью обычной команды `&` или запустив `:s`. Если вы только что выполнили `:s/good/awesome/`, выполнение `&` или `:s` повторит её.

Также ранее в этой главе я упоминал, что вы можете использовать `//` для повторения предыдущего шаблона поиска. Этот трюк работает с командой замены. Если `/good` было выполнено недавно и вы оставите первый аргумент шаблона замены пустым, как в `:s//awesome/`, это будет работать так же, как выполнение `:s/good/awesome/`.

## Диапазон Замены

Как и многие команды Ex, вы можете передать аргумент диапазона в команду замены. Синтаксис:

```shell
:[range]s/old/new/
```

Если у вас есть следующие выражения:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

Чтобы заменить "let" на "const" в строках с третьей по пятую, вы можете сделать:

```shell
:3,5s/let/const/
```

Вот некоторые вариации диапазона, которые вы можете передать:

- `:,3s/let/const/` - если ничего не указано перед запятой, это представляет текущую строку. Заменить с текущей строки до строки 3.
- `:1,s/let/const/` - если ничего не указано после запятой, это также представляет текущую строку. Заменить с 1-й строки до текущей строки.
- `:3s/let/const/` - если указано только одно значение как диапазон (без запятой), это выполняет замену только в этой строке.

В Vim `%` обычно означает весь файл. Если вы выполните `:%s/let/const/`, это заменит во всех строках. Имейте в виду этот синтаксис диапазона. Многие команды командной строки, которые вы изучите в следующих главах, будут следовать этой форме.

## Сопоставление Шаблонов

Следующие несколько разделов охватят основные регулярные выражения. Сильные знания шаблонов необходимы для освоения команды замены.

Если у вас есть следующие выражения:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

Чтобы добавить пару двойных кавычек вокруг цифр:

```shell
:%s/\d/"\0"/
```

Результат:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

Давайте разберем команду:
- `:%s` нацеливается на весь файл для выполнения замены.
- `\d` - это предопределенный диапазон Vim для цифр (аналогично использованию `[0-9]`).
- `"\0"` здесь двойные кавычки являются буквальными двойными кавычками. `\0` - это специальный символ, представляющий "весь совпадающий шаблон". Совпадающий шаблон здесь - это одноцифровое число, `\d`.

Альтернативно, `&` также представляет весь совпадающий шаблон, как `\0`. `:s/\d/"&"/` также сработает.

Рассмотрим еще один пример. Учитывая эти выражения, вам нужно поменять местами все "let" с именами переменных.

```shell
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

Чтобы это сделать, выполните:

```shell
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

Команда выше содержит слишком много обратных слешей и трудно читается. В этом случае удобнее использовать оператор `\v`:

```shell
:%s/\v(\w+) (\w+)/\2 \1/
```

Результат:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

Отлично! Давайте разберем эту команду:
- `:%s` нацеливается на все строки в файле для выполнения замены.
- `(\w+) (\w+)` - это групповой матч. `\w` - это один из предопределенных диапазонов Vim для символа слова (`[0-9A-Za-z_]`). Скобки `( )` вокруг него захватывают совпадение символа слова в группе. Обратите внимание на пробел между двумя группами. `(\w+) (\w+)` захватывает две группы. Первая группа захватывает "one", а вторая группа захватывает "two".
- `\2 \1` возвращает захваченную группу в обратном порядке. `\2` содержит захваченную строку "let", а `\1` - строку "one". Наличие `\2 \1` возвращает строку "let one".

Помните, что `\0` представляет весь совпадающий шаблон. Вы можете разбить совпадающую строку на меньшие группы с помощью `( )`. Каждая группа представлена как `\1`, `\2`, `\3` и т.д.

Давайте сделаем еще один пример, чтобы закрепить концепцию группового совпадения. Если у вас есть эти числа:

```shell
123
456
789
```

Чтобы изменить порядок, выполните:

```shell
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

Результат:

```shell
321
654
987
```

Каждое `(\d)` соответствует каждой цифре и создает группу. В первой строке первое `(\d)` имеет значение 1, второе `(\d)` имеет значение 2, а третье `(\d)` имеет значение 3. Они хранятся в переменных `\1`, `\2` и `\3`. Во второй половине вашей замены новый шаблон `\3\2\1` приводит к значению "321" в первой строке.

Если бы вы вместо этого выполнили:

```shell
:%s/\v(\d\d)(\d)/\2\1/
```
Вы бы получили другой результат:

```shell
312
645
978
```

Это потому, что теперь у вас только две группы. Первая группа, захваченная `(\d\d)`, хранится в `\1` и имеет значение 12. Вторая группа, захваченная `(\d)`, хранится в `\2` и имеет значение 3. `\2\1` затем возвращает 312.

## Флаги Замены

Если у вас есть предложение:

```shell
chocolate pancake, strawberry pancake, blueberry pancake
```

Чтобы заменить все панкейки на пончики, вы не можете просто выполнить:

```shell
:s/pancake/donut
```

Команда выше заменит только первое совпадение, дав вам:

```shell
chocolate donut, strawberry pancake, blueberry pancake
```

Есть два способа решить эту проблему. Вы можете либо выполнить команду замены еще два раза, либо передать ей глобальный (`g`) флаг, чтобы заменить все совпадения в строке.

Давайте поговорим о глобальном флаге. Выполните:

```shell
:s/pancake/donut/g
```

Vim заменяет все панкейки на пончики одним быстрым командой. Глобальная команда - это один из нескольких флагов, которые принимает команда замены. Вы передаете флаги в конце команды замены. Вот список полезных флагов:

```shell
&    Повторить флаги из предыдущей команды замены.
g    Заменить все совпадения в строке.
c    Запросить подтверждение замены.
e    Предотвратить отображение сообщения об ошибке, когда замена не удалась.
i    Выполнить нечувствительную к регистру замену.
I    Выполнить чувствительную к регистру замену.
```

Есть еще больше флагов, которые я не перечислил выше. Чтобы узнать о всех флагах, посмотрите `:h s_flags`.

Кстати, команды повторной замены (`&` и `:s`) не сохраняют флаги. Выполнение `&` просто повторит `:s/pancake/donut/` без `g`. Чтобы быстро повторить последнюю команду замены со всеми флагами, выполните `:&&`.

## Изменение Разделителя

Если вам нужно заменить URL на длинный путь:

```shell
https://mysite.com/a/b/c/d/e
```

Чтобы заменить его на слово "hello", выполните:

```shell
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

Однако трудно понять, какие косые черты (`/`) являются частью шаблона замены, а какие - разделителями. Вы можете изменить разделитель на любые однобайтовые символы (кроме букв, цифр, `"`, `|` и `\`). Давайте заменим их на `+`. Команда замены выше может быть переписана как:

```shell
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

Теперь легче увидеть, где находятся разделители.

## Специальная Замена

Вы также можете изменить регистр текста, который вы заменяете. Учитывая следующие выражения, ваша задача - сделать заглавными переменные "one", "two", "three" и т.д.

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

Выполните:

```shell
:%s/\v(\w+) (\w+)/\1 \U\2/
```

Вы получите:

```shell
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

Разбор:
- `(\w+) (\w+)` захватывает первые две совпадающие группы, такие как "let" и "one".
- `\1` возвращает значение первой группы, "let".
- `\U\2` делает заглавной (`\U`) вторую группу (`\2`).

Трюк этой команды заключается в выражении `\U\2`. `\U` указывает следующему символу быть заглавным.

Давайте сделаем еще один пример. Предположим, вы пишете руководство по Vim и вам нужно сделать заглавной первую букву каждого слова в строке.

```shell
vim is the greatest text editor in the whole galaxy
```

Вы можете выполнить:

```shell
:s/\<./\U&/g
```

Результат:

```shell
Vim Is The Greatest Text Editor In The Whole Galaxy
```

Вот разбор:
- `:s` заменяет текущую строку.
- `\<.` состоит из двух частей: `\<` для совпадения с началом слова и `.` для совпадения с любым символом. Оператор `\<` заставляет следующий символ быть первым символом слова. Поскольку `.` - следующий символ, он совпадает с первым символом любого слова.
- `\U&` делает заглавным последующий символ, `&`. Напоминаю, что `&` (или `\0`) представляет все совпадение. Оно совпадает с первым символом любого слова.
- `g` - глобальный флаг. Без него эта команда заменит только первое совпадение. Вам нужно заменить каждое совпадение в этой строке.

Чтобы узнать больше о специальных символах замены в замене, таких как `\U`, посмотрите `:h sub-replace-special`.

## Альтернативные Шаблоны

Иногда вам нужно одновременно сопоставить несколько шаблонов. Если у вас есть следующие приветствия:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

Вам нужно заменить слово "vim" на "друг", но только в строках, содержащих слово "hello" или "hola". Напоминаю, что вы можете использовать `|` для нескольких альтернативных шаблонов.

```shell
:%s/\v(hello|hola) vim/\1 friend/g
```

Результат:

```shell
hello friend
hola friend
salve vim
bonjour vim
```

Вот разбор:
- `%s` выполняет команду замены на каждой строке в файле.
- `(hello|hola)` совпадает *либо* с "hello", либо с "hola" и рассматривает это как группу.
- `vim` - это буквальное слово "vim".
- `\1` - это первая группа, которая либо текст "hello", либо "hola".
- `friend` - это буквальное слово "друг".

## Замена Начала и Конца Шаблона

Напоминаю, что вы можете использовать `\zs` и `\ze`, чтобы определить начало и конец совпадения. Эта техника также работает в замене. Если у вас есть:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

Чтобы заменить "cake" в "hotcake" на "dog", чтобы получить "hotdog":

```shell
:%s/hot\zscake/dog/g
```

Результат:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotdog
```
## Жадный и Нежадный

Вы можете заменить n-ное совпадение в строке с помощью этого трюка:

```shell
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

Чтобы заменить третье "Mississippi" на "Arkansas", выполните:

```shell
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

Разбор:
- `:s/` команда замены.
- `\v` это магическое слово, чтобы вам не пришлось экранировать специальные ключевые слова.
- `.` соответствует любому одиночному символу.
- `{-}` выполняет нежадное совпадение 0 или более предыдущего атома.
- `\zsMississippi` делает "Mississippi" началом совпадения.
- `(...){3}` ищет третье совпадение.

Вы видели синтаксис `{3}` ранее в этой главе. В этом случае `{3}` будет соответствовать именно третьему совпадению. Новый трюк здесь — `{-}`. Это нежадное совпадение. Оно находит самое короткое совпадение данного шаблона. В этом случае `(.{-}Mississippi)` соответствует наименьшему количеству "Mississippi", предшествующему любому символу. В отличие от `(.*Mississippi)`, где оно находит самое длинное совпадение данного шаблона.

Если вы используете `(.{-}Mississippi)`, вы получаете пять совпадений: "One Mississippi", "Two Mississippi" и т.д. Если вы используете `(.*Mississippi)`, вы получаете одно совпадение: последнее "Mississippi". `*` — это жадный сопоставитель, а `{-}` — нежадный сопоставитель. Чтобы узнать больше, посмотрите `:h /\{-` и `:h non-greedy`.

Давайте сделаем более простой пример. Если у вас есть строка:

```shell
abc1de1
```

Вы можете сопоставить "abc1de1" (жадно) с:

```shell
/a.*1
```

Вы можете сопоставить "abc1" (нежадно) с:

```shell
/a.\{-}1
```

Так что, если вам нужно сделать заглавными буквами самое длинное совпадение (жадно), выполните:

```shell
:s/a.*1/\U&/g
```

Чтобы получить:

```shell
ABC1DEFG1
```

Если вам нужно сделать заглавными буквами самое короткое совпадение (нежадно), выполните:

```shell
:s/a.\{-}1/\U&/g
```

Чтобы получить:

```shell
ABC1defg1
```

Если вы новичок в концепции жадного и нежадного сопоставления, это может быть трудно понять. Экспериментируйте с различными комбинациями, пока не поймете это.

## Замена в нескольких файлах

Наконец, давайте научимся заменять фразы в нескольких файлах. Для этого раздела предположим, что у вас есть два файла: `food.txt` и `animal.txt`.

Внутри `food.txt`:

```shell
corndog
hotdog
chilidog
```

Внутри `animal.txt`:

```shell
large dog
medium dog
small dog
```

Предположим, ваша структура каталогов выглядит так:

```shell
- food.txt
- animal.txt
```

Сначала захватите оба `food.txt` и `animal.txt` внутри `:args`. Вспомните из предыдущих глав, что `:args` можно использовать для создания списка имен файлов. Есть несколько способов сделать это изнутри Vim, один из них — запустить это изнутри Vim:

```shell
:args *.txt                  захватывает все txt файлы в текущем расположении
```

Чтобы протестировать это, когда вы выполните `:args`, вы должны увидеть:

```shell
[food.txt] animal.txt
```

Теперь, когда все соответствующие файлы сохранены в списке аргументов, вы можете выполнить замену в нескольких файлах с помощью команды `:argdo`. Выполните:

```shell
:argdo %s/dog/chicken/
```

Это выполняет замену во всех файлах внутри списка `:args`. Наконец, сохраните измененные файлы с:

```shell
:argdo update
```

`:args` и `:argdo` — полезные инструменты для применения командных строк к нескольким файлам. Попробуйте это с другими командами!

## Замена в нескольких файлах с помощью макросов

В качестве альтернативы вы также можете выполнить команду замены в нескольких файлах с помощью макросов. Выполните:

```shell
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

Разбор:
- `:args *.txt` добавляет все текстовые файлы в список `:args`.
- `qq` начинает макрос в регистре "q".
- `:%s/dog/chicken/g` заменяет "dog" на "chicken" на всех строках в текущем файле.
- `:wnext` сохраняет файл, затем переходит к следующему файлу в списке `args`.
- `q` останавливает запись макроса.
- `99@q` выполняет макрос девяносто девять раз. Vim остановит выполнение макроса после того, как встретит первую ошибку, так что Vim на самом деле не выполнит макрос девяносто девять раз.

## Умное изучение поиска и замены

Умение хорошо искать — это необходимый навык в редактировании. Освоение поиска позволяет вам использовать гибкость регулярных выражений для поиска любого шаблона в файле. Не спешите учиться этому. Чтобы стать лучше в регулярных выражениях, вам нужно активно использовать регулярные выражения. Я однажды читал книгу о регулярных выражениях, не практикуясь, и забыл почти все, что прочитал позже. Активное программирование — лучший способ освоить любой навык.

Хороший способ улучшить свои навыки сопоставления шаблонов — это каждый раз, когда вам нужно искать шаблон (например, "hello 123"), вместо того чтобы запрашивать буквальный поисковый термин (`/hello 123`), попытаться придумать шаблон для него (что-то вроде `/\v(\l+) (\d+)`). Многие из этих концепций регулярных выражений также применимы в общем программировании, а не только при использовании Vim.

Теперь, когда вы узнали о продвинутом поиске и замене в Vim, давайте изучим одну из самых универсальных команд — глобальную команду.