---
description: В этом документе вы познакомитесь с Vimscript, его примитивными типами
  данных и использованием режима Ex для практики программирования в Vim.
title: Ch25. Vimscript Basic Data Types
---

В следующих нескольких главах вы узнаете о Vimscript, встроенном языке программирования Vim.

При изучении нового языка есть три основных элемента, на которые стоит обратить внимание:
- Примитивы
- Средства комбинации
- Средства абстракции

В этой главе вы узнаете о примитивных типах данных Vim.

## Типы данных

Vim имеет 10 различных типов данных:
- Число
- Вещественное число
- Строка
- Список
- Словарь
- Специальный
- Funcref
- Job
- Channel
- Blob

Я рассмотрю первые шесть типов данных здесь. В главе 27 вы узнаете о Funcref. Для получения дополнительной информации о типах данных Vim, ознакомьтесь с `:h variables`.

## Следуя за режимом Ex

Технически, у Vim нет встроенного REPL, но есть режим, режим Ex, который можно использовать как таковой. Вы можете перейти в режим Ex с помощью `Q` или `gQ`. Режим Ex похож на расширенный режим командной строки (это как непрерывный ввод команд в командной строке). Чтобы выйти из режима Ex, введите `:visual`.

Вы можете использовать как `:echo`, так и `:echom` в этой главе и последующих главах Vimscript, чтобы писать код. Они аналогичны `console.log` в JS или `print` в Python. Команда `:echo` выводит вычисленное выражение, которое вы передаете. Команда `:echom` делает то же самое, но дополнительно сохраняет результат в истории сообщений.

```viml
:echom "hello echo message"
```

Вы можете просмотреть историю сообщений с помощью:

```shell
:messages
```

Чтобы очистить историю сообщений, выполните:

```shell
:messages clear
```

## Число

Vim имеет 4 различных типа чисел: десятичные, шестнадцатеричные, двоичные и восьмеричные. Кстати, когда я говорю о типе данных число, часто это означает тип данных целое число. В этом руководстве я буду использовать термины число и целое число взаимозаменяемо.

### Десятичные

Вы должны быть знакомы с десятичной системой. Vim принимает положительные и отрицательные десятичные числа. 1, -1, 10 и т.д. В программировании на Vimscript вы, вероятно, будете использовать десятичный тип большую часть времени.

### Шестнадцатеричные

Шестнадцатеричные числа начинаются с `0x` или `0X`. Мнемоника: He**x**adecimal.

### Двоичные

Двоичные числа начинаются с `0b` или `0B`. Мнемоника: **B**inary.

### Восьмеричные

Восьмеричные числа начинаются с `0`, `0o` и `0O`. Мнемоника: **O**ctal.

### Печать чисел

Если вы `echo` либо шестнадцатеричное, двоичное, либо восьмеричное число, Vim автоматически преобразует их в десятичные.

```viml
:echo 42
" возвращает 42

:echo 052
" возвращает 42

:echo 0b101010
" возвращает 42

:echo 0x2A
" возвращает 42
```

### Истинные и ложные значения

В Vim значение 0 является ложным, а все ненулевые значения являются истинными.

Следующее не выведет ничего.

```viml
:if 0
:  echo "Нет"
:endif
```

Однако это выведет:

```viml
:if 1
:  echo "Да"
:endif
```

Любые значения, кроме 0, являются истинными, включая отрицательные числа. 100 является истинным. -1 является истинным.

### Арифметика чисел

Числа могут использоваться для выполнения арифметических выражений:

```viml
:echo 3 + 1
" возвращает 4

: echo 5 - 3
" возвращает 2

:echo 2 * 2
" возвращает 4

:echo 4 / 2
" возвращает 2
```

При делении числа с остатком Vim отбрасывает остаток.

```viml
:echo 5 / 2
" возвращает 2 вместо 2.5
```

Чтобы получить более точный результат, вам нужно использовать вещественное число.

## Вещественное число

Вещественные числа — это числа с дробной частью. Существует два способа представления вещественных чисел: десятичная нотация (например, 31.4) и экспонента (3.14e01). Подобно числам, вы можете использовать положительные и отрицательные знаки:

```viml
:echo +123.4
" возвращает 123.4

:echo -1.234e2
" возвращает -123.4

:echo 0.25
" возвращает 0.25

:echo 2.5e-1
" возвращает 0.25
```

Вы должны указать вещественному числу точку и дробные цифры. `25e-2` (без точки) и `1234.` (с точкой, но без дробных цифр) являются недопустимыми вещественными числами.

### Арифметика вещественных чисел

При выполнении арифметического выражения между числом и вещественным числом Vim приводит результат к вещественному числу.

```viml
:echo 5 / 2.0
" возвращает 2.5
```

Арифметика вещественных чисел дает вам еще одно вещественное число.

```shell
:echo 1.0 + 1.0
" возвращает 2.0
```

## Строка

Строки — это символы, окруженные либо двойными кавычками (`""`), либо одинарными кавычками (`''`). "Hello", "123" и '123.4' являются примерами строк.

### Конкатенация строк

Чтобы конкатенировать строку в Vim, используйте оператор `.`.

```viml
:echo "Hello" . " world"
" возвращает "Hello world"
```

### Арифметика строк

Когда вы выполняете арифметические операторы (`+ - * /`) с числом и строкой, Vim приводит строку к числу.

```viml
:echo "12 donuts" + 3
" возвращает 15
```

Когда Vim видит "12 donuts", он извлекает 12 из строки и преобразует его в число 12. Затем выполняется сложение, возвращая 15. Для того чтобы это приведение строки в число сработало, числовой символ должен быть *первым символом* в строке.

Следующее не сработает, потому что 12 не является первым символом в строке:

```viml
:echo "donuts 12" + 3
" возвращает 3
```

Это также не сработает, потому что пустое пространство является первым символом строки:

```viml
:echo " 12 donuts" + 3
" возвращает 3
```

Это приведение работает даже с двумя строками:

```shell
:echo "12 donuts" + "6 pastries"
" возвращает 18
```

Это работает с любым арифметическим оператором, не только `+`:

```viml
:echo "12 donuts" * "5 boxes"
" возвращает 60

:echo "12 donuts" - 5
" возвращает 7

:echo "12 donuts" / "3 people"
" возвращает 4
```

Хороший трюк для принудительного приведения строки к числу — просто добавить 0 или умножить на 1:

```viml
:echo "12" + 0
" возвращает 12

:echo "12" * 1
" возвращает 12
```

Когда арифметика выполняется с вещественным числом в строке, Vim обрабатывает его как целое число, а не как вещественное:

```shell
:echo "12.0 donuts" + 12
" возвращает 24, а не 24.0
```

### Конкатенация числа и строки

Вы можете привести число к строке с помощью оператора точки (`.`):

```viml
:echo 12 . "donuts"
" возвращает "12donuts"
```

Приведение работает только с типом данных число, а не вещественным. Это не сработает:

```shell
:echo 12.0 . "donuts"
" не возвращает "12.0donuts", а вызывает ошибку
```

### Условные операторы строк

Помните, что 0 является ложным, а все ненулевые числа являются истинными. Это также верно при использовании строк в качестве условных операторов.

В следующем операторе if Vim приводит "12donuts" к 12, что является истинным:

```viml
:if "12donuts"
:  echo "Вкусно"
:endif
" возвращает "Вкусно"
```

С другой стороны, это является ложным:

```viml
:if "donuts12"
:  echo "Нет"
:endif
" ничего не возвращает
```

Vim приводит "donuts12" к 0, потому что первый символ не является числом.

### Двойные против одинарных кавычек

Двойные кавычки ведут себя иначе, чем одинарные. Одинарные кавычки отображают символы буквально, в то время как двойные кавычки принимают специальные символы.

Что такое специальные символы? Ознакомьтесь с отображением новой строки и двойных кавычек:

```viml
:echo "hello\nworld"
" возвращает
" hello
" world

:echo "hello \"world\""
" возвращает "hello "world""
```

Сравните это с одинарными кавычками:

```shell
:echo 'hello\nworld'
" возвращает 'hello\nworld'

:echo 'hello \"world\"'
" возвращает 'hello \"world\"'
```

Специальные символы — это специальные строковые символы, которые при экранировании ведут себя иначе. `\n` действует как новая строка. `\"` ведет себя как литерал `"`. Для получения списка других специальных символов ознакомьтесь с `:h expr-quote`.

### Процедуры строк

Давайте рассмотрим некоторые встроенные процедуры строк.

Вы можете получить длину строки с помощью `strlen()`.

```shell
:echo strlen("choco")
" возвращает 5
```

Вы можете преобразовать строку в число с помощью `str2nr()`:

```shell
:echo str2nr("12donuts")
" возвращает 12

:echo str2nr("donuts12")
" возвращает 0
```

Подобно приведению строки к числу ранее, если число не является первым символом, Vim не сможет его поймать.

Хорошая новость заключается в том, что у Vim есть метод, который преобразует строку в вещественное число, `str2float()`:

```shell
:echo str2float("12.5donuts")
" возвращает 12.5
```

Вы можете заменить шаблон в строке с помощью метода `substitute()`:

```shell
:echo substitute("sweet", "e", "o", "g")
" возвращает "swoot"
```

Последний параметр, "g", является глобальным флагом. С ним Vim заменит все совпадения. Без него Vim заменит только первое совпадение.

```shell
:echo substitute("sweet", "e", "o", "")
" возвращает "swoet"
```

Команду замены можно комбинировать с `getline()`. Напоминаю, что функция `getline()` получает текст на заданном номере строки. Предположим, у вас есть текст "chocolate donut" на строке 5. Вы можете использовать процедуру:

```shell
:echo substitute(getline(5), "chocolate", "glazed", "g")
" возвращает glazed donut
```

Существует множество других процедур строк. Ознакомьтесь с `:h string-functions`.

## Список

Список Vimscript похож на массив в Javascript или список в Python. Это *упорядоченная* последовательность элементов. Вы можете смешивать и сочетать содержимое с различными типами данных:

```shell
[1,2,3]
['a', 'b', 'c']
[1,'a', 3.14]
[1,2,[3,4]]
```

### Подсписки

Список Vim индексируется с нуля. Вы можете получить доступ к конкретному элементу в списке с помощью `[n]`, где n — индекс.

```shell
:echo ["a", "sweet", "dessert"][0]
" возвращает "a"

:echo ["a", "sweet", "dessert"][2]
" возвращает "dessert"
```

Если вы превысите максимальный номер индекса, Vim выдаст ошибку, сообщая, что индекс вне диапазона:

```shell
:echo ["a", "sweet", "dessert"][999]
" возвращает ошибку
```

Когда вы опускаетесь ниже нуля, Vim начинает индексировать с последнего элемента. Превышение минимального номера индекса также вызовет ошибку:

```shell
:echo ["a", "sweet", "dessert"][-1]
" возвращает "dessert"

:echo ["a", "sweet", "dessert"][-3]
" возвращает "a"

:echo ["a", "sweet", "dessert"][-999]
" возвращает ошибку
```

Вы можете "нарезать" несколько элементов из списка с помощью `[n:m]`, где `n` — начальный индекс, а `m` — конечный индекс.

```shell
:echo ["chocolate", "glazed", "plain", "strawberry", "lemon", "sugar", "cream"][2:4]
" возвращает ["plain", "strawberry", "lemon"]
```

Если вы не передадите `m` (`[n:]`), Vim вернет остальные элементы, начиная с n-го элемента. Если вы не передадите `n` (`[:m]`), Vim вернет первый элемент до m-го элемента.

```shell
:echo ["chocolate", "glazed", "plain", "strawberry", "lemon", "sugar", "cream"][2:]
" возвращает ['plain', 'strawberry', 'lemon', 'sugar', 'cream']

:echo ["chocolate", "glazed", "plain", "strawberry", "lemon", "sugar", "cream"][:4]
" возвращает ['chocolate', 'glazed', 'plain', 'strawberry', 'lemon']
```

Вы можете передать индекс, который превышает максимальное количество элементов при нарезке массива.

```viml
:echo ["chocolate", "glazed", "plain", "strawberry", "lemon", "sugar", "cream"][2:999]
" возвращает ['plain', 'strawberry', 'lemon', 'sugar', 'cream']
```
### Разбиение строки

Вы можете разрезать и нацеливаться на строки так же, как и на списки:

```viml
:echo "choco"[0]
" возвращает "c"

:echo "choco"[1:3]
" возвращает "hoc"

:echo "choco"[:3]
" возвращает choc

:echo "choco"[1:]
" возвращает hoco
```

### Арифметика списков

Вы можете использовать `+` для конкатенации и изменения списка:

```viml
:let sweetList = ["chocolate", "strawberry"]
:let sweetList += ["sugar"]
:echo sweetList
" возвращает ["chocolate", "strawberry", "sugar"]
```

### Функции списков

Давайте исследуем встроенные функции списков Vim.

Чтобы получить длину списка, используйте `len()`:

```shell
:echo len(["chocolate", "strawberry"])
" возвращает 2
```

Чтобы добавить элемент в начало списка, вы можете использовать `insert()`:

```shell
:let sweetList = ["chocolate", "strawberry"]
:call insert(sweetList, "glazed")

:echo sweetList
" возвращает ["glazed", "chocolate", "strawberry"]
```

Вы также можете передать `insert()` индекс, где хотите добавить элемент. Если вы хотите добавить элемент перед вторым элементом (индекс 1):

```shell
:let sweeterList = ["glazed", "chocolate", "strawberry"]
:call insert(sweeterList, "cream", 1)

:echo sweeterList
" возвращает ['glazed', 'cream', 'chocolate', 'strawberry']
```

Чтобы удалить элемент списка, используйте `remove()`. Он принимает список и индекс элемента, который вы хотите удалить.

```shell
:let sweeterList = ["glazed", "chocolate", "strawberry"]
:call remove(sweeterList, 1)

:echo sweeterList
" возвращает ['glazed', 'strawberry']
```

Вы можете использовать `map()` и `filter()` на списке. Чтобы отфильтровать элементы, содержащие фразу "choco":

```shell
:let sweeterList = ["glazed", "chocolate", "strawberry"]
:call filter(sweeterList, 'v:val !~ "choco"')
:echo sweeterList
" возвращает ["glazed", "strawberry"]

:let sweetestList = ["chocolate", "glazed", "sugar"]
:call map(sweetestList, 'v:val . " donut"')
:echo sweetestList
" возвращает ['chocolate donut', 'glazed donut', 'sugar donut']
```

Переменная `v:val` является специальной переменной Vim. Она доступна при итерации по списку или словарю с использованием `map()` или `filter()`. Она представляет каждый элемент в итерации.

Для получения дополнительной информации, посмотрите `:h list-functions`.

### Распаковка списка

Вы можете распаковать список и присвоить переменные элементам списка:

```shell
:let favoriteFlavor = ["chocolate", "glazed", "plain"]
:let [flavor1, flavor2, flavor3] = favoriteFlavor

:echo flavor1
" возвращает "chocolate"

:echo flavor2
" возвращает "glazed"
```

Чтобы присвоить оставшиеся элементы списка, вы можете использовать `;`, за которым следует имя переменной:

```shell
:let favoriteFruits = ["apple", "banana", "lemon", "blueberry", "raspberry"]
:let [fruit1, fruit2; restFruits] = favoriteFruits

:echo fruit1
" возвращает "apple"

:echo restFruits
" возвращает ['lemon', 'blueberry', 'raspberry']
```

### Изменение списка

Вы можете изменить элемент списка напрямую:

```shell
:let favoriteFlavor = ["chocolate", "glazed", "plain"]
:let favoriteFlavor[0] = "sugar"
:echo favoriteFlavor
" возвращает ['sugar', 'glazed', 'plain']
```

Вы можете изменить несколько элементов списка напрямую:

```shell
:let favoriteFlavor = ["chocolate", "glazed", "plain"]
:let favoriteFlavor[2:] = ["strawberry", "chocolate"]
:echo favoriteFlavor
" возвращает ['chocolate', 'glazed', 'strawberry', 'chocolate']
```

## Словарь

Словарь Vimscript — это ассоциативный, неупорядоченный список. Непустой словарь состоит как минимум из одной пары ключ-значение.

```shell
{"breakfast": "waffles", "lunch": "pancakes"}
{"meal": ["breakfast", "second breakfast", "third breakfast"]}
{"dinner": 1, "dessert": 2}
```

Объект данных словаря Vim использует строку в качестве ключа. Если вы попытаетесь использовать число, Vim преобразует его в строку.

```shell
:let breakfastNo = {1: "7am", 2: "9am", "11ses": "11am"}

:echo breakfastNo
" возвращает {'1': '7am', '2': '9am', '11ses': '11am'}
```

Если вам лень ставить кавычки вокруг каждого ключа, вы можете использовать нотацию `#{}`:

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}

:echo mealPlans
" возвращает {'lunch': 'pancakes', 'breakfast': 'waffles', 'dinner': 'donuts'}
```

Единственное требование для использования синтаксиса `#{}` заключается в том, что каждый ключ должен быть либо:

- ASCII-символом.
- Цифрой.
- Подчеркиванием (`_`).
- Дефисом (`-`).

Так же, как и в списках, вы можете использовать любой тип данных в качестве значений.

```shell
:let mealPlan = {"breakfast": ["pancake", "waffle", "hash brown"], "lunch": WhatsForLunch(), "dinner": {"appetizer": "gruel", "entree": "more gruel"}}
```

### Доступ к словарю

Чтобы получить значение из словаря, вы можете вызвать ключ с помощью квадратных скобок (`['key']`) или точечной нотации (`.key`).

```shell
:let meal = {"breakfast": "gruel omelettes", "lunch": "gruel sandwiches", "dinner": "more gruel"}

:let breakfast = meal['breakfast']
:let lunch = meal.lunch

:echo breakfast
" возвращает "gruel omelettes"

:echo lunch
" возвращает "gruel sandwiches"
```

### Изменение словаря

Вы можете изменить или даже добавить содержимое словаря:

```shell
:let meal = {"breakfast": "gruel omelettes", "lunch": "gruel sandwiches"}

:let meal.breakfast = "breakfast tacos"
:let meal["lunch"] = "tacos al pastor"
:let meal["dinner"] = "quesadillas"

:echo meal
" возвращает {'lunch': 'tacos al pastor', 'breakfast': 'breakfast tacos', 'dinner': 'quesadillas'}
```

### Функции словаря

Давайте исследуем некоторые встроенные функции Vim для работы со словарями.

Чтобы проверить длину словаря, используйте `len()`.

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}

:echo len(mealPlans)
" возвращает 3
```

Чтобы узнать, содержит ли словарь определенный ключ, используйте `has_key()`.

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}

:echo has_key(mealPlans, "breakfast")
" возвращает 1

:echo has_key(mealPlans, "dessert")
" возвращает 0
```

Чтобы узнать, есть ли в словаре какие-либо элементы, используйте `empty()`. Процедура `empty()` работает со всеми типами данных: списком, словарем, строкой, числом, дробным и т.д.

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}
:let noMealPlan = {}

:echo empty(noMealPlan)
" возвращает 1

:echo empty(mealPlans)
" возвращает 0
```

Чтобы удалить запись из словаря, используйте `remove()`.

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}

:echo "удаление завтрака: " . remove(mealPlans, "breakfast")
" возвращает "удаление завтрака: 'waffles'""

:echo mealPlans
" возвращает {'lunch': 'pancakes', 'dinner': 'donuts'}
```

Чтобы преобразовать словарь в список списков, используйте `items()`:

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}

:echo items(mealPlans)
" возвращает [['lunch', 'pancakes'], ['breakfast', 'waffles'], ['dinner', 'donuts']]
```

`filter()` и `map()` также доступны.

```shell
:let breakfastNo = {1: "7am", 2: "9am", "11ses": "11am"}
:call filter(breakfastNo, 'v:key > 1')

:echo breakfastNo
" возвращает {'2': '9am', '11ses': '11am'}
```

Поскольку словарь содержит пары ключ-значение, Vim предоставляет специальную переменную `v:key`, которая работает аналогично `v:val`. При итерации по словарю `v:key` будет содержать значение текущего итерационного ключа.

Если у вас есть словарь `mealPlans`, вы можете применить к нему `map`, используя `v:key`.

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}
:call map(mealPlans, 'v:key . " и молоко"')

:echo mealPlans
" возвращает {'lunch': 'lunch и молоко', 'breakfast': 'breakfast и молоко', 'dinner': 'dinner и молоко'}
```

Аналогично, вы можете применить к нему `map`, используя `v:val`:

```shell
:let mealPlans = #{breakfast: "waffles", lunch: "pancakes", dinner: "donuts"}
:call map(mealPlans, 'v:val . " и молоко"')

:echo mealPlans
" возвращает {'lunch': 'pancakes и молоко', 'breakfast': 'waffles и молоко', 'dinner': 'donuts и молоко'}
```

Чтобы узнать больше о функциях словаря, посмотрите `:h dict-functions`.

## Специальные примитивы

У Vim есть специальные примитивы:

- `v:false`
- `v:true`
- `v:none`
- `v:null`

Кстати, `v:` — это встроенная переменная Vim. Они будут рассмотрены более подробно в следующей главе.

На моем опыте, вы не будете часто использовать эти специальные примитивы. Если вам нужно истинное/ложное значение, вы можете просто использовать 0 (ложное) и ненулевое (истинное). Если вам нужна пустая строка, просто используйте `""`. Но все же полезно знать, поэтому давайте быстро рассмотрим их.

### Истина

Это эквивалентно `true`. Это эквивалентно числу со значением, отличным от 0. При декодировании json с помощью `json_encode()` это интерпретируется как "истина".

```shell
:echo json_encode({"test": v:true})
" возвращает {"test": true}
```

### Ложь

Это эквивалентно `false`. Это эквивалентно числу со значением 0. При декодировании json с помощью `json_encode()` это интерпретируется как "ложь".

```shell
:echo json_encode({"test": v:false})
" возвращает {"test": false}
```

### Ничто

Это эквивалентно пустой строке. При декодировании json с помощью `json_encode()` это интерпретируется как пустой элемент (`null`).

```shell
:echo json_encode({"test": v:none})
" возвращает {"test": null}
```

### Нулевой

Похоже на `v:none`.

```shell
:echo json_encode({"test": v:null})
" возвращает {"test": null}
```

## Учите типы данных умным способом

В этой главе вы узнали о базовых типах данных Vimscript: число, дробь, строка, список, словарь и специальные. Изучение этих типов — первый шаг к программированию на Vimscript.

В следующей главе вы узнаете, как комбинировать их для написания выражений, таких как равенства, условные операторы и циклы.