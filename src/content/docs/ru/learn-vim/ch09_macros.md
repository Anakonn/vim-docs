---
description: В этом документе вы узнаете, как использовать макросы в Vim для автоматизации
  повторяющихся действий при редактировании файлов.
title: Ch09. Macros
---

Когда вы редактируете файлы, вы можете обнаружить, что повторяете одни и те же действия. Разве не было бы здорово, если бы вы могли выполнить эти действия один раз и воспроизводить их всякий раз, когда это необходимо? С помощью макросов Vim вы можете записывать действия и сохранять их внутри регистров Vim, чтобы выполнять их, когда это нужно.

В этой главе вы узнаете, как использовать макросы для автоматизации рутинных задач (плюс это выглядит круто, когда ваш файл редактируется сам).

## Основные макросы

Вот базовый синтаксис макроса Vim:

```shell
qa                     Начать запись макроса в регистре a
q (во время записи)    Остановить запись макроса
```

Вы можете выбрать любые строчные буквы (a-z) для хранения макросов. Вот как вы можете выполнить макрос:

```shell
@a    Выполнить макрос из регистра a
@@    Выполнить последний выполненный макрос
```

Предположим, у вас есть этот текст, и вы хотите сделать все буквы заглавными в каждой строке:

```shell
hello
vim
macros
are
awesome
```

С курсором в начале строки "hello" выполните:

```shell
qa0gU$jq
```

Разбор:
- `qa` начинает запись макроса в регистре a.
- `0` переходит к началу строки.
- `gU$` делает заглавными буквы от вашего текущего положения до конца строки.
- `j` переходит на одну строку вниз.
- `q` останавливает запись.

Чтобы воспроизвести это, выполните `@a`. Как и многие другие команды Vim, вы можете передать аргумент счетчика макросам. Например, выполнение `3@a` выполняет макрос трижды.

## Защита

Выполнение макроса автоматически заканчивается, когда он сталкивается с ошибкой. Предположим, у вас есть этот текст:

```shell
a. шоколадный пончик
b. мочи пончик
c. пончик с сахаром
d. обычный пончик
```

Если вы хотите сделать заглавной первое слово в каждой строке, этот макрос должен сработать:

```shell
qa0W~jq
```

Вот разбор команды выше:
- `qa` начинает запись макроса в регистре a.
- `0` переходит к началу строки.
- `W` переходит к следующему СЛОВУ.
- `~` переключает регистр символа под курсором.
- `j` переходит на одну строку вниз.
- `q` останавливает запись.

Я предпочитаю переоценивать выполнение моего макроса, чем недооценивать, поэтому я обычно вызываю его девяносто девять раз (`99@a`). С этой командой Vim на самом деле не выполняет этот макрос девяносто девять раз. Когда Vim доходит до последней строки и выполняет движение `j`, он не находит больше строк, чтобы спуститься, выдает ошибку и останавливает выполнение макроса.

Тот факт, что выполнение макроса останавливается при первой встреченной ошибке, является хорошей функцией, иначе Vim продолжал бы выполнять этот макрос девяносто девять раз, даже если он уже достиг конца строки.

## Макрос командной строки

Выполнение `@a` в нормальном режиме не является единственным способом выполнения макросов в Vim. Вы также можете выполнить команду `:normal @a`. `:normal` позволяет пользователю выполнять любую команду нормального режима, переданную в качестве аргумента. В приведенном выше случае это то же самое, что и выполнение `@a` из нормального режима.

Команда `:normal` принимает диапазон в качестве аргументов. Вы можете использовать это для выполнения макроса в выбранных диапазонах. Если вы хотите выполнить свой макрос между строками 2 и 3, вы можете выполнить `:2,3 normal @a`.

## Выполнение макроса в нескольких файлах

Предположим, у вас есть несколько файлов `.txt`, каждый из которых содержит некоторый текст. Ваша задача — сделать заглавным только первое слово в строках, содержащих слово "пончик". Предположим, у вас есть `0W~j` в регистре a (тот же макрос, что и раньше). Как вы можете быстро это сделать?

Первый файл:

```shell
## savory.txt
a. пончик с чеддером и халапеньо
b. пончик с макаронами и сыром
c. жареный пельмень
```

Второй файл:

```shell
## sweet.txt
a. шоколадный пончик
b. шоколадный блинчик
c. пончик с сахаром
```

Третий файл:

```shell
## plain.txt
a. хлеб из пшеницы
b. обычный пончик
```

Вот как вы можете это сделать:
- `:args *.txt` для поиска всех файлов `.txt` в вашем текущем каталоге.
- `:argdo g/donut/normal @a` выполняет глобальную команду `g/donut/normal @a` для каждого файла внутри `:args`.
- `:argdo update` выполняет команду `update`, чтобы сохранить каждый файл внутри `:args`, когда буфер был изменен.

Если вы не знакомы с глобальной командой `:g/donut/normal @a`, она выполняет команду, которую вы даете (`normal @a`), на строках, которые соответствуют шаблону (`/donut/`). Я расскажу о глобальной команде в следующей главе.

## Рекурсивный макрос

Вы можете рекурсивно выполнять макрос, вызывая тот же регистр макроса во время записи этого макроса. Предположим, у вас снова есть этот список, и вам нужно переключить регистр первого слова:

```shell
a. шоколадный пончик
b. мочи пончик
c. пончик с сахаром
d. обычный пончик
```

На этот раз давайте сделаем это рекурсивно. Выполните:

```shell
qaqqa0W~j@aq
```

Вот разбор шагов:
- `qaq` записывает пустой макрос a. Необходимо начать с пустого регистра, потому что когда вы рекурсивно вызываете макрос, он выполнит все, что находится в этом регистре.
- `qa` начинает запись в регистре a.
- `0` переходит к первому символу в текущей строке.
- `W` переходит к следующему СЛОВУ.
- `~` переключает регистр символа под курсором.
- `j` переходит на одну строку вниз.
- `@a` выполняет макрос a.
- `q` останавливает запись.

Теперь вы можете просто выполнить `@a` и наблюдать, как Vim рекурсивно выполняет макрос.

Как макрос знал, когда остановиться? Когда макрос был на последней строке, он попытался выполнить `j`, и поскольку больше не было строк, чтобы спуститься, он остановил выполнение макроса.

## Добавление к макросу

Если вам нужно добавить действия к существующему макросу, вместо того чтобы пересоздавать макрос с нуля, вы можете добавить действия к существующему. В главе о регистрах вы узнали, что вы можете добавить к именованному регистру, используя его заглавный символ. То же правило применяется. Чтобы добавить действия к регистру макроса, используйте регистр A.

Запишите макрос в регистре a: `qa0W~q` (эта последовательность переключает регистр следующего СЛОВА в строке). Если вы хотите добавить новую последовательность, чтобы также добавить точку в конце строки, выполните:

```shell
qAA.<Esc>q
```

Разбор:
- `qA` начинает запись макроса в регистре A.
- `A.<Esc>` вставляет в конец строки (здесь `A` — это команда режима вставки, не путать с макросом A) точку, затем выходит из режима вставки.
- `q` останавливает запись макроса.

Теперь, когда вы выполняете `@a`, он не только переключает регистр следующего СЛОВА, но и добавляет точку в конце строки.

## Изменение макроса

Что если вам нужно добавить новые действия в середину макроса?

Предположим, что у вас есть макрос, который переключает первое фактическое слово и добавляет точку в конце строки, `0W~A.<Esc>` в регистре a. Предположим, что между заглавными буквами первого слова и добавлением точки в конце строки вам нужно добавить слово "глубоко жареный" прямо перед словом "пончик" *(потому что единственное, что лучше обычных пончиков, это глубоко жареные пончики)*.

Я повторно использую текст из предыдущего раздела:
```shell
a. шоколадный пончик
b. мочи пончик
c. пончик с сахаром
d. обычный пончик
```

Сначала давайте вызовем существующий макрос (предположим, что вы сохранили макрос из предыдущего раздела в регистре a) с помощью `:put a`:

```shell
0W~A.^[
```

Что это `^[`? Разве вы не сделали `0W~A.<Esc>`? Где `<Esc>`? `^[` — это *внутренний код* Vim для `<Esc>`. С определенными специальными клавишами Vim выводит представление этих клавиш в виде внутренних кодов. Некоторые общие клавиши, которые имеют внутренние представления кодов, это `<Esc>`, `<Backspace>` и `<Enter>`. Есть и другие специальные клавиши, но они не входят в рамки этой главы.

Вернемся к макросу, сразу после оператора переключения регистра (`~`), давайте добавим инструкции перейти в конец строки (`$`), вернуться на одно слово назад (`b`), перейти в режим вставки (`i`), ввести "глубоко жареный " (не забудьте пробел после "жареный "), и выйти из режима вставки (`<Esc>`).

Вот что у вас получится в итоге:

```shell
0W~$bideep fried <Esc>A.^[
```

Есть небольшая проблема. Vim не понимает `<Esc>`. Вы не можете буквально ввести `<Esc>`. Вам придется написать внутреннее представление кода для клавиши `<Esc>`. Находясь в режиме вставки, нажмите `Ctrl-V`, затем `<Esc>`. Vim выведет `^[`. `Ctrl-V` — это оператор режима вставки для вставки следующего нецифрового символа *буквально*. Ваш код макроса теперь должен выглядеть так:

```shell
0W~$bideep fried ^[A.^[
```

Чтобы добавить измененные инструкции в регистр a, вы можете сделать это так же, как добавление новой записи в именованный регистр. В начале строки выполните `"ay$`, чтобы сохранить вырезанный текст в регистре a.

Теперь, когда вы выполняете `@a`, ваш макрос будет переключать регистр первого слова, добавлять "глубоко жареный " перед "пончик" и добавлять "." в конце строки. Вкусно!

Альтернативный способ изменить макрос — использовать выражение командной строки. Выполните `:let @a="`, затем нажмите `Ctrl-R a`, это буквально вставит содержимое регистра a. Наконец, не забудьте закрыть двойные кавычки (`"`). У вас может получиться что-то вроде `:let @a="0W~$bideep fried ^[A.^["`.

## Избыточность макроса

Вы можете легко дублировать макросы из одного регистра в другой. Например, чтобы дублировать макрос из регистра a в регистр z, вы можете выполнить `:let @z = @a`. `@a` представляет содержимое регистра a. Теперь, если вы выполните `@z`, он выполнит те же действия, что и `@a`.

Я нахожу создание избыточности полезным для своих наиболее часто используемых макросов. В моем рабочем процессе я обычно записываю макросы в первых семи буквах алфавита (a-g) и часто заменяю их без особых размышлений. Если я перемещу полезные макросы ближе к концу алфавита, я смогу сохранить их, не беспокоясь о том, что случайно их заменю.

## Серийные и параллельные макросы

Vim может выполнять макросы серийно и параллельно. Предположим, у вас есть этот текст:

```shell
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

Если вы хотите записать макрос, чтобы сделать строчными все заглавные "FUNC", этот макрос должен сработать:

```shell
qa0f{gui{jq
```

Разбор:
- `qa` начинает запись в регистре a.
- `0` переходит к первой строке.
- `f{` находит первое вхождение "{".
- `gui{` делает строчными (`gu`) текст внутри текстового объекта скобок (`i{`).
- `j` переходит на одну строку вниз.
- `q` останавливает запись макроса.

Теперь вы можете выполнить `99@a`, чтобы выполнить его на оставшихся строках. Однако что, если у вас есть это выражение импорта внутри вашего файла?

```shell
import { FUNC1 } from "library1";
import { FUNC2 } from "library2";
import { FUNC3 } from "library3";
import foo from "bar";
import { FUNC4 } from "library4";
import { FUNC5 } from "library5";
```

Выполнение `99@a` выполняет макрос только три раза. Он не выполняет макрос на последних двух строках, потому что выполнение не удалось выполнить `f{` на строке "foo". Это ожидаемо при выполнении макроса серийно. Вы всегда можете перейти к следующей строке, где находится "FUNC4", и воспроизвести этот макрос снова. Но что, если вы хотите сделать все за один раз?

Выполните макрос параллельно.

Напомню из предыдущего раздела, что макросы можно выполнять с помощью команды командной строки `:normal` (например, `:3,5 normal @a` выполняет макрос a на строках 3-5). Если вы выполните `:1,$ normal @a`, вы увидите, что макрос выполняется на всех строках, кроме строки "foo". Это работает!

Хотя внутренне Vim на самом деле не выполняет макросы параллельно, внешне он ведет себя так. Vim выполняет `@a` *независимо* на каждой строке с первой до последней строки (`1,$`). Поскольку Vim выполняет эти макросы независимо, каждая строка не знает, что одно из выполнений макроса не удалось на строке "foo".
## Учите макросы умным способом

Многие действия, которые вы выполняете при редактировании, являются повторяющимися. Чтобы стать лучше в редактировании, выработайте привычку обнаруживать повторяющиеся действия. Используйте макросы (или команду точки), чтобы не выполнять одно и то же действие дважды. Почти все, что вы можете сделать в Vim, можно воспроизвести с помощью макросов.

В начале мне было очень неудобно писать макросы, но не сдавайтесь. С достаточной практикой вы привыкнете автоматизировать все.

Вам может быть полезно использовать мнемоники, чтобы запомнить ваши макросы. Если у вас есть макрос, который создает функцию, используйте регистр "f (`qf`). Если у вас есть макрос для числовых операций, должен подойти регистр "n (`qn`). Назовите его *первым именованным регистром*, который приходит вам на ум, когда вы думаете об этой операции. Я также считаю, что регистр "q является хорошим регистром по умолчанию для макросов, потому что `qq` требует меньше умственных усилий для запоминания. Наконец, мне также нравится увеличивать свои макросы в алфавитном порядке, например, `qa`, затем `qb`, затем `qc` и так далее.

Найдите метод, который лучше всего подходит вам.