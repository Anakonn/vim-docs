---
description: В этом документе рассматриваются основные типы данных Vimscript и их
  использование для написания условных операторов и циклов в базовых программах.
title: Ch26. Vimscript Conditionals and Loops
---

После изучения основных типов данных следующим шагом является изучение того, как их комбинировать, чтобы начать писать базовую программу. Базовая программа состоит из условных операторов и циклов.

В этой главе вы узнаете, как использовать типы данных Vimscript для написания условных операторов и циклов.

## Отношенческие операторы

Отношенческие операторы Vimscript похожи на многие языки программирования:

```shell
a == b		равно
a != b		не равно
a >  b		больше
a >= b		больше или равно
a <  b		меньше
a <= b		меньше или равно
```

Например:

```shell
:echo 5 == 5
:echo 5 != 5
:echo 10 > 5
:echo 10 >= 5
:echo 10 < 5
:echo 5 <= 5
```

Помните, что строки преобразуются в числа в арифметическом выражении. Здесь Vim также преобразует строки в числа в выражении равенства. "5foo" преобразуется в 5 (истинно):

```shell
:echo 5 == "5foo"
" возвращает true
```

Также помните, что если вы начнете строку с нечислового символа, например "foo5", строка преобразуется в число 0 (ложно).

```shell
echo 5 == "foo5"
" возвращает false
```

### Логические операторы строк

У Vim есть дополнительные отношенческие операторы для сравнения строк:

```shell
a =~ b
a !~ b
```

Например:

```shell
let str = "сытный завтрак"

echo str =~ "сытный"
" возвращает true

echo str =~ "ужин"
" возвращает false

echo str !~ "ужин"
" возвращает true
```

Оператор `=~` выполняет регулярное выражение на заданной строке. В приведенном выше примере `str =~ "сытный"` возвращает true, потому что `str` *содержит* шаблон "сытный". Вы всегда можете использовать `==` и `!=`, но использование их будет сравнивать выражение с целой строкой. `=~` и `!~` являются более гибкими вариантами.

```shell
echo str == "сытный"
" возвращает false

echo str == "сытный завтрак"
" возвращает true
```

Попробуем это. Обратите внимание на заглавную "С":

```shell
echo str =~ "Сытный"
" true
```

Он возвращает true, даже если "Сытный" с заглавной буквы. Интересно... Оказывается, моя настройка Vim установлена на игнорирование регистра (`set ignorecase`), так что когда Vim проверяет равенство, он использует мою настройку Vim и игнорирует регистр. Если бы я отключил игнорирование регистра (`set noignorecase`), сравнение теперь возвращает false.

```shell
set noignorecase
echo str =~ "Сытный"
" возвращает false, потому что регистр имеет значение

set ignorecase
echo str =~ "Сытный"
" возвращает true, потому что регистр не имеет значения
```

Если вы пишете плагин для других, это сложная ситуация. Использует ли пользователь `ignorecase` или `noignorecase`? Вы определенно не хотите заставлять своих пользователей менять опцию игнорирования регистра. Так что же делать?

К счастью, у Vim есть оператор, который может *всегда* игнорировать или учитывать регистр. Чтобы всегда учитывать регистр, добавьте `#` в конце.

```shell
set ignorecase
echo str =~# "сытный"
" возвращает true

echo str =~# "Сытный"
" возвращает false

set noignorecase
echo str =~# "сытный"
" true

echo str =~# "Сытный"
" false

echo str !~# "Сытный"
" true
```

Чтобы всегда игнорировать регистр при сравнении, добавьте `?`:

```shell
set ignorecase
echo str =~? "сытный"
" true

echo str =~? "Сытный"
" true

set noignorecase
echo str =~? "сытный"
" true

echo str =~? "Сытный"
" true

echo str !~? "Сытный"
" false
```

Я предпочитаю использовать `#`, чтобы всегда учитывать регистр и быть на безопасной стороне.

## If

Теперь, когда вы увидели выражения равенства Vim, давайте коснемся основного условного оператора, оператора `if`.

Минимальный синтаксис:

```shell
if {условие}
  {некоторое выражение}
endif
```

Вы можете расширить анализ случаев с помощью `elseif` и `else`.

```shell
if {предикат1}
  {выражение1}
elseif {предикат2}
  {выражение2}
elseif {предикат3}
  {выражение3}
else
  {выражение4}
endif
```

Например, плагин [vim-signify](https://github.com/mhinz/vim-signify) использует другой метод установки в зависимости от ваших настроек Vim. Ниже приведены инструкции по установке из их `readme`, используя оператор `if`:

```shell
if has('nvim') || has('patch-8.0.902')
  Plug 'mhinz/vim-signify'
else
  Plug 'mhinz/vim-signify', { 'branch': 'legacy' }
endif
```

## Тернарное выражение

У Vim есть тернарное выражение для однострочного анализа случаев:

```shell
{предикат} ? выражениеистинно : выражениеложно
```

Например:

```shell
echo 1 ? "Я истинно" : "Я ложно"
```

Поскольку 1 истинно, Vim выводит "Я истинно". Предположим, вы хотите условно установить `background` на темный, если вы используете Vim после определенного часа. Добавьте это в vimrc:

```shell
let &background = strftime("%H") < 18 ? "светлый" : "темный"
```

`&background` - это опция `'background'` в Vim. `strftime("%H")` возвращает текущее время в часах. Если еще не 6 вечера, используйте светлый фон. В противном случае используйте темный фон.

## or

Логический "или" (`||`) работает как во многих языках программирования.

```shell
{Ложное выражение}  || {Ложное выражение}   false
{Ложное выражение}  || {Истинное выражение}  true
{Истинное выражение} || {Ложное выражение}   true
{Истинное выражение} || {Истинное выражение}  true
```

Vim оценивает выражение и возвращает либо 1 (истинно), либо 0 (ложно).

```shell
echo 5 || 0
" возвращает 1

echo 5 || 5
" возвращает 1

echo 0 || 0
" возвращает 0

echo "foo5" || "foo5"
" возвращает 0

echo "5foo" || "foo5"
" возвращает 1
```

Если текущее выражение оценивается как истинное, последующее выражение не будет оцениваться.

```shell
let one_dozen = 12

echo one_dozen || two_dozen
" возвращает 1

echo two_dozen || one_dozen
" возвращает ошибку
```

Обратите внимание, что `two_dozen` никогда не определен. Выражение `one_dozen || two_dozen` не вызывает ошибку, потому что `one_dozen` сначала оценивается и оказывается истинным, поэтому Vim не оценивает `two_dozen`.

## and

Логический "и" (`&&`) является дополнением логического "или".

```shell
{Ложное выражение}  && {Ложное выражение}   false
{Ложное выражение}  && {Истинное выражение}  false
{Истинное выражение} && {Ложное выражение}   false
{Истинное выражение} && {Истинное выражение}  true
```

Например:

```shell
echo 0 && 0
" возвращает 0

echo 0 && 10
" возвращает 0
```

`&&` оценивает выражение, пока не увидит первое ложное выражение. Например, если у вас `true && true`, оно оценит оба и вернет `true`. Если у вас `true && false && true`, оно оценит первый `true` и остановится на первом `false`. Оно не оценит третий `true`.

```shell
let one_dozen = 12
echo one_dozen && 10
" возвращает 1

echo one_dozen && v:false
" возвращает 0

echo one_dozen && two_dozen
" возвращает ошибку

echo exists("one_dozen") && one_dozen == 12
" возвращает 1
```

## for

Цикл `for` обычно используется с типом данных список.

```shell
let breakfasts = ["блинчики", "вафли", "яйца"]

for breakfast in breakfasts
  echo breakfast
endfor
```

Он работает с вложенными списками:

```shell
let meals = [["завтрак", "блинчики"], ["обед", "рыба"], ["ужин", "паста"]]

for [meal_type, food] in meals
  echo "Я ем " . food . " на " . meal_type
endfor
```

Вы технически можете использовать цикл `for` со словарем, используя метод `keys()`.

```shell
let beverages = #{завтрак: "молоко", обед: "апельсиновый сок", ужин: "вода"}
for beverage_type in keys(beverages)
  echo "Я пью " . beverages[beverage_type] . " на " . beverage_type
endfor
```

## While

Другой распространенный цикл - это цикл `while`.

```shell
let counter = 1
while counter < 5
  echo "Счетчик: " . counter
  let counter += 1
endwhile
```

Чтобы получить содержимое от текущей строки до последней строки:

```shell
let current_line = line(".")
let last_line = line("$")

while current_line <= last_line
  echo getline(current_line)
  let current_line += 1
endwhile
```

## Обработка ошибок

Часто ваша программа не работает так, как вы ожидаете. В результате это сбивает вас с толку (игра слов). Вам нужна правильная обработка ошибок.

### Break

Когда вы используете `break` внутри цикла `while` или `for`, он останавливает цикл.

Чтобы получить тексты от начала файла до текущей строки, но остановиться, когда увидите слово "пончик":

```shell
let line = 0
let last_line = line("$")
let total_word = ""

while line <= last_line
  let line += 1
  let line_text = getline(line)
  if line_text =~# "пончик"
    break
  endif
  echo line_text
  let total_word .= line_text . " "
endwhile

echo total_word
```

Если у вас есть текст:

```shell
один
два
три
пончик
четыре
пять
```

Запуск вышеуказанного цикла `while` дает "один два три" и не остальной текст, потому что цикл прерывается, как только он совпадает с "пончик".

### Continue

Метод `continue` похож на `break`, когда он вызывается во время цикла. Разница в том, что вместо выхода из цикла он просто пропускает текущую итерацию.

Предположим, у вас тот же текст, но вместо `break` вы используете `continue`:

```shell
let line = 0
let last_line = line("$")
let total_word = ""

while line <= last_line
  let line += 1
  let line_text = getline(line)
  if line_text =~# "пончик"
    continue
  endif
  echo line_text
  let total_word .= line_text . " "
endwhile

echo total_word
```

На этот раз он возвращает `один два три четыре пять`. Он пропускает строку со словом "пончик", но цикл продолжается.
### try, finally, и catch

Vim имеет `try`, `finally` и `catch` для обработки ошибок. Чтобы смоделировать ошибку, вы можете использовать команду `throw`.

```shell
try
  echo "Попробуйте"
  throw "Нет"
endtry
```

Запустите это. Vim выдаст ошибку `"Исключение не поймано: Нет`.

Теперь добавим блок catch:

```shell
try
  echo "Попробуйте"
  throw "Нет"
catch
  echo "Поймано"
endtry
```

Теперь ошибки больше нет. Вы должны увидеть "Попробуйте" и "Поймано".

Давайте уберем `catch` и добавим `finally`:

```shell
try
  echo "Попробуйте"
  throw "Нет"
  echo "Вы меня не увидите"
finally
  echo "Наконец"
endtry
```

Запустите это. Теперь Vim отображает ошибку и "Наконец".

Давайте объединим все вместе:

```shell
try
  echo "Попробуйте"
  throw "Нет"
catch
  echo "Поймано"
finally
  echo "Наконец"
endtry
```

На этот раз Vim отображает как "Поймано", так и "Наконец". Ошибка не отображается, потому что Vim поймал её.

Ошибки могут возникать из разных источников. Другим источником ошибки является вызов несуществующей функции, такой как `Nope()` ниже:

```shell
try
  echo "Попробуйте"
  call Nope()
catch
  echo "Поймано"
finally
  echo "Наконец"
endtry
```

Разница между `catch` и `finally` заключается в том, что `finally` всегда выполняется, независимо от наличия ошибки, в то время как `catch` выполняется только тогда, когда ваш код получает ошибку.

Вы можете поймать конкретную ошибку с помощью `:catch`. Согласно `:h :catch`:

```shell
catch /^Vim:Interrupt$/.             " поймать прерывания (CTRL-C)
catch /^Vim\\%((\\a\\+)\\)\\=:E/.    " поймать все ошибки Vim
catch /^Vim\\%((\\a\\+)\\)\\=:/.     " поймать ошибки и прерывания
catch /^Vim(write):/.                " поймать все ошибки в :write
catch /^Vim\\%((\\a\\+)\\)\\=:E123:/ " поймать ошибку E123
catch /my-exception/.                " поймать пользовательское исключение
catch /.*/                           " поймать всё
catch.                               " то же самое, что и /.*/
```

Внутри блока `try` прерывание считается ловимой ошибкой.

```shell
try
  catch /^Vim:Interrupt$/
  sleep 100
endtry
```

В вашем vimrc, если вы используете пользовательскую цветовую схему, такую как [gruvbox](https://github.com/morhetz/gruvbox), и случайно удалили директорию цветовой схемы, но все еще имеете строку `colorscheme gruvbox` в вашем vimrc, Vim выдаст ошибку, когда вы `source` её. Чтобы исправить это, я добавил следующее в мой vimrc:

```shell
try
  colorscheme gruvbox
catch
  colorscheme default
endtry
```

Теперь, если вы `source` vimrc без директории `gruvbox`, Vim будет использовать `colorscheme default`.

## Узнайте условные операторы умным способом

В предыдущей главе вы узнали о базовых типах данных Vim. В этой главе вы узнали, как комбинировать их для написания базовых программ с использованием условных операторов и циклов. Это строительные блоки программирования.

Далее давайте узнаем о областях видимости переменных.