---
description: В этом документе рассматривается плагин Vim `totitle-vim`, который автоматизирует
  преобразование заголовков в заглавный регистр.
title: 'Ch29. Write a Plugin: Creating a Titlecase Operator'
---

Когда вы начинаете хорошо разбираться в Vim, вы можете захотеть написать свои собственные плагины. Недавно я написал свой первый плагин для Vim, [totitle-vim](https://github.com/iggredible/totitle-vim). Это плагин оператора для преобразования в заглавные буквы, аналогичный операторам верхнего регистра `gU`, нижнего регистра `gu` и переключения регистра `g~` в Vim.

В этой главе я представлю разбор плагина `totitle-vim`. Надеюсь, это прояснит процесс и, возможно, вдохновит вас создать свой уникальный плагин!

## Проблема

Я использую Vim для написания своих статей, включая этот самый гид.

Одной из основных проблем было создание правильного заглавного регистра для заголовков. Один из способов автоматизировать это — это сделать заглавной каждое слово в заголовке с помощью `g/^#/ s/\<./\u\0/g`. Для базового использования этой команды было достаточно, но это все еще не так хорошо, как иметь настоящий заглавный регистр. Слова "The" и "Of" в "Capitalize The First Letter Of Each Word" должны быть написаны с заглавной буквы. Без правильного написания с заглавной буквы предложение выглядит немного неправильно.

Сначала я не планировал писать плагин. Также оказалось, что уже существует плагин для заглавного регистра: [vim-titlecase](https://github.com/christoomey/vim-titlecase). Однако были несколько моментов, которые не работали так, как мне хотелось. Основной из них — это поведение блочного визуального режима. Если у меня есть фраза:

```shell
test title one
test title two
test title three
```

Если я использую блочное визуальное выделение на "tle":

```shell
test ti[tle] one
test ti[tle] two
test ti[tle] three
```

Если я нажму `gt`, плагин не сделает его заглавным. Я нахожу это непоследовательным с поведением `gu`, `gU` и `g~`. Поэтому я решил доработать этот репозиторий плагина заглавного регистра и использовать его для создания собственного плагина, который будет последовательным с `gu`, `gU` и `g~`!. Вновь, сам плагин vim-titlecase является отличным плагином и достойным использования самостоятельно (правда в том, что, возможно, глубоко внутри я просто хотел написать свой собственный плагин для Vim. Я не вижу, чтобы функция блочного заглавного регистра использовалась так часто в реальной жизни, кроме крайних случаев).

### Планирование плагина

Перед тем как написать первую строку кода, мне нужно решить, каковы правила заглавного регистра. Я нашел аккуратную таблицу различных правил написания с заглавной буквы на сайте [titlecaseconverter](https://titlecaseconverter.com/rules/). Знали ли вы, что в английском языке существует как минимум 8 различных правил написания с заглавной буквы? *Вздох!*

В конце концов, я использовал общие знаменатели из этого списка, чтобы придумать достаточно хорошее базовое правило для плагина. Плюс я сомневаюсь, что люди будут жаловаться: "Эй, чувак, ты используешь AMA, почему ты не используешь APA?". Вот основные правила:
- Первое слово всегда пишется с заглавной буквы.
- Некоторые наречия, союзы и предлоги пишутся с маленькой буквы.
- Если входное слово полностью написано заглавными буквами, то ничего не делайте (это может быть аббревиатура).

Что касается того, какие слова пишутся с маленькой буквы, разные правила имеют разные списки. Я решил придерживаться `a an and at but by en for in nor of off on or out per so the to up yet vs via`.

### Планирование пользовательского интерфейса

Я хочу, чтобы плагин был оператором, дополняющим существующие операторы регистра Vim: `gu`, `gU` и `g~`. Будучи оператором, он должен принимать либо движение, либо текстовый объект (`gtw` должен преобразовать в заглавные буквы следующее слово, `gtiw` должен преобразовать в заглавные буквы внутреннее слово, `gt$` должен преобразовать в заглавные буквы слова от текущего местоположения до конца строки, `gtt` должен преобразовать в заглавные буквы текущую строку, `gti(` должен преобразовать в заглавные буквы слова внутри скобок и т.д.). Я также хочу, чтобы он был сопоставлен с `gt` для легкого запоминания. Более того, он также должен работать со всеми визуальными режимами: `v`, `V` и `Ctrl-V`. Я должен иметь возможность выделить его в *любом* визуальном режиме, нажать `gt`, и тогда все выделенные тексты будут преобразованы в заглавные буквы.

## Время выполнения Vim

Первое, что вы видите, когда смотрите на репозиторий, это то, что он имеет две директории: `plugin/` и `doc/`. Когда вы запускаете Vim, он ищет специальные файлы и директории внутри директории `~/.vim` и выполняет все скриптовые файлы внутри этой директории. Для получения дополнительной информации ознакомьтесь с главой о времени выполнения Vim.

Плагин использует две директории времени выполнения Vim: `doc/` и `plugin/`. `doc/` — это место для размещения документации помощи (так что вы сможете позже искать по ключевым словам, например, `:h totitle`). Я расскажу, как создать страницу помощи позже. А пока давайте сосредоточимся на `plugin/`. Директория `plugin/` выполняется один раз при запуске Vim. В этой директории есть один файл: `totitle.vim`. Название не имеет значения (я мог бы назвать его `whatever.vim`, и он все равно бы работал). Весь код, отвечающий за работу плагина, находится в этом файле.

## Сопоставления

Давайте пройдемся по коду!

В начале файла вы видите:

```shell
if !exists('g:totitle_default_keys')
  let g:totitle_default_keys = 1
endif
```

Когда вы запускаете Vim, `g:totitle_default_keys` еще не существует, поэтому `!exists(...)` возвращает true. В этом случае определите `g:totitle_default_keys` равным 1. В Vim 0 является ложным, а ненулевое значение — истинным (используйте 1, чтобы указать на истинность).

Давайте перейдем к концу файла. Вы увидите это:

```shell
if g:totitle_default_keys
  nnoremap <expr> gt ToTitle()
  xnoremap <expr> gt ToTitle()
  nnoremap <expr> gtt ToTitle() .. '_'
endif
```

Здесь определяется основное сопоставление `gt`. В этом случае, к моменту, когда вы дойдете до условий `if` внизу файла, `if g:totitle_default_keys` вернет 1 (истинное), поэтому Vim выполнит следующие сопоставления:
- `nnoremap <expr> gt ToTitle()` сопоставляет оператор нормального режима. Это позволяет вам запускать оператор + движение/текстовый объект, например, `gtw`, чтобы преобразовать в заглавные буквы следующее слово, или `gtiw`, чтобы преобразовать в заглавные буквы внутреннее слово. Я расскажу о деталях того, как работает сопоставление операторов позже.
- `xnoremap <expr> gt ToTitle()` сопоставляет операторы визуального режима. Это позволяет вам преобразовывать в заглавные буквы тексты, которые визуально выделены.
- `nnoremap <expr> gtt ToTitle() .. '_'` сопоставляет оператор по строке в нормальном режиме (аналогично `guu` и `gUU`). Вы можете задаться вопросом, что делает `.. '_'` в конце. `..` — это оператор интерполяции строк в Vim. `_` используется как движение с оператором. Если вы посмотрите в `:help _`, там говорится, что подчеркивание используется для подсчета 1 строки вниз. Это выполняет оператор на текущей строке (попробуйте с другими операторами, попробуйте выполнить `gU_` или `d_`, обратите внимание, что это делает то же самое, что и `gUU` или `dd`).
- Наконец, аргумент `<expr>` позволяет вам указать количество, так что вы можете сделать `3gtw`, чтобы преобразовать в заглавные буквы следующие 3 слова.

Что если вы не хотите использовать стандартное сопоставление `gt`? В конце концов, вы переопределяете стандартное сопоставление `gt` (перейти к следующей вкладке) в Vim. Что если вы хотите использовать `gz` вместо `gt`? Помните, как вы ранее проверяли `if !exists('g:totitle_default_keys')` и `if g:totitle_default_keys`? Если вы добавите `let g:totitle_default_keys = 0` в ваш vimrc, то `g:totitle_default_keys` уже будет существовать, когда плагин будет запущен (коды в вашем vimrc выполняются до файлов времени выполнения `plugin/`), поэтому `!exists('g:totitle_default_keys')` вернет false. Более того, `if g:totitle_default_keys` будет ложным (поскольку он будет иметь значение 0), поэтому он также не выполнит сопоставление `gt`! Это эффективно позволяет вам определить ваше собственное пользовательское сопоставление в Vimrc.

Чтобы определить ваше собственное сопоставление заглавного регистра на `gz`, добавьте это в ваш vimrc:

```shell
let g:totitle_default_keys = 0

nnoremap <expr> gz ToTitle()
xnoremap <expr> gz ToTitle()
nnoremap <expr> gzz ToTitle() .. '_'
```

Легко.

## Функция ToTitle

Функция `ToTitle()` — это, безусловно, самая длинная функция в этом файле.

```shell
 function! ToTitle(type = '')
  if a:type ==# ''
    set opfunc=ToTitle
    return 'g@'
  endif

  " вызывается при вызове функции ToTitle()
  if a:type != 'block' && a:type != 'line' && a:type != 'char'
    let l:words = a:type
    let l:wordsArr = trim(l:words)->split('\s\+')
    call map(l:wordsArr, 's:capitalize(v:val)')
    return l:wordsArr->join(' ')
  endif

  " сохраняем текущие настройки
  let l:sel_save = &selection
  let l:reg_save = getreginfo('"')
  let l:cb_save = &clipboard
  let l:visual_marks_save = [getpos("'<"), getpos("'>")]

  try
    set clipboard= selection=inclusive
    let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
    let l:selected_phrase = getreg('"')
    let l:WORD_PATTERN = '\<\k*\>'
    let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

    let l:startLine = line("'<")
    let l:startCol = virtcol(".")

    " когда пользователь вызывает блочную операцию
    if a:type ==# "block"
      sil! keepj norm! gv"ad
      keepj $
      keepj pu_

      let l:lastLine = line("$")

      sil! keepj norm "ap

      let l:curLine = line(".")

      sil! keepj norm! VGg@
      exe "keepj norm! 0\<c-v>G$h\"ad"
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
      exe "keepj " . l:lastLine
      sil! keepj norm! "_dG
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"

    " когда пользователь вызывает операцию по символу или строке
    else
      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
      let l:titlecased = s:capitalizeFirstWord(l:titlecased)
      call setreg('"', l:titlecased)
      let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
      silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"
    endif
  finally

    " восстанавливаем настройки
    call setreg('"', l:reg_save)
    call setpos("'<", l:visual_marks_save[0])
    call setpos("'>", l:visual_marks_save[1])
    let &clipboard = l:cb_save
    let &selection = l:sel_save
  endtry
  return
endfunction
```

Это очень длинная функция, поэтому давайте разобьем ее на части.

*Я мог бы разбить это на более мелкие секции, но ради завершения этой главы я оставил это как есть.*
## Операторная Функция

Вот первая часть кода:

```shell
if a:type ==# ''
  set opfunc=ToTitle
  return 'g@'
endif
```

Что такое `opfunc`? Почему он возвращает `g@`?

Vim имеет специальный оператор, операторную функцию, `g@`. Этот оператор позволяет использовать *любую* функцию, назначенную опции `opfunc`. Если у меня есть функция `Foo()`, назначенная `opfunc`, то когда я запускаю `g@w`, я запускаю `Foo()` на следующем слове. Если я запускаю `g@i(`, то я запускаю `Foo()` на внутренних скобках. Эта операторная функция критически важна для создания собственного оператора Vim.

Следующая строка назначает `opfunc` функции `ToTitle`.

```shell
set opfunc=ToTitle
```

Следующая строка буквально возвращает `g@`:

```shell
return g@
```

Так как же работают эти две строки и почему они возвращают `g@`?

Предположим, что у вас есть следующая карта:

```shell
nnoremap <expr> gt ToTitle()`
```

Затем вы нажимаете `gtw` (привести к заглавным буквам следующее слово). В первый раз, когда вы запускаете `gtw`, Vim вызывает метод `ToTitle()`. Но в данный момент `opfunc` все еще пуст. Вы также не передаете никаких аргументов в `ToTitle()`, поэтому у него будет значение `a:type` равное `''`. Это приводит к тому, что условное выражение проверяет аргумент `a:type`, `if a:type ==# ''`, и оно истинно. Внутри вы назначаете `opfunc` функции `ToTitle` с помощью `set opfunc=ToTitle`. Теперь `opfunc` назначен на `ToTitle`. Наконец, после того как вы назначили `opfunc` функции `ToTitle`, вы возвращаете `g@`. Я объясню, почему он возвращает `g@` ниже.

Вы еще не закончили. Помните, вы только что нажали `gtw`. Нажатие `gt` выполнило все вышеперечисленные действия, но у вас все еще есть `w`, который нужно обработать. Возвращая `g@`, в этот момент вы технически имеете `g@w` (поэтому вы и возвращаете `g@`). Поскольку `g@` является оператором функции, вы передаете ему движение `w`. Таким образом, Vim, получив `g@w`, вызывает `ToTitle` *еще раз* (не волнуйтесь, вы не попадете в бесконечный цикл, как вы увидите чуть позже).

Вкратце, нажав `gtw`, Vim проверяет, пуст ли `opfunc` или нет. Если он пуст, то Vim назначит его на `ToTitle`. Затем он возвращает `g@`, по сути вызывая `ToTitle` еще раз, чтобы вы могли использовать его как оператор. Это самая сложная часть создания пользовательского оператора, и вы это сделали! Далее вам нужно построить логику для `ToTitle()`, чтобы на самом деле привести ввод к заглавным буквам.

## Обработка Ввода

Теперь у вас есть `gt`, функционирующий как оператор, который выполняет `ToTitle()`. Но что делать дальше? Как на самом деле привести текст к заглавным буквам?

Когда вы запускаете любой оператор в Vim, есть три разных типа действий: символ, строка и блок. `g@w` (слово) является примером операции с символами. `g@j` (одна строка ниже) является примером строковой операции. Операция с блоком редка, но обычно, когда вы выполняете операцию `Ctrl-V` (визуальный блок), она будет считаться операцией с блоком. Операции, которые нацелены на несколько символов вперед / назад, обычно считаются операциями с символами (`b`, `e`, `w`, `ge` и т.д.). Операции, которые нацелены на несколько строк вниз / вверх, обычно считаются строковыми операциями (`j`, `k`). Операции, которые нацелены на столбцы вперед, назад, вверх или вниз, обычно считаются операциями с блоками (они обычно либо принудительное движение по столбцам, либо блочное визуальное режим; для получения дополнительной информации: `:h forced-motion`).

Это означает, что если вы нажмете `g@w`, `g@` передаст буквальную строку `"char"` в качестве аргумента для `ToTitle()`. Если вы сделаете `g@j`, `g@` передаст буквальную строку `"line"` в качестве аргумента для `ToTitle()`. Эта строка будет передана в функцию `ToTitle` как аргумент `type`.

## Создание Собственной Пользовательской Функции Оператора

Давайте остановимся и поиграем с `g@`, написав тестовую функцию:

```shell
function! Test(some_arg)
  echom a:some_arg 
endfunction
```

Теперь назначьте эту функцию `opfunc`, выполнив:

```shell
:set opfunc=Test
```

Оператор `g@` выполнит `Test(some_arg)` и передаст ему либо `"char"`, либо `"line"`, либо `"block"` в зависимости от того, какую операцию вы выполняете. Запустите разные операции, такие как `g@iw` (внутреннее слово), `g@j` (одна строка ниже), `g@$` (до конца строки) и т.д. Посмотрите, какие разные значения выводятся. Чтобы протестировать операцию с блоком, вы можете использовать принудительное движение Vim для операций с блоками: `g@Ctrl-Vj` (операция с блоком на один столбец ниже).

Вы также можете использовать это в визуальном режиме. Используйте различные визуальные выделения, такие как `v`, `V` и `Ctrl-V`, а затем нажмите `g@` (будьте осторожны, вывод будет мигать очень быстро, так что вам нужно быть внимательным - но вывод определенно есть. Также, поскольку вы используете `echom`, вы можете проверить записанные сообщения вывода с помощью `:messages`).

Довольно круто, не правда ли? Что можно запрограммировать с помощью Vim! Почему это не учили в школе? Давайте продолжим с нашим плагином.

## ToTitle Как Функция

Переходим к следующим строкам:

```shell
if a:type != 'block' && a:type != 'line' && a:type != 'char'
  let l:words = a:type
  let l:wordsArr = trim(l:words)->split('\s\+')
  call map(l:wordsArr, 's:capitalize(v:val)')
  return l:wordsArr->join(' ')
endif
```

Эта строка на самом деле не имеет ничего общего с поведением `ToTitle()` как оператора, но позволяет сделать его вызываемой функцией TitleCase (да, я знаю, что нарушаю принцип единственной ответственности). Мотивация заключается в том, что Vim имеет встроенные функции `toupper()` и `tolower()`, которые преобразуют любую заданную строку в верхний и нижний регистр соответственно. Например: `:echo toupper('hello')` возвращает `'HELLO'`, а `:echo tolower('HELLO')` возвращает `'hello'`. Я хочу, чтобы этот плагин имел возможность запускать `ToTitle`, чтобы вы могли делать `:echo ToTitle('once upon a time')` и получать значение `'Once Upon a Time'`.

Теперь вы знаете, что когда вы вызываете `ToTitle(type)` с `g@`, аргумент `type` будет иметь значение либо `'block'`, либо `'line'`, либо `'char'`. Если аргумент не является ни `'block'`, ни `'line'`, ни `'char'`, вы можете с уверенностью предположить, что `ToTitle()` вызывается вне `g@`. В этом случае вы разбиваете их по пробелам (`\s\+`) с помощью:

```shell
let l:wordsArr = trim(l:words)->split('\s\+')
```

Затем капитализируете каждый элемент:

```shell
call map(l:wordsArr, 's:capitalize(v:val)')
```

Прежде чем снова объединить их:

```shell
l:wordsArr->join(' ')
```

Функция `capitalize()` будет рассмотрена позже.

## Временные Переменные

Следующие строки:

```shell
let l:sel_save = &selection
let l:reg_save = getreginfo('"')
let l:cb_save = &clipboard
let l:visual_marks_save = [getpos("'<"), getpos("'>")]
```

Эти строки сохраняют различные текущие состояния во временные переменные. Позже вы будете использовать визуальные режимы, метки и регистры. Выполнение этих действий повлияет на несколько состояний. Поскольку вы не хотите изменять историю, вам нужно сохранить их во временные переменные, чтобы вы могли восстановить состояния позже.
## Приведение выделенного текста к верхнему регистру

Следующие строки важны:

```shell
try
  set clipboard= selection=inclusive
  let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
  let l:selected_phrase = getreg('"')
  let l:WORD_PATTERN = '\<\k*\>'
  let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

  let l:startLine = line("'<")
  let l:startCol = virtcol(".")
```
Давайте разберем их небольшими частями. Эта строка:

```shell
set clipboard= selection=inclusive
```

Вы сначала устанавливаете параметр `selection` в значение inclusive, а `clipboard` оставляете пустым. Атрибут выбора обычно используется в визуальном режиме, и есть три возможных значения: `old`, `inclusive` и `exclusive`. Установка его в значение inclusive означает, что последний символ выделения включен. Я не буду углубляться в это, но суть в том, что выбор inclusive обеспечивает согласованное поведение в визуальном режиме. По умолчанию Vim устанавливает его в значение inclusive, но вы устанавливаете его здесь на всякий случай, если один из ваших плагинов установит его в другое значение. Ознакомьтесь с `:h 'clipboard'` и `:h 'selection'`, если вам интересно, что они действительно делают.

Далее у вас есть этот странно выглядящий хэш, за которым следует команда выполнения:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
```

Во-первых, синтаксис `#{}` — это словарный тип данных Vim. Локальная переменная `l:commands` — это хэш с ключами 'lines', 'char' и 'block'. Команда `silent exe '...'` выполняет любую команду внутри строки без уведомлений (в противном случае она будет отображать уведомления внизу вашего экрана).

Во-вторых, выполняемые команды — это `'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')`. Первая команда, `noautocmd`, выполнит последующую команду без срабатывания каких-либо автокоманд. Вторая команда, `keepjumps`, не будет записывать перемещение курсора во время перемещения. В Vim определенные движения автоматически записываются в список изменений, список переходов и список меток. Это предотвращает это. Суть использования `noautocmd` и `keepjumps` — предотвратить побочные эффекты. Наконец, команда `normal` выполняет строки как обычные команды. `..` — это синтаксис интерполяции строк Vim. `get()` — это метод получения, который принимает либо список, блоб, либо словарь. В данном случае вы передаете ему словарь `l:commands`. Ключ — это `a:type`. Вы уже узнали, что `a:type` — это одно из трех строковых значений: 'char', 'line' или 'block'. Таким образом, если `a:type` — это 'line', вы будете выполнять `"noautocmd keepjumps normal! '[V']y"` (для получения дополнительной информации ознакомьтесь с `:h silent`, `:h :exe`, `:h :noautocmd`, `:h :keepjumps`, `:h :normal` и `:h get()`).

Давайте разберем, что делает `'[V']y`. Сначала предположим, что у вас есть следующий текст:

```shell
второй завтрак
лучше первого завтрака
```
Предположим, что ваш курсор находится на первой строке. Затем вы нажимаете `g@j` (запускаете операторную функцию, `g@`, на одну строку ниже, с помощью `j`). `'[` перемещает курсор к началу ранее измененного или вырезанного текста. Хотя вы технически не изменили и не вырезали никакой текст с помощью `g@j`, Vim запоминает расположение начальных и конечных движений команды `g@` с помощью `'[` и `']` (для получения дополнительной информации ознакомьтесь с `:h g@`). В вашем случае нажатие `'[` перемещает курсор на первую строку, потому что именно там вы начали, когда запустили `g@`. `V` — это команда визуального режима по строкам. Наконец, `']` перемещает курсор к концу ранее измененного или вырезанного текста, но в данном случае он перемещает курсор к концу вашей последней операции `g@`. В итоге `y` вырезает выделенный текст.

То, что вы только что сделали, — это вырезание того же текста, над которым вы выполняли `g@`.

Если вы посмотрите на другие две команды здесь:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
```

Они все выполняют аналогичные действия, за исключением того, что вместо использования действий по строкам вы будете использовать действия по символам или блокам. Я буду звучать избыточно, но в любом из трех случаев вы фактически вырезаете тот же текст, над которым вы выполняли `g@`.

Давайте посмотрим на следующую строку:

```shell
let l:selected_phrase = getreg('"')
```

Эта строка получает содержимое неназванного регистра (`"`) и сохраняет его в переменной `l:selected_phrase`. Подождите минутку... разве вы только что не вырезали текст? Неназванный регистр в данный момент содержит текст, который вы только что вырезали. Вот как этот плагин может получить копию текста.

Следующая строка — это регулярное выражение:

```shell
let l:WORD_PATTERN = '\<\k*\>'
```

`\<` и `\>` — это шаблоны границ слов. Символ, следующий за `\<`, соответствует началу слова, а символ, предшествующий `\>`, соответствует концу слова. `\k` — это шаблон ключевого слова. Вы можете проверить, какие символы Vim принимает в качестве ключевых слов, с помощью `:set iskeyword?`. Напомню, что движение `w` в Vim перемещает курсор по словам. Vim имеет предвзятое представление о том, что такое "ключевое слово" (вы даже можете редактировать их, изменяя параметр `iskeyword`). Ознакомьтесь с `:h /\<`, `:h /\>`, `:h /\k` и `:h 'iskeyword'` для получения дополнительной информации. Наконец, `*` означает ноль или более последующих шаблонов.

В общем, `'\<\k*\>'` соответствует слову. Если у вас есть строка:

```shell
один два три
```

Сравнение ее с шаблоном даст вам три совпадения: "один", "два" и "три".

Наконец, у вас есть еще один шаблон:

```shell
let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'
```

Напомню, что команда замены Vim может использоваться с выражением `\={ваше-выражение}`. Например, если вы хотите сделать строку "пончик" заглавной в текущей строке, вы можете использовать функцию `toupper()` Vim. Вы можете достичь этого, выполнив `:%s/пончик/\=toupper(submatch(0))/g`. `submatch(0)` — это специальное выражение, используемое в команде замены. Оно возвращает весь совпавший текст.

Следующие две строки:

```shell
let l:startLine = line("'<")
let l:startCol = virtcol(".")
```

Выражение `line()` возвращает номер строки. Здесь вы передаете ему метку `'<`, представляющую первую строку последней выделенной области. Напомню, что вы использовали визуальный режим, чтобы вырезать текст. `'<` возвращает номер строки начала этого выделенного участка. Выражение `virtcol()` возвращает номер столбца текущего курсора. Вам нужно будет перемещать курсор по всему тексту через некоторое время, поэтому вам нужно сохранить местоположение курсора, чтобы вы могли вернуться сюда позже.

Сделайте паузу здесь и просмотрите все, что было до сих пор. Убедитесь, что вы все еще следите за материалом. Когда будете готовы, давайте продолжим.
## Обработка блочной операции

Давайте пройдемся по этому разделу:

```shell
if a:type ==# "block"
  sil! keepj norm! gv"ad
  keepj $
  keepj pu_

  let l:lastLine = line("$")

  sil! keepj norm "ap

  let l:curLine = line(".")

  sil! keepj norm! VGg@
  exe "keepj norm! 0\<c-v>G$h\"ad" 
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
  exe "keepj " . l:lastLine
  sil! keepj norm! "_dG
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

Пора на самом деле сделать текст заглавным. Помните, что у вас есть `a:type`, который может быть 'char', 'line' или 'block'. В большинстве случаев вы, вероятно, будете получать 'char' и 'line'. Но иногда вы можете получить блок. Это редко, но это необходимо учитывать. К сожалению, обработка блока не так проста, как обработка символов и строк. Это потребует немного дополнительных усилий, но это осуществимо.

Прежде чем начать, давайте рассмотрим пример того, как вы можете получить блок. Предположим, у вас есть следующий текст:

```shell
блинчик на завтрак
блинчик на обед
блинчик на ужин
```

Предположим, что ваш курсор находится на "c" в "блинчик" на первой строке. Затем вы используете визуальный блок (`Ctrl-V`), чтобы выбрать вниз и вперед, чтобы выделить "линчик" во всех трех строках:

```shell
бли[nчик] на завтрак
бли[nчик] на обед
бли[nчик] на ужин
```

Когда вы нажимаете `gt`, вы хотите получить:

```shell
блинЧик на завтрак
блинЧик на обед
блинЧик на ужин

```
Вот ваши основные предположения: когда вы выделяете три "линчика" в "блинчиках", вы говорите Vim, что у вас есть три строки слов, которые вы хотите выделить. Эти слова - "линчик", "линчик" и "линчик". Вы ожидаете получить "Линчик", "Линчик" и "Линчик".

Давайте перейдем к деталям реализации. Следующие несколько строк содержат:

```shell
sil! keepj norm! gv"ad
keepj $
keepj pu_
let l:lastLine = line("$")
sil! keepj norm "ap
let l:curLine = line(".")
```

Первая строка:

```shell
sil! keepj norm! gv"ad
```

Помните, что `sil!` выполняется без вывода, а `keepj` сохраняет историю переходов при перемещении. Затем вы выполняете нормальную команду `gv"ad`. `gv` повторно выделяет последний визуально выделенный текст (в примере с блинчиками это повторно выделит все три 'линчика'). `"ad` удаляет визуально выделенные тексты и сохраняет их в регистре a. В результате у вас теперь есть:

```shell
бли на завтрак
бли на обед
бли на ужин
```

Теперь у вас есть 3 *блока* (не строки) 'линчиков', сохраненных в регистре a. Это различие важно. Копирование текста с помощью визуального режима по строкам отличается от копирования текста с помощью визуального режима по блокам. Имейте это в виду, потому что вы увидите это снова позже.

Далее у вас есть:

```shell
keepj $
keepj pu_
```

`$` перемещает вас на последнюю строку в вашем файле. `pu_` вставляет одну строку ниже, где находится ваш курсор. Вы хотите выполнить их с `keepj`, чтобы не изменять историю переходов.

Затем вы сохраняете номер строки последней строки (`line("$")`) в локальной переменной `lastLine`.

```shell
let l:lastLine = line("$")
```

Затем вставляете содержимое из регистра с помощью `norm "ap`.

```shell
sil! keepj norm "ap
```

Имейте в виду, что это происходит на новой строке, которую вы создали ниже последней строки файла - вы находитесь внизу файла. Вставка дает вам эти *блоки* текста:

```shell
линчик
линчик
линчик
```

Далее вы сохраняете местоположение текущей строки, где находится ваш курсор.

```shell
let l:curLine = line(".")
```

Теперь давайте перейдем к следующим строкам:

```shell
sil! keepj norm! VGg@
exe "keepj norm! 0\<c-v>G$h\"ad"
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

Эта строка:

```shell
sil! keepj norm! VGg@
```

`VG` визуально выделяет их с помощью режима визуального выделения строк от текущей строки до конца файла. Таким образом, вы выделяете три блока текстов 'линчик' с помощью выделения по строкам (вспомните различие между блоком и строкой). Обратите внимание, что в первый раз, когда вы вставили три "линчика", вы вставляли их как блоки. Теперь вы выделяете их как строки. Они могут выглядеть одинаково снаружи, но внутренне Vim знает разницу между вставкой блоков текста и вставкой строк текста.

```shell
линчик
линчик
линчик
```

`g@` - это оператор функции, поэтому вы фактически делаете рекурсивный вызов к самому себе. Но зачем? Какова цель этого?

Вы делаете рекурсивный вызов к `g@` и передаете ему все 3 строки (после выполнения с `V`, у вас теперь строки, а не блоки) текстов 'линчик', чтобы они были обработаны другой частью кода (вы рассмотрите это позже). Результат выполнения `g@` - три строки правильно оформленного текста:

```shell
Линчик
Линчик
Линчик
```

Следующая строка:

```shell
exe "keepj norm! 0\<c-v>G$h\"ad"
```

Эта команда выполняет команду нормального режима, чтобы перейти к началу строки (`0`), использовать визуальное выделение блока, чтобы перейти к последней строке и последнему символу на этой строке (`<c-v>G$`). `h` - это для корректировки курсора (когда вы выполняете `$`, Vim перемещается на одну строку вправо). Наконец, вы удаляете выделенный текст и сохраняете его в регистре a (`"ad`).

Следующая строка:

```shell
exe "keepj " . l:startLine
```

Вы перемещаете курсор обратно туда, где была `startLine`.

Далее:

```shell
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
```

Находясь в местоположении `startLine`, вы теперь переходите к столбцу, отмеченному `startCol`. `\<bar>\` - это движение по бару `|`. Движение по бару в Vim перемещает ваш курсор в n-й столбец (предположим, что `startCol` был 4. Выполнение `4|` переместит ваш курсор в позицию столбца 4). Помните, что `startCol` - это местоположение, где вы сохранили позицию столбца текста, который вы хотели сделать заглавным. Наконец, `"aP` вставляет тексты, сохраненные в регистре a. Это возвращает текст туда, где он был удален ранее.

Давайте посмотрим на следующие 4 строки:

```shell
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

`exe "keepj " . l:lastLine` перемещает ваш курсор обратно в местоположение `lastLine` из ранее. `sil! keepj norm! "_dG` удаляет лишние пробелы, которые были созданы с помощью черной дыры (`"_dG`), чтобы ваш неназванный регистр оставался чистым. `exe "keepj " . l:startLine` перемещает ваш курсор обратно в `startLine`. Наконец, `exe "sil! keepj norm! " . l:startCol . "\<bar>"` перемещает ваш курсор в столбец `startCol`.

Это все действия, которые вы могли бы выполнить вручную в Vim. Однако преимущество превращения этих действий в многоразовые функции заключается в том, что они избавят вас от выполнения 30+ строк инструкций каждый раз, когда вам нужно сделать заглавным что-либо. Главное здесь в том, что все, что вы можете сделать вручную в Vim, вы можете превратить в многоразовую функцию, а значит, в плагин!

Вот как это будет выглядеть.

Дано некоторый текст:

```shell
блинчик на завтрак
блинчик на обед
блинчик на ужин

... какой-то текст
```

Сначала вы визуально выделяете его блочно:

```shell
бли[nчик] на завтрак
бли[nчик] на обед
бли[nчик] на ужин

... какой-то текст
```

Затем вы удаляете его и сохраняете этот текст в регистре a:

```shell
бли на завтрак
бли на обед
бли на ужин

... какой-то текст
```

Затем вы вставляете его внизу файла:

```shell
бли на завтрак
бли на обед
бли на ужин

... какой-то текст
линчик
линчик
линчик
```

Затем вы делаете его заглавным:

```shell
бли на завтрак
бли на обед
бли на ужин

... какой-то текст
Линчик
Линчик
Линчик
```

Наконец, вы возвращаете заглавленный текст обратно:

```shell
блинЧик на завтрак
блинЧик на обед
блинЧик на ужин

... какой-то текст
```

## Обработка строковых и символьных операций

Вы еще не закончили. Вы только что рассмотрели крайний случай, когда вы выполняете `gt` на блочных текстах. Вам все еще нужно обработать операции 'line' и 'char'. Давайте посмотрим на код `else`, чтобы увидеть, как это сделано.

Вот коды:

```shell
if a:type ==# "block"
  # ... 
else
  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
  let l:titlecased = s:capitalizeFirstWord(l:titlecased)
  call setreg('"', l:titlecased)
  let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
  silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
endif
```

Давайте пройдемся по ним построчно. Секретный соус этого плагина на самом деле находится в этой строке:

```shell
let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
```

`@@` содержит текст из неназванного регистра, который нужно сделать заглавным. `l:WORD_PATTERN` - это индивидуальное совпадение ключевого слова. `l:UPCASE_REPLACEMENT` - это вызов команды `capitalize()` (которую вы увидите позже). `'g'` - это глобальный флаг, который указывает команде замены заменять все заданные слова, а не только первое слово.

Следующая строка:

```shell
let l:titlecased = s:capitalizeFirstWord(l:titlecased)
```

Это гарантирует, что первое слово всегда будет с заглавной буквы. Если у вас есть фраза, такая как "яблоко в день держит врача подальше", поскольку первое слово "яблоко" - это специальное слово, ваша команда замены не сделает его заглавным. Вам нужен метод, который всегда делает заглавной первую букву, независимо от этого. Эта функция делает именно это (вы увидите детали этой функции позже). Результат этих методов капитализации хранится в локальной переменной `l:titlecased`.

Следующая строка:

```shell
call setreg('"', l:titlecased)
```

Это помещает строку с заглавной буквы в неназванный регистр (`"`).

Далее следующие две строки:

```shell
let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
```

Эй, это выглядит знакомо! Вы видели похожий шаблон ранее с `l:commands`. Вместо yank здесь вы используете paste (`p`). Ознакомьтесь с предыдущим разделом, где я объяснял `l:commands`, для освежения памяти.

Наконец, эти две строки:

```shell
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

Вы перемещаете курсор обратно в строку и столбец, где вы начали. Вот и все!

Давайте подытожим. Вышеуказанный метод замены достаточно умен, чтобы сделать заглавными заданные тексты и пропустить специальные слова (подробнее об этом позже). После того, как у вас есть строка с заглавной буквы, вы сохраняете их в неназванном регистре. Затем вы визуально выделяете точно тот же текст, над которым вы работали с `g@` ранее, затем вставляете из неназванного регистра (это эффективно заменяет не заглавные тексты на заглавные версии). Наконец, вы перемещаете курсор обратно туда, где вы начали.
## Очистка

Вы технически завершили. Тексты теперь написаны с заглавной буквы. Все, что осталось сделать, это восстановить регистры и настройки.

```shell
call setreg('"', l:reg_save)
call setpos("'<", l:visual_marks_save[0])
call setpos("'>", l:visual_marks_save[1])
let &clipboard = l:cb_save
let &selection = l:sel_save
```

Это восстанавливает:
- безымянный регистр.
- метки `<` и `>`.
- параметры `'clipboard'` и `'selection'`.

Фух, вы закончили. Это была длинная функция. Я мог бы сделать функцию короче, разбив её на более мелкие, но пока что этого будет достаточно. Теперь давайте кратко рассмотрим функции капитализации.

## Функция Капитализации

В этом разделе давайте рассмотрим функцию `s:capitalize()`. Вот как выглядит эта функция:

```shell
function! s:capitalize(string)
    if(toupper(a:string) ==# a:string && a:string != 'A')
        return a:string
    endif

    let l:str = tolower(a:string)
    let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
      return l:str
    endif

    return toupper(l:str[0]) . l:str[1:]
endfunction
```

Напомню, что аргумент для функции `capitalize()`, `a:string`, это отдельное слово, переданное оператором `g@`. Так что если я запускаю `gt` на тексте "блинчик на завтрак", `ToTitle` вызовет `capitalize(string)` *три* раза, один раз для "блинчик", один раз для "на", и один раз для "завтрак".

Первая часть функции:

```shell
if(toupper(a:string) ==# a:string && a:string != 'A')
  return a:string
endif
```

Первое условие (`toupper(a:string) ==# a:string`) проверяет, совпадает ли верхний регистр аргумента с строкой и является ли сама строка "A". Если это верно, то возвращается эта строка. Это основано на предположении, что если данное слово уже полностью написано заглавными буквами, то это аббревиатура. Например, слово "CEO" в противном случае будет преобразовано в "Ceo". Хм, вашему CEO это не понравится. Поэтому лучше оставить любое полностью заглавное слово в покое. Второе условие, `a:string != 'A'`, учитывает крайний случай для заглавной буквы "A". Если `a:string` уже является заглавной "A", она случайно прошла тест `toupper(a:string) ==# a:string`. Поскольку "a" является неопределённым артиклем в английском, его нужно привести к нижнему регистру.

Следующая часть принуждает строку к нижнему регистру:

```shell
let l:str = tolower(a:string)
```

Следующая часть — это регулярное выражение списка всех исключений слов. Я взял их с https://titlecaseconverter.com/rules/ :

```shell
let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
```

Следующая часть:

```shell
if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
  return l:str
endif
```

Сначала проверьте, является ли ваша строка частью списка исключённых слов (`l:exclusions`). Если это так, не капитализируйте её. Затем проверьте, является ли ваша строка частью локального списка исключений (`s:local_exclusion_list`). Этот список исключений — это пользовательский список, который пользователь может добавить в vimrc (в случае, если у пользователя есть дополнительные требования к специальным словам).

Последняя часть возвращает капитализированную версию слова. Первый символ становится заглавным, в то время как остальная часть остаётся без изменений.

```shell
return toupper(l:str[0]) . l:str[1:]
```

Давайте рассмотрим вторую функцию капитализации. Функция выглядит так:

```shell
function! s:capitalizeFirstWord(string)
  if (a:string =~ "\n")
    let l:lineArr = trim(a:string)->split('\n')
    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
    return l:lineArr->join("\n")
  endif
  return toupper(a:string[0]) . a:string[1:]
endfunction
```

Эта функция была создана для обработки крайнего случая, если у вас есть предложение, начинающееся с исключённого слова, например "ан яблоко в день держит врача подальше". Согласно правилам капитализации в английском языке, все первые слова в предложении, независимо от того, являются ли они специальными словами или нет, должны быть написаны с заглавной буквы. С помощью вашей команды `substitute()` одно "ан" в вашем предложении было бы приведено к нижнему регистру. Вам нужно принудительно сделать первый символ заглавным.

В этой функции `capitalizeFirstWord` аргумент `a:string` не является отдельным словом, как `a:string` внутри функции `capitalize`, а вместо этого представляет собой весь текст. Так что если у вас есть "блинчик на завтрак", значение `a:string` — это "блинчик на завтрак". Она выполняется только один раз для всего текста.

Одним из сценариев, на который вам нужно обратить внимание, является наличие многострочной строки, такой как `"ан яблоко в день\nдержит врача подальше"`. Вы хотите сделать заглавным первый символ всех строк. Если у вас нет переносов строк, просто сделайте заглавным первый символ.

```shell
return toupper(a:string[0]) . a:string[1:]
```

Если у вас есть переносы строк, вам нужно сделать заглавными все первые символы в каждой строке, поэтому вы разбиваете их на массив, разделённый переносами строк:

```shell
let l:lineArr = trim(a:string)->split('\n')
```

Затем вы применяете к каждому элементу массива и капитализируете первое слово каждого элемента:

```shell
let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
```

Наконец, вы собираете элементы массива вместе:

```shell
return l:lineArr->join("\n")
```

И вы закончили!

## Документация

Вторая директория в репозитории — это директория `docs/`. Хорошо предоставить плагину подробную документацию. В этом разделе я кратко расскажу, как создать свою собственную документацию для плагина.

Директория `docs/` является одной из специальных путей выполнения Vim. Vim читает все файлы внутри `docs/`, поэтому, когда вы ищете специальное ключевое слово и это слово найдено в одном из файлов в директории `docs/`, оно будет отображено на странице справки. Здесь у вас есть `totitle.txt`. Я назвал его так, потому что это имя плагина, но вы можете назвать его как угодно.

Файл документации Vim по сути является текстовым файлом. Разница между обычным текстовым файлом и файлом справки Vim заключается в том, что последний использует специальные синтаксисы "справки". Но сначала вам нужно сказать Vim, чтобы он рассматривал его не как текстовый файл, а как файл типа `help`. Чтобы сказать Vim интерпретировать этот `totitle.txt` как *файл справки*, выполните `:set ft=help` (`:h 'filetype'` для получения дополнительной информации). Кстати, если вы хотите сказать Vim интерпретировать этот `totitle.txt` как *обычный* текстовый файл, выполните `:set ft=txt`.

### Специальный Синтаксис Файла Справки

Чтобы сделать ключевое слово доступным для поиска, окружите это ключевое слово звёздочками. Чтобы сделать ключевое слово `totitle` доступным для поиска, когда пользователь ищет `:h totitle`, напишите его как `*totitle*` в файле справки.

Например, у меня есть эти строки вверху моего оглавления:

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

// больше информации об оглавлении
```

Обратите внимание, что я использовал два ключевых слова: `*totitle*` и `*totitle-toc*`, чтобы отметить раздел оглавления. Вы можете использовать столько ключевых слов, сколько хотите. Это означает, что каждый раз, когда вы ищете либо `:h totitle`, либо `:h totitle-toc`, Vim перенаправит вас в это место.

Вот ещё один пример, где-то внизу файла:

```shell
2. Использование                                                       *totitle-usage*

// использование
```

Если вы ищете `:h totitle-usage`, Vim перенаправит вас в этот раздел.

Вы также можете использовать внутренние ссылки, чтобы сослаться на другой раздел в файле справки, окружив ключевое слово синтаксисом с вертикальной чертой `|`. В разделе оглавления вы видите ключевые слова, окружённые вертикальными чертами, такие как `|totitle-intro|`, `|totitle-usage|` и т.д.

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

    1. Введение ........................... |totitle-intro|
    2. Использование ........................... |totitle-usage|
    3. Слова для капитализации ............. |totitle-words|
    4. Оператор ........................ |totitle-operator|
    5. Привязка клавиш ..................... |totitle-keybinding|
    6. Ошибки ............................ |totitle-bug-report|
    7. Участие .................... |totitle-contributing|
    8. Благодарности ......................... |totitle-credits|

```
Это позволяет вам перейти к определению. Если вы поставите курсор где-то на `|totitle-intro|` и нажмёте `Ctrl-]`, Vim перейдёт к определению этого слова. В этом случае он перейдёт к месту `*totitle-intro*`. Вот как вы можете связывать разные ключевые слова в справочной документации.

Нет правильного или неправильного способа написания документации в Vim. Если вы посмотрите на разные плагины от разных авторов, многие из них используют разные форматы. Главное — сделать понятную документацию для ваших пользователей.

Наконец, если вы сначала пишете свой собственный плагин локально и хотите протестировать страницу документации, просто добавление текстового файла в `~/.vim/docs/` не сделает ваши ключевые слова автоматически доступными для поиска. Вам нужно указать Vim добавить вашу страницу документации. Выполните команду helptags: `:helptags ~/.vim/doc`, чтобы создать новые файлы тегов. Теперь вы можете начать искать свои ключевые слова.

## Заключение

Вы дошли до конца! Эта глава является объединением всех глав по Vimscript. Здесь вы, наконец, применяете на практике то, что узнали до сих пор. Надеюсь, прочитав это, вы поняли не только, как создавать плагины Vim, но и получили стимул написать свой собственный плагин.

Каждый раз, когда вы обнаруживаете, что повторяете одну и ту же последовательность действий несколько раз, вам следует попробовать создать свой собственный! Говорят, что не стоит изобретать велосипед. Однако я думаю, что может быть полезно заново изобрести велосипед ради обучения. Читайте плагины других людей. Воссоздавайте их. Учитесь у них. Пишите свои собственные! Кто знает, возможно, вы напишете следующий потрясающий, суперпопулярный плагин после прочтения этого. Возможно, вы станете следующим легендарным Тимом Поупом. Когда это произойдёт, дайте мне знать!