---
description: В этом документе рассматриваются различные способы редактирования нескольких
  файлов в Vim с использованием команд для выполнения операций в нескольких списках.
title: Ch21. Multiple File Operations
---

Возможность обновления в нескольких файлах — это еще один полезный инструмент редактирования. Ранее вы узнали, как обновлять несколько текстов с помощью `cfdo`. В этой главе вы узнаете о различных способах редактирования нескольких файлов в Vim.

## Разные способы выполнения команды в нескольких файлах

Vim имеет восемь способов выполнения команд в нескольких файлах:
- список аргументов (`argdo`)
- список буферов (`bufdo`)
- список окон (`windo`)
- список вкладок (`tabdo`)
- список quickfix (`cdo`)
- список quickfix по файлам (`cfdo`)
- список местоположений (`ldo`)
- список местоположений по файлам (`lfdo`)

Практически, вы, вероятно, будете использовать только один или два из них большую часть времени (я лично использую `cdo` и `argdo` чаще других), но полезно узнать о всех доступных вариантах и использовать те, которые соответствуют вашему стилю редактирования.

Изучение восьми команд может показаться пугающим. Но на самом деле эти команды работают аналогично. После изучения одной, изучение остальных станет проще. Все они имеют одну общую идею: составить список своих соответствующих категорий, а затем передать им команду, которую вы хотите выполнить.

## Список аргументов

Список аргументов — это самый базовый список. Он создает список файлов. Чтобы создать список file1, file2 и file3, вы можете выполнить:

```shell
:args file1 file2 file3
```

Вы также можете передать ему подстановочный знак (`*`), так что если вы хотите создать список всех `.js` файлов в текущем каталоге, выполните:

```shell
:args *.js
```

Если вы хотите создать список всех файлов Javascript, начинающихся с "a" в текущем каталоге, выполните:

```shell
:args a*.js
```

Подстановочный знак соответствует одному или нескольким символам имени файла в текущем каталоге, но что если вам нужно искать рекурсивно в любом каталоге? Вы можете использовать двойной подстановочный знак (`**`). Чтобы получить все файлы Javascript внутри каталогов в вашем текущем местоположении, выполните:

```shell
:args **/*.js
```

После выполнения команды `args` ваш текущий буфер будет переключен на первый элемент в списке. Чтобы просмотреть список файлов, который вы только что создали, выполните `:args`. Как только вы создали свой список, вы можете перемещаться по ним. `:first` переместит вас на первый элемент в списке. `:last` переместит вас на последний элемент в списке. Чтобы перемещаться по списку вперед по одному файлу за раз, выполните `:next`. Чтобы перемещаться по списку назад по одному файлу за раз, выполните `:prev`. Чтобы перемещаться вперед / назад по одному файлу за раз и сохранять изменения, выполните `:wnext` и `:wprev`. Существует множество других команд навигации. Ознакомьтесь с `:h arglist` для получения дополнительной информации.

Список аргументов полезен, если вам нужно нацелиться на конкретный тип файла или несколько файлов. Возможно, вам нужно обновить все "donut" на "pancake" во всех `yml` файлах, вы можете сделать это:

```shell
:args **/*.yml
:argdo %s/donut/pancake/g | update
```

Если вы снова выполните команду `args`, она заменит предыдущий список. Например, если вы ранее выполнили:

```shell
:args file1 file2 file3
```

Предполагая, что эти файлы существуют, у вас теперь есть список `file1`, `file2` и `file3`. Затем вы выполняете это:

```shell
:args file4 file5
```

Ваш первоначальный список `file1`, `file2` и `file3` заменяется на `file4` и `file5`. Если у вас есть `file1`, `file2` и `file3` в вашем списке аргументов, и вы хотите *добавить* `file4` и `file5` в свой первоначальный список файлов, используйте команду `:arga`. Выполните:

```shell
:arga file4 file5
```

Теперь у вас есть `file1`, `file2`, `file3`, `file4` и `file5` в вашем списке аргументов.

Если вы выполните `:arga` без каких-либо аргументов, Vim добавит ваш текущий буфер в текущий список аргументов. Если у вас уже есть `file1`, `file2` и `file3` в вашем списке аргументов, и ваш текущий буфер находится на `file5`, выполнение `:arga` добавит `file5` в список.

Как только у вас есть список, вы можете передать его с любыми командами командной строки по вашему выбору. Вы видели, как это делается с помощью замены (`:argdo %s/donut/pancake/g`). Некоторые другие примеры:
- Чтобы удалить все строки, содержащие "dessert" в списке аргументов, выполните `:argdo g/dessert/d`.
- Чтобы выполнить макрос a (предполагая, что вы записали что-то в макрос a) в списке аргументов, выполните `:argdo norm @a`.
- Чтобы записать "hello " с именем файла на первой строке, выполните `:argdo 0put='hello ' .. @:`.

Когда вы закончите, не забудьте сохранить их с помощью `:update`.

Иногда вам нужно выполнять команды только на первых n элементах списка аргументов. Если это так, просто передайте команде `argdo` адрес. Например, чтобы выполнить команду замены только на первых 3 элементах из списка, выполните `:1,3argdo %s/donut/pancake/g`.

## Список буферов

Список буферов будет органически создан, когда вы редактируете новые файлы, потому что каждый раз, когда вы создаете новый файл / открываете файл, Vim сохраняет его в буфере (если вы явно его не удалите). Так что если вы уже открыли 3 файла: `file1.rb file2.rb file3.rb`, у вас уже есть 3 элемента в вашем списке буферов. Чтобы отобразить список буферов, выполните `:buffers` (в качестве альтернативы: `:ls` или `:files`). Чтобы перемещаться вперед и назад, используйте `:bnext` и `:bprev`. Чтобы перейти к первому и последнему буферу из списка, используйте `:bfirst` и `:blast` (все еще веселитесь? :D).

Кстати, вот классный трюк с буфером, не относящийся к этой главе: если у вас есть несколько элементов в вашем списке буферов, вы можете показать все из них с помощью `:ball` (все буферы). Команда `ball` отображает все буферы горизонтально. Чтобы отобразить их вертикально, выполните `:vertical ball`.

Вернемся к теме, механика выполнения операций по всем буферам аналогична списку аргументов. Как только вы создали свой список буферов, вам просто нужно предварить команды, которые вы хотите выполнить, с помощью `:bufdo` вместо `:argdo`. Так что если вы хотите заменить все "donut" на "pancake" во всех буферах и затем сохранить изменения, выполните `:bufdo %s/donut/pancake/g | update`.

## Список окон и вкладок

Списки окон и вкладок также аналогичны спискам аргументов и буферов. Единственные различия — это их контекст и синтаксис.

Операции с окнами выполняются в каждом открытом окне и выполняются с помощью `:windo`. Операции с вкладками выполняются в каждой открытой вами вкладке и выполняются с помощью `:tabdo`. Для получения дополнительной информации ознакомьтесь с `:h list-repeat`, `:h :windo` и `:h :tabdo`.

Например, если у вас открыто три окна (вы можете открыть новые окна с помощью `Ctrl-W v` для вертикального окна и `Ctrl-W s` для горизонтального окна) и вы выполните `:windo 0put ='hello' . @%`, Vim выведет "hello" + имя файла во все открытые окна.

## Список Quickfix

В предыдущих главах (Ch3 и Ch19) я говорил о quickfix. Quickfix имеет много применений. Многие популярные плагины используют quickfix, поэтому полезно потратить больше времени на их понимание.

Если вы новичок в Vim, quickfix может быть для вас новым понятием. В старые времена, когда вам действительно приходилось явно компилировать свой код, во время компиляции вы сталкивались с ошибками. Чтобы отобразить эти ошибки, вам нужно было специальное окно. Вот тут и появляется quickfix. Когда вы компилируете свой код, Vim отображает сообщения об ошибках в окне quickfix, чтобы вы могли исправить их позже. Многие современные языки больше не требуют явной компиляции, но это не делает quickfix устаревшим. В наши дни люди используют quickfix для самых разных вещей, таких как отображение вывода виртуального терминала и хранение результатов поиска. Давайте сосредоточимся на последнем, хранении результатов поиска.

В дополнение к командам компиляции некоторые команды Vim полагаются на интерфейсы quickfix. Один тип команд, который сильно использует quickfix, — это команды поиска. Оба `:vimgrep` и `:grep` по умолчанию используют quickfix.

Например, если вам нужно искать "donut" во всех Javascript файлах рекурсивно, вы можете выполнить:

```shell
:vimgrep /donut/ **/*.js
```

Результат поиска "donut" хранится в окне quickfix. Чтобы увидеть результаты совпадений в окне quickfix, выполните:

```shell
:copen
```

Чтобы закрыть его, выполните:

```shell
:cclose
```

Чтобы перемещаться по списку quickfix вперед и назад, выполните:

```shell
:cnext
:cprev
```

Чтобы перейти к первому и последнему элементу в совпадениях, выполните:

```shell
:cfirst
:clast
```

Ранее я упоминал, что есть две команды quickfix: `cdo` и `cfdo`. Как они отличаются? `cdo` выполняет команду для каждого элемента в списке quickfix, в то время как `cfdo` выполняет команду для каждого *файла* в списке quickfix.

Позвольте мне пояснить. Предположим, что после выполнения команды `vimgrep` выше вы нашли:
- 1 результат в `file1.js`
- 10 результатов в `file2.js`

Если вы выполните `:cfdo %s/donut/pancake/g`, это фактически выполнит `%s/donut/pancake/g` один раз в `file1.js` и один раз в `file2.js`. Это выполняется *столько раз, сколько файлов в совпадениях.* Поскольку в результатах два файла, Vim выполняет команду замены один раз для `file1.js` и еще раз для `file2.js`, несмотря на то, что в втором файле 10 совпадений. `cfdo` заботится только о том, сколько всего файлов в списке quickfix.

Если вы выполните `:cdo %s/donut/pancake/g`, это фактически выполнит `%s/donut/pancake/g` один раз в `file1.js` и *десять раз* в `file2.js`. Это выполняется столько раз, сколько фактических элементов в списке quickfix. Поскольку в `file1.js` найдено только одно совпадение, а в `file2.js` найдено 10 совпадений, это будет выполнено всего 11 раз.

Поскольку вы выполнили `%s/donut/pancake/g`, имеет смысл использовать `cfdo`. Не имело смысла использовать `cdo`, потому что это выполняло бы `%s/donut/pancake/g` десять раз в `file2.js` (`%s` — это замена по всему файлу). Выполнение `%s` один раз для каждого файла достаточно. Если бы вы использовали `cdo`, имело бы больше смысла передать его с `s/donut/pancake/g` вместо этого.

При принятии решения о том, использовать ли `cfdo` или `cdo`, подумайте о области команды, которую вы передаете. Это команда, действующая на весь файл (например, `:%s` или `:g`), или это команда, действующая по строкам (например, `:s` или `:!`)?

## Список местоположений

Список местоположений аналогичен списку quickfix в том смысле, что Vim также использует специальное окно для отображения сообщений. Разница между списком quickfix и списком местоположений заключается в том, что в любое время у вас может быть только один список quickfix, в то время как у вас может быть столько списков местоположений, сколько окон.

Предположим, что у вас открыты два окна, одно окно отображает `food.txt`, а другое — `drinks.txt`. Изнутри `food.txt` вы выполняете команду поиска в списке местоположений `:lvimgrep` (вариант местоположения для команды `:vimgrep`):

```shell
:lvim /bagel/ **/*.md
```

Vim создаст список местоположений всех совпадений поиска bagel для этого *окна* `food.txt`. Вы можете увидеть список местоположений с помощью `:lopen`. Теперь перейдите в другое окно `drinks.txt` и выполните:

```shell
:lvimgrep /milk/ **/*.md
```

Vim создаст *отдельный* список местоположений со всеми результатами поиска молока для этого *окна* `drinks.txt`.

Для каждой команды местоположения, которую вы выполняете в каждом окне, Vim создает отдельный список местоположений. Если у вас есть 10 разных окон, вы можете иметь до 10 разных списков местоположений. В отличие от списка quickfix, где у вас может быть только один в любое время. Если у вас есть 10 разных окон, у вас все равно будет только один список quickfix.

Большинство команд списка местоположений аналогичны командам quickfix, за исключением того, что они предваряются `l-`. Например: `:lvimgrep`, `:lgrep` и `:lmake` против `:vimgrep`, `:grep` и `:make`. Чтобы управлять окном списка местоположений, команды также выглядят аналогично командам quickfix `:lopen`, `:lclose`, `:lfirst`, `:llast`, `:lnext` и `:lprev` против `:copen`, `:cclose`, `:cfirst`, `:clast`, `:cnext` и `:cprev`.

Две многофайловые команды списка местоположений также аналогичны многофайловым командам quickfix: `:ldo` и `:lfdo`. `:ldo` выполняет команду местоположения в каждом списке местоположений, в то время как `:lfdo` выполняет команду списка местоположений для каждого файла в списке местоположений. Для получения дополнительной информации ознакомьтесь с `:h location-list`.
## Выполнение операций с несколькими файлами в Vim

Знание того, как выполнять операции с несколькими файлами, является полезным навыком в редактировании. Каждый раз, когда вам нужно изменить имя переменной в нескольких файлах, вы хотите выполнить это одним махом. В Vim есть восемь различных способов сделать это.

Практически говоря, вы, вероятно, не будете использовать все восемь в равной степени. Вы будете склоняться к одному или двум. Когда вы только начинаете, выберите один (я лично рекомендую начать с аргументного списка `:argdo`) и овладейте им. Как только вы почувствуете себя уверенно с одним, изучите следующий. Вы обнаружите, что изучение второго, третьего, четвертого становится легче. Будьте креативны. Используйте это с различными комбинациями. Продолжайте практиковаться, пока не сможете делать это без усилий и без особых размышлений. Сделайте это частью вашей мышечной памяти.

Сказав это, вы овладели редактированием в Vim. Поздравляю!