---
description: هذا المستند يشرح كيفية كتابة ملحق Vim الخاص بك، مع التركيز على ملحق "totitle-vim"
  الذي يقوم بتحويل النص إلى حالة العنوان بشكل تلقائي.
title: 'Ch29. Write a Plugin: Creating a Titlecase Operator'
---

عندما تبدأ في إتقان Vim، قد ترغب في كتابة الإضافات الخاصة بك. لقد كتبت مؤخرًا أول إضافة لي لـ Vim، [totitle-vim](https://github.com/iggredible/totitle-vim). إنها إضافة مشغل لحالة العنوان، مشابهة لمشغلات Vim للحروف الكبيرة `gU`، والحروف الصغيرة `gu`، وتبديل الحالة `g~`.

في هذا الفصل، سأقدم تحليلًا لإضافة `totitle-vim`. آمل أن أضيء بعض الجوانب في العملية وقد ألهمك لإنشاء إضافتك الفريدة الخاصة!

## المشكلة

أستخدم Vim لكتابة مقالاتي، بما في ذلك هذا الدليل.

كانت إحدى المشكلات الرئيسية هي إنشاء حالة عنوان مناسبة للعناوين. إحدى الطرق لأتمتة ذلك هي كتابة كل كلمة في العنوان بحروف كبيرة باستخدام `g/^#/ s/\<./\u\0/g`. بالنسبة للاستخدام الأساسي، كانت هذه الأوامر كافية، لكنها لا تزال ليست جيدة مثل وجود حالة عنوان فعلية. يجب أن تكون الكلمات "The" و "Of" في "Capitalize The First Letter Of Each Word" بحروف كبيرة. بدون كتابة صحيحة، تبدو الجملة غير صحيحة قليلاً.

في البداية، لم أكن أنوي كتابة إضافة. كما اتضح أن هناك إضافة لحالة العنوان بالفعل: [vim-titlecase](https://github.com/christoomey/vim-titlecase). ومع ذلك، كان هناك بعض الأشياء التي لم تعمل بالطريقة التي أردتها. كانت المشكلة الرئيسية هي سلوك وضع التحديد الكتلي. إذا كان لدي العبارة:

```shell
test title one
test title two
test title three
```

إذا استخدمت تمييزًا بصريًا كتليًا على "tle":

```shell
test ti[tle] one
test ti[tle] two
test ti[tle] three
```

إذا ضغطت على `gt`، فلن تقوم الإضافة بتحويلها إلى حالة عنوان. أجد أن هذا غير متسق مع سلوكيات `gu` و `gU` و `g~`. لذا قررت العمل من مستودع تلك الإضافة لحالة العنوان واستخدامها لإنشاء إضافة لحالة عنوان بنفسي تتماشى مع `gu` و `gU` و `g~`!. مرة أخرى، تعتبر إضافة vim-titlecase إضافة ممتازة وتستحق الاستخدام بمفردها (الحقيقة هي، ربما في أعماقي كنت أرغب فقط في كتابة إضافتي الخاصة لـ Vim. لا أستطيع حقًا رؤية ميزة تحويل حالة العنوان الكتلي تُستخدم كثيرًا في الحياة الواقعية بخلاف الحالات النادرة).

### التخطيط للإضافة

قبل كتابة السطر الأول من الكود، أحتاج إلى تحديد قواعد حالة العنوان. وجدت جدولًا رائعًا لقواعد الكتابة بحروف كبيرة المختلفة من موقع [titlecaseconverter](https://titlecaseconverter.com/rules/). هل كنت تعلم أن هناك على الأقل 8 قواعد مختلفة للكتابة بحروف كبيرة في اللغة الإنجليزية؟ *آه!*

في النهاية، استخدمت القواسم المشتركة من تلك القائمة للتوصل إلى قاعدة أساسية جيدة بما يكفي للإضافة. بالإضافة إلى أنني أشك في أن الناس سيشتكون، "يا رجل، أنت تستخدم AMA، لماذا لا تستخدم APA؟". إليك القواعد الأساسية:
- الكلمة الأولى دائمًا بحروف كبيرة.
- بعض الظروف، والروابط، وحروف الجر تُكتب بحروف صغيرة.
- إذا كانت الكلمة المدخلة مكتوبة بالكامل بحروف كبيرة، فلا تفعل شيئًا (قد تكون اختصارًا).

أما بالنسبة للكلمات التي تُكتب بحروف صغيرة، فالقواعد المختلفة لديها قوائم مختلفة. قررت الالتزام بـ `a an and at but by en for in nor of off on or out per so the to up yet vs via`.

### التخطيط لواجهة المستخدم

أريد أن تكون الإضافة مشغلًا لتكمل مشغلات الحالة الموجودة في Vim: `gu` و `gU` و `g~`. كونها مشغلًا، يجب أن تقبل إما حركة أو كائن نصي (`gtw` يجب أن يحول الكلمة التالية إلى حالة عنوان، `gtiw` يجب أن يحول الكلمة الداخلية إلى حالة عنوان، `gt$` يجب أن يحول الكلمات من الموقع الحالي حتى نهاية السطر، `gtt` يجب أن يحول السطر الحالي إلى حالة عنوان، `gti(` يجب أن يحول الكلمات داخل الأقواس، إلخ). أريد أيضًا أن يتم تعيينها على `gt` لتسهيل التذكر. علاوة على ذلك، يجب أن تعمل مع جميع الأوضاع البصرية: `v` و `V` و `Ctrl-V`. يجب أن أكون قادرًا على تمييزها في *أي* وضع بصري، ثم الضغط على `gt`، ثم سيتم تحويل جميع النصوص المميزة إلى حالة عنوان.

## وقت تشغيل Vim

أول شيء تراه عند النظر إلى المستودع هو أنه يحتوي على دليلين: `plugin/` و `doc/`. عندما تبدأ Vim، تبحث عن ملفات ودلائل خاصة داخل دليل `~/.vim` وتقوم بتشغيل جميع ملفات السكريبت داخل ذلك الدليل. لمزيد من المعلومات، راجع فصل وقت تشغيل Vim.

تستخدم الإضافة دليلين من وقت تشغيل Vim: `doc/` و `plugin/`. `doc/` هو مكان لوضع وثائق المساعدة (حتى تتمكن من البحث عن الكلمات الرئيسية لاحقًا، مثل `:h totitle`). سأشرح كيفية إنشاء صفحة مساعدة لاحقًا. في الوقت الحالي، دعنا نركز على `plugin/`. يتم تنفيذ دليل `plugin/` مرة واحدة عند بدء تشغيل Vim. يوجد ملف واحد داخل هذا الدليل: `totitle.vim`. لا تهم التسمية (يمكنني تسميته `whatever.vim` وستظل تعمل). كل الكود المسؤول عن عمل الإضافة موجود داخل هذا الملف.

## التعيينات

دعنا نمر عبر الكود!

في بداية الملف، لديك:

```shell
if !exists('g:totitle_default_keys')
  let g:totitle_default_keys = 1
endif
```

عندما تبدأ Vim، لن يوجد `g:totitle_default_keys` بعد، لذا فإن `!exists(...)` تعود صحيحة. في هذه الحالة، قم بتعريف `g:totitle_default_keys` ليكون 1. في Vim، 0 تعتبر غير صحيحة و القيمة غير الصفرية تعتبر صحيحة (استخدم 1 للإشارة إلى الصحة).

دعنا ننتقل إلى أسفل الملف. سترى هذا:

```shell
if g:totitle_default_keys
  nnoremap <expr> gt ToTitle()
  xnoremap <expr> gt ToTitle()
  nnoremap <expr> gtt ToTitle() .. '_'
endif
```

هنا يتم تعريف التعيين الرئيسي لـ `gt`. في هذه الحالة، بحلول الوقت الذي تصل فيه إلى الشرط `if` في أسفل الملف، ستعود `if g:totitle_default_keys` بـ 1 (صحيحة)، لذا يقوم Vim بتنفيذ التعيينات التالية:
- `nnoremap <expr> gt ToTitle()` يعيّن مشغل وضع عادي. هذا يتيح لك تشغيل المشغل + الحركة/كائن النص مثل `gtw` لتحويل الكلمة التالية إلى حالة عنوان أو `gtiw` لتحويل الكلمة الداخلية إلى حالة عنوان. سأشرح تفاصيل كيفية عمل تعيين المشغل لاحقًا.
- `xnoremap <expr> gt ToTitle()` يعيّن مشغلات وضع التحديد البصري. هذا يتيح لك تحويل النصوص المميزة بصريًا إلى حالة عنوان.
- `nnoremap <expr> gtt ToTitle() .. '_'` يعيّن مشغل وضع عادي على مستوى السطر (مماثل لـ `guu` و `gUU`). قد تتساءل عما تفعله `.. '_'` في النهاية. `..` هو مشغل دمج السلاسل في Vim. `_` يستخدم كحركة مع مشغل. إذا نظرت في `:help _`، ستجد أن الخط السفلي يستخدم للعد 1 سطر للأسفل. إنه ينفذ مشغلًا على السطر الحالي (جربه مع مشغلات أخرى، جرب تشغيل `gU_` أو `d_`، ولاحظ أنه يقوم بنفس الشيء مثل `gUU` أو `dd`).
- أخيرًا، يسمح لك الوسيط `<expr>` بتحديد العدد، لذا يمكنك القيام بـ `3gtw` لتحويل الحالة إلى حالة عنوان لـ 3 كلمات.

ماذا لو كنت لا تريد استخدام تعيين `gt` الافتراضي؟ بعد كل شيء، أنت تتجاوز تعيين `gt` الافتراضي في Vim (التبويب التالي). ماذا لو كنت تريد استخدام `gz` بدلاً من `gt`؟ تذكر كيف مررت سابقًا بمشكلة التحقق من `if !exists('g:totitle_default_keys')` و `if g:totitle_default_keys`؟ إذا وضعت `let g:totitle_default_keys = 0` في ملف vimrc الخاص بك، فسيكون `g:totitle_default_keys` موجودًا بالفعل عندما يتم تشغيل الإضافة (يتم تنفيذ الأكواد في ملف vimrc الخاص بك قبل ملفات وقت تشغيل `plugin/`)، لذا فإن `!exists('g:totitle_default_keys')` تعود خاطئة. علاوة على ذلك، ستكون `if g:totitle_default_keys` غير صحيحة (لأنها ستكون بقيمة 0)، لذا لن يتم تنفيذ تعيين `gt` أيضًا! هذا يتيح لك بشكل فعال تعريف تعيين مخصص خاص بك في Vimrc.

لتعريف تعيين حالة عنوان خاص بك إلى `gz`، أضف هذا في ملف vimrc الخاص بك:

```shell
let g:totitle_default_keys = 0

nnoremap <expr> gz ToTitle()
xnoremap <expr> gz ToTitle()
nnoremap <expr> gzz ToTitle() .. '_'
```

سهل جدًا.

## دالة ToTitle

دالة `ToTitle()` هي بسهولة أطول دالة في هذا الملف.

```shell
 function! ToTitle(type = '')
  if a:type ==# ''
    set opfunc=ToTitle
    return 'g@'
  endif

  " invoke this when calling the ToTitle() function
  if a:type != 'block' && a:type != 'line' && a:type != 'char'
    let l:words = a:type
    let l:wordsArr = trim(l:words)->split('\s\+')
    call map(l:wordsArr, 's:capitalize(v:val)')
    return l:wordsArr->join(' ')
  endif

  " save the current settings
  let l:sel_save = &selection
  let l:reg_save = getreginfo('"')
  let l:cb_save = &clipboard
  let l:visual_marks_save = [getpos("'<"), getpos("'>")]

  try
    set clipboard= selection=inclusive
    let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
    let l:selected_phrase = getreg('"')
    let l:WORD_PATTERN = '\<\k*\>'
    let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

    let l:startLine = line("'<")
    let l:startCol = virtcol(".")

    " when user calls a block operation
    if a:type ==# "block"
      sil! keepj norm! gv"ad
      keepj $
      keepj pu_

      let l:lastLine = line("$")

      sil! keepj norm "ap

      let l:curLine = line(".")

      sil! keepj norm! VGg@
      exe "keepj norm! 0\<c-v>G$h\"ad"
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
      exe "keepj " . l:lastLine
      sil! keepj norm! "_dG
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"

    " when user calls a char or line operation
    else
      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
      let l:titlecased = s:capitalizeFirstWord(l:titlecased)
      call setreg('"', l:titlecased)
      let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
      silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"
    endif
  finally

    " restore the settings
    call setreg('"', l:reg_save)
    call setpos("'<", l:visual_marks_save[0])
    call setpos("'>", l:visual_marks_save[1])
    let &clipboard = l:cb_save
    let &selection = l:sel_save
  endtry
  return
endfunction
```

هذه دالة طويلة جدًا، لذا دعنا نقسمها. 

*يمكنني إعادة هيكلة هذا إلى أقسام أصغر، لكن من أجل إكمال هذا الفصل، تركته كما هو.*
## دالة المشغل

إليك الجزء الأول من الكود:

```shell
if a:type ==# ''
  set opfunc=ToTitle
  return 'g@'
endif
```

ما هو `opfunc` بحق الجحيم؟ لماذا يُرجع `g@`؟

يمتلك Vim مشغلًا خاصًا، وهو دالة المشغل، `g@`. يتيح لك هذا المشغل استخدام *أي* دالة مُعينة لخيار `opfunc`. إذا كان لدي الدالة `Foo()` مُعينة لـ `opfunc`، فعندما أستخدم `g@w`، أكون قد قمت بتشغيل `Foo()` على الكلمة التالية. إذا استخدمت `g@i(`، فأنا أشغل `Foo()` على الأقواس الداخلية. تعتبر دالة المشغل هذه حاسمة لإنشاء مشغل Vim الخاص بك.

السطر التالي يُعين `opfunc` إلى دالة `ToTitle`.

```shell
set opfunc=ToTitle
```

السطر التالي يُرجع حرفيًا `g@`:

```shell
return g@
```

فكيف تعمل هذان السطران بالضبط ولماذا يُرجع `g@`؟

دعنا نفترض أنك تمتلك الخريطة التالية:

```shell
nnoremap <expr> gt ToTitle()`
```

ثم تضغط على `gtw` (تغيير حالة الكلمة التالية إلى عنوان). في المرة الأولى التي تستخدم فيها `gtw`، يقوم Vim باستدعاء دالة `ToTitle()`. ولكن في هذه اللحظة، لا يزال `opfunc` فارغًا. أنت أيضًا لا تمرر أي وسيط إلى `ToTitle()`، لذا سيكون لقيمة `a:type` قيمة `''`. هذا يتسبب في أن تعبير الشرط يتحقق من الوسيط `a:type`، `if a:type ==# ''`، ليكون صحيحًا. في الداخل، تقوم بتعيين `opfunc` إلى دالة `ToTitle` باستخدام `set opfunc=ToTitle`. الآن تم تعيين `opfunc` إلى `ToTitle`. أخيرًا، بعد أن قمت بتعيين `opfunc` إلى دالة `ToTitle`، تُرجع `g@`. سأشرح لماذا يُرجع `g@` أدناه.

لم تنته بعد. تذكر، لقد ضغطت للتو على `gtw`. الضغط على `gt` قام بكل الأشياء أعلاه، لكن لا يزال لديك `w` لتعالجه. من خلال إرجاع `g@`، في هذه المرحلة، لديك تقنيًا `g@w` (لهذا السبب لديك `return g@`). نظرًا لأن `g@` هو مشغل الدالة، فإنك تمرر له حركة `w`. لذا، عند استلام `g@w`، يقوم Vim باستدعاء `ToTitle` *مرة أخرى* (لا تقلق، لن تنتهي في حلقة لانهائية كما سترى بعد قليل).

لتلخيص، من خلال الضغط على `gtw`، يتحقق Vim مما إذا كان `opfunc` فارغًا أم لا. إذا كان فارغًا، فإن Vim سيعينه إلى `ToTitle`. ثم يُرجع `g@`، مما يعني أنه يستدعي `ToTitle` مرة أخرى حتى تتمكن من استخدامه كمشغل. هذه هي أصعب جزء في إنشاء مشغل مخصص وقد فعلتها! بعد ذلك، تحتاج إلى بناء المنطق لـ `ToTitle()` لجعلها تقوم بتغيير حالة الإدخال إلى عنوان.

## معالجة الإدخال

الآن لديك `gt` يعمل كمشغل ينفذ `ToTitle()`. لكن ماذا تفعل بعد ذلك؟ كيف تقوم فعليًا بتغيير حالة النص إلى عنوان؟

عندما تقوم بتشغيل أي مشغل في Vim، هناك ثلاثة أنواع مختلفة من حركات الإجراءات: حرف، سطر، وكتلة. `g@w` (كلمة) هو مثال على عملية حرفية. `g@j` (سطر واحد أسفل) هو مثال على عملية سطر. عملية الكتلة نادرة، ولكن عادةً عندما تقوم بعملية `Ctrl-V` (كتلة مرئية)، سيتم اعتبارها كعملية كتلة. العمليات التي تستهدف عددًا قليلاً من الأحرف للأمام / للخلف تُعتبر عمومًا عمليات حرفية (`b`، `e`، `w`، `ge`، إلخ). العمليات التي تستهدف عددًا قليلاً من الأسطر للأسفل / للأعلى تُعتبر عمومًا عمليات سطر (`j`، `k`). العمليات التي تستهدف الأعمدة للأمام، للخلف، للأعلى، أو للأسفل تُعتبر عمومًا عمليات كتلة (عادةً ما تكون إما حركة عمودية مُجبرة أو وضع مرئي كتلي؛ لمزيد من المعلومات: `:h forced-motion`).

هذا يعني، إذا ضغطت على `g@w`، فإن `g@` سيمرر سلسلة حرفية `"char"` كوسيط إلى `ToTitle()`. إذا قمت بـ `g@j`، فإن `g@` سيمرر سلسلة حرفية `"line"` كوسيط إلى `ToTitle()`. هذه السلسلة هي ما سيتم تمريره إلى دالة `ToTitle` كوسيط `type`.

## إنشاء مشغل دالة مخصص خاص بك

دعنا نتوقف ونلعب مع `g@` من خلال كتابة دالة وهمية:

```shell
function! Test(some_arg)
  echom a:some_arg 
endfunction
```

الآن عيّن تلك الدالة إلى `opfunc` من خلال تشغيل:

```shell
:set opfunc=Test
```

سيقوم مشغل `g@` بتنفيذ `Test(some_arg)` ويمررها إما `"char"`، `"line"`، أو `"block"` اعتمادًا على العملية التي تقوم بها. قم بتشغيل عمليات مختلفة مثل `g@iw` (الكلمة الداخلية)، `g@j` (سطر واحد أسفل)، `g@$` (إلى نهاية السطر)، إلخ. انظر ما هي القيم المختلفة التي يتم عرضها. لاختبار عملية الكتلة، يمكنك استخدام حركة Vim المُجبرة لعمليات الكتلة: `g@Ctrl-Vj` (عملية كتلة عمود واحد أسفل).

يمكنك أيضًا استخدامها مع الوضع المرئي. استخدم الإبرازات المرئية المختلفة مثل `v`، `V`، و`Ctrl-V` ثم اضغط على `g@` (كن حذرًا، ستومض الإخراج بسرعة كبيرة، لذا تحتاج إلى أن تكون سريع البديهة - لكن الإخراج موجود بالتأكيد. أيضًا، نظرًا لأنك تستخدم `echom`، يمكنك التحقق من رسائل الإخراج المسجلة باستخدام `:messages`).

رائع، أليس كذلك؟ الأشياء التي يمكنك برمجتها باستخدام Vim! لماذا لم يعلموا هذا في المدرسة؟ دعنا نواصل مع الإضافة الخاصة بنا.

## ToTitle كدالة

ننتقل إلى الأسطر القليلة التالية:

```shell
if a:type != 'block' && a:type != 'line' && a:type != 'char'
  let l:words = a:type
  let l:wordsArr = trim(l:words)->split('\s\+')
  call map(l:wordsArr, 's:capitalize(v:val)')
  return l:wordsArr->join(' ')
endif
```

هذا السطر في الواقع ليس له علاقة بسلوك `ToTitle()` كمشغل، ولكن لتمكينه كدالة TitleCase قابلة للاستدعاء (نعم، أعلم أنني أنتهك مبدأ المسؤولية الواحدة). الدافع هو أن Vim لديه دوال أصلية `toupper()` و `tolower()` التي ستجعل أي سلسلة معينة بالأحرف الكبيرة أو الصغيرة. على سبيل المثال: `:echo toupper('hello')` تُرجع `'HELLO'` و`:echo tolower('HELLO')` تُرجع `'hello'`. أريد أن تكون هذه الإضافة قادرة على تشغيل `ToTitle` بحيث يمكنك استخدام `:echo ToTitle('once upon a time')` والحصول على قيمة إرجاع `'Once Upon a Time'`.

بحلول الآن، تعرف أنه عند استدعاء `ToTitle(type)` باستخدام `g@`، سيكون لوسيط `type` قيمة إما `'block'`، `'line'`، أو `'char'`. إذا لم يكن الوسيط لا `'block'` ولا `'line'` ولا `'char'`، يمكنك أن تفترض بأمان أن `ToTitle()` يتم استدعاؤها خارج `g@`. في هذه الحالة، تقوم بتقسيمها حسب المسافات البيضاء (`\s\+`) باستخدام:

```shell
let l:wordsArr = trim(l:words)->split('\s\+')
```

ثم تقوم بتكبير كل عنصر:

```shell
call map(l:wordsArr, 's:capitalize(v:val)')
```

قبل أن تجمعها مرة أخرى معًا:

```shell
l:wordsArr->join(' ')
```

ستتم تغطية دالة `capitalize()` لاحقًا.

## المتغيرات المؤقتة

الأسطر القليلة التالية:

```shell
let l:sel_save = &selection
let l:reg_save = getreginfo('"')
let l:cb_save = &clipboard
let l:visual_marks_save = [getpos("'<"), getpos("'>")]
```

تحفظ هذه الأسطر حالات مختلفة حالية في متغيرات مؤقتة. لاحقًا في هذا، ستستخدم الأوضاع المرئية، العلامات، والسجلات. القيام بذلك سيؤثر على بعض الحالات. نظرًا لأنك لا تريد تعديل التاريخ، تحتاج إلى حفظها في متغيرات مؤقتة حتى تتمكن من استعادة الحالات لاحقًا.
## تحويل الاختيارات إلى أحرف كبيرة

الأسطر التالية مهمة:

```shell
try
  set clipboard= selection=inclusive
  let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
  let l:selected_phrase = getreg('"')
  let l:WORD_PATTERN = '\<\k*\>'
  let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

  let l:startLine = line("'<")
  let l:startCol = virtcol(".")
```
دعونا نمر عبرها في أجزاء صغيرة. هذا السطر:

```shell
set clipboard= selection=inclusive
```

أنت أولاً تقوم بتعيين خيار `selection` ليكون شاملًا و `clipboard` ليكون فارغًا. يتم استخدام خاصية الاختيار عادةً مع الوضع البصري وهناك ثلاث قيم ممكنة: `old`، `inclusive`، و `exclusive`. تعيينه ليكون شاملًا يعني أن آخر حرف من الاختيار مشمول. لن أغطيها هنا، لكن النقطة هي أن اختيارها لتكون شاملة يجعلها تتصرف بشكل متسق في الوضع البصري. بشكل افتراضي، يقوم Vim بتعيينها لتكون شاملة، لكنك قمت بتعيينها هنا على أي حال فقط في حالة قيام أحد المكونات الإضافية لديك بتعيينها إلى قيمة مختلفة. تحقق من `:h 'clipboard'` و `:h 'selection'` إذا كنت فضولياً لمعرفة ما تفعله حقًا.

بعد ذلك لديك هذا الهاش الغريب الشكل متبوعًا بأمر تنفيذ:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
```

أولاً، صيغة `#{}` هي نوع بيانات القاموس في Vim. المتغير المحلي `l:commands` هو هاش يحتوي على 'lines' و 'char' و 'block' كمفاتيح له. الأمر `silent exe '...'` ينفذ أي أمر داخل السلسلة بصمت (وإلا سيعرض إشعارات في أسفل الشاشة).

ثانيًا، الأوامر المنفذة هي `'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')`. الأول، `noautocmd`، سينفذ الأمر التالي دون تفعيل أي أمر تلقائي. الثاني، `keepjumps`، هو لعدم تسجيل حركة المؤشر أثناء الحركة. في Vim، يتم تسجيل حركات معينة تلقائيًا في قائمة التغييرات، قائمة القفز، وقائمة العلامات. هذا يمنع ذلك. النقطة من وجود `noautocmd` و `keepjumps` هي منع الآثار الجانبية. أخيرًا، الأمر `normal` ينفذ السلاسل كأوامر عادية. `..` هو صيغة دمج السلاسل في Vim. `get()` هي طريقة للحصول على القيمة التي تقبل إما قائمة، أو blob، أو قاموس. في هذه الحالة، أنت تمرر القاموس `l:commands`. المفتاح هو `a:type`. لقد تعلمت سابقًا أن `a:type` هو إما واحدة من القيم الثلاثة: 'char'، 'line'، أو 'block'. لذا إذا كان `a:type` هو 'line'، ستقوم بتنفيذ `"noautocmd keepjumps normal! '[V']y"` (للمزيد، تحقق من `:h silent`، `:h :exe`، `:h :noautocmd`، `:h :keepjumps`، `:h :normal`، و `:h get()`).

دعونا نراجع ما يفعله `'[V']y`. أولاً افترض أن لديك هذا النص:

```shell
الإفطار الثاني
أفضل من الإفطار الأول
```
افترض أن المؤشر لديك على السطر الأول. ثم تضغط على `g@j` (تشغيل وظيفة المشغل، `g@`، سطر واحد أسفل، مع `j`). `'[` ينقل المؤشر إلى بداية النص الذي تم تغييره أو نسخه سابقًا. على الرغم من أنك تقنيًا لم تقم بتغيير أو نسخ أي نص باستخدام `g@j`، يتذكر Vim مواقع بداية ونهاية حركات أمر `g@` باستخدام `'[` و `']` (للمزيد، تحقق من `:h g@`). في حالتك، الضغط على `'[` ينقل المؤشر إلى السطر الأول لأنه حيث بدأت عندما قمت بتشغيل `g@`. `V` هو أمر وضع بصري على مستوى السطر. أخيرًا، `']` ينقل المؤشر إلى نهاية النص الذي تم تغييره أو نسخه سابقًا، ولكن في هذه الحالة، ينقل المؤشر إلى نهاية آخر عملية `g@`. أخيرًا، `y` ينسخ النص المحدد.

ما قمت به هو نسخ نفس النص الذي قمت بتنفيذ `g@` عليه.

إذا نظرت إلى الأوامر الأخرى هنا:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
```

كلها تؤدي إجراءات مشابهة، باستثناء أنه بدلاً من استخدام إجراءات على مستوى السطر، ستستخدم إجراءات على مستوى الحرف أو الكتلة. سأبدو متكررًا، لكن في أي من الحالات الثلاث، أنت فعليًا تنسخ نفس النص الذي قمت بتنفيذ `g@` عليه.

دعونا نلقي نظرة على السطر التالي:

```shell
let l:selected_phrase = getreg('"')
```

هذا السطر يحصل على محتوى السجل غير المسماة (`"`) ويخزنه داخل المتغير `l:selected_phrase`. انتظر لحظة... أليس لديك نص تم نسخه للتو؟ السجل غير المسماة يحتوي حاليًا على النص الذي قمت بنسخه للتو. هذه هي الطريقة التي يتمكن بها هذا المكون الإضافي من الحصول على نسخة من النص.

السطر التالي هو نمط تعبير عادي:

```shell
let l:WORD_PATTERN = '\<\k*\>'
```

`\<` و `\>` هي أنماط حدود الكلمات. الحرف الذي يلي `\<` يتطابق مع بداية الكلمة والحرف الذي يسبق `\>` يتطابق مع نهاية الكلمة. `\k` هو نمط الكلمة الرئيسية. يمكنك التحقق من الحروف التي يقبلها Vim ككلمات رئيسية باستخدام `:set iskeyword?`. تذكر أن حركة `w` في Vim تنقل المؤشر لديك على مستوى الكلمة. يأتي Vim مع مفهوم مسبق لما هو "كلمة رئيسية" (يمكنك حتى تعديلها عن طريق تغيير خيار `iskeyword`). تحقق من `:h /\<`، `:h /\>`، و `:h /\k`، و `:h 'iskeyword'` للمزيد. أخيرًا، `*` تعني صفر أو أكثر من النمط التالي.

في الصورة الكبيرة، `'\<\k*\>'` يتطابق مع كلمة. إذا كان لديك سلسلة:

```shell
واحد اثنان ثلاثة
```

سيتطابق مع النمط وسيعطيك ثلاث تطابقات: "واحد"، "اثنان"، و"ثلاثة".

أخيرًا، لديك نمط آخر:

```shell
let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'
```

تذكر أن أمر الاستبدال في Vim يمكن استخدامه مع تعبير باستخدام `\={your-expression}`. على سبيل المثال، إذا كنت تريد تحويل السلسلة "دونات" إلى أحرف كبيرة في السطر الحالي، يمكنك استخدام دالة `toupper()` في Vim. يمكنك تحقيق ذلك عن طريق تشغيل `:%s/donut/\=toupper(submatch(0))/g`. `submatch(0)` هو تعبير خاص يستخدم في أمر الاستبدال. إنه يعيد النص المتطابق بالكامل.

السطرين التاليين:

```shell
let l:startLine = line("'<")
let l:startCol = virtcol(".")
```

تُعيد تعبير `line()` رقم السطر. هنا تمرره مع العلامة `'<`، التي تمثل أول سطر من منطقة العرض المحددة الأخيرة. تذكر أنك استخدمت الوضع البصري لنسخ النص. `'<` يُعيد رقم السطر لبداية تلك المنطقة المحددة. تُعيد تعبير `virtcol()` رقم العمود للمؤشر الحالي. ستقوم بتحريك المؤشر في كل مكان بعد قليل، لذا تحتاج إلى تخزين موقع المؤشر حتى تتمكن من العودة إلى هنا لاحقًا.

خذ قسطًا من الراحة هنا واستعرض كل شيء حتى الآن. تأكد من أنك لا تزال تتابع. عندما تكون جاهزًا، دعنا نواصل.
## التعامل مع عملية الكتلة

دعنا نمر عبر هذا القسم:

```shell
if a:type ==# "block"
  sil! keepj norm! gv"ad
  keepj $
  keepj pu_

  let l:lastLine = line("$")

  sil! keepj norm "ap

  let l:curLine = line(".")

  sil! keepj norm! VGg@
  exe "keepj norm! 0\<c-v>G$h\"ad" 
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
  exe "keepj " . l:lastLine
  sil! keepj norm! "_dG
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

حان الوقت فعليًا لتكبير نصك. تذكر أن لديك `a:type` إما 'char' أو 'line' أو 'block'. في معظم الحالات، ستحصل على 'char' و 'line'. ولكن في بعض الأحيان قد تحصل على كتلة. إنه نادر، ولكن يجب التعامل معه على أي حال. للأسف، التعامل مع كتلة ليس بسيطًا مثل التعامل مع الحرف والسطر. سيتطلب الأمر جهدًا إضافيًا قليلاً، لكنه ممكن.

قبل أن تبدأ، دعنا نأخذ مثالًا على كيفية حصولك على كتلة. افترض أن لديك هذا النص:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner
```

افترض أن المؤشر الخاص بك على "c" في "pancake" في السطر الأول. ثم تستخدم الكتلة المرئية (`Ctrl-V`) للاختيار للأسفل للأمام لتحديد "cake" في جميع الأسطر الثلاثة:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner
```

عندما تضغط على `gt`، تريد أن تحصل على:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner

```
إليك افتراضاتك الأساسية: عندما تبرز الثلاث "cakes" في "pancakes"، فإنك تخبر Vim أن لديك ثلاث أسطر من الكلمات التي تريد إبرازها. هذه الكلمات هي "cake"، "cake"، و "cake". تتوقع أن تحصل على "Cake"، "Cake"، و "Cake".

دعنا ننتقل إلى تفاصيل التنفيذ. الأسطر القليلة التالية تحتوي على:

```shell
sil! keepj norm! gv"ad
keepj $
keepj pu_
let l:lastLine = line("$")
sil! keepj norm "ap
let l:curLine = line(".")
```

السطر الأول:

```shell
sil! keepj norm! gv"ad
```

تذكر أن `sil!` يعمل بصمت و `keepj` يحتفظ بسجل القفز عند التحرك. ثم تنفذ الأمر العادي `gv"ad`. `gv` يحدد النص الذي تم تمييزه بصريًا آخر مرة (في مثال الفطائر، سيعيد تمييز جميع الثلاث 'cakes'). `"ad` يحذف النصوص المميزة بصريًا ويخزنها في السجل a. نتيجة لذلك، لديك الآن:

```shell
pan for breakfast
pan for lunch
pan for dinner
```

الآن لديك 3 *كتل* (وليس أسطر) من 'cakes' مخزنة في السجل a. هذا التمييز مهم. قص النص باستخدام وضع التحديد السطري يختلف عن قص النص باستخدام وضع التحديد الكتلي. تذكر هذا لأنه ستراه مرة أخرى لاحقًا.

بعد ذلك لديك:

```shell
keepj $
keepj pu_
```

`$` ينقلك إلى السطر الأخير في ملفك. `pu_` يقوم بإدراج سطر واحد أسفل المكان الذي يوجد فيه المؤشر الخاص بك. تريد تشغيلهما مع `keepj` حتى لا تغير سجل القفز.

ثم تخزن رقم السطر الخاص بك في السطر الأخير (`line("$")`) في المتغير المحلي `lastLine`.

```shell
let l:lastLine = line("$")
```

ثم تلصق المحتوى من السجل باستخدام `norm "ap`.

```shell
sil! keepj norm "ap
```

تذكر أن هذا يحدث على السطر الجديد الذي أنشأته أسفل السطر الأخير من الملف - أنت حاليًا في أسفل الملف. اللصق يعطيك هذه النصوص *الكتلية*:

```shell
cake
cake
cake
```

بعد ذلك، تخزن موقع السطر الحالي حيث يوجد المؤشر الخاص بك.

```shell
let l:curLine = line(".")
```

الآن دعنا نذهب إلى الأسطر القليلة التالية:

```shell
sil! keepj norm! VGg@
exe "keepj norm! 0\<c-v>G$h\"ad"
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

هذا السطر:

```shell
sil! keepj norm! VGg@
```

`VG` يبرزها بصريًا باستخدام وضع التحديد السطري من السطر الحالي إلى نهاية الملف. لذا هنا تقوم بتمييز الثلاث كتل من نصوص 'cake' باستخدام التمييز السطري (تذكر التمييز بين الكتلة والسطر). لاحظ أنه في المرة الأولى التي ألصقت فيها الثلاث نصوص "cake"، كنت تلصقها ككتل. الآن أنت تميزها كأسطر. قد تبدو متشابهة من الخارج، لكن داخليًا، يعرف Vim الفرق بين لصق كتل النصوص ولصق أسطر النصوص.

```shell
cake
cake
cake
```

`g@` هو مشغل الدالة، لذا أنت في الأساس تقوم باستدعاء تكراري لنفسها. لكن لماذا؟ ماذا يحقق هذا؟

أنت تقوم بعمل استدعاء تكراري لـ `g@` وتمريره بجميع الثلاث أسطر (بعد تشغيله مع `V`، لديك الآن أسطر، وليس كتل) من نصوص 'cake' حتى يتم التعامل معها بواسطة الجزء الآخر من الكود (ستمر على هذا لاحقًا). نتيجة تشغيل `g@` هي ثلاث أسطر من النصوص المكتوبة بشكل صحيح:

```shell
Cake
Cake
Cake
```

السطر التالي:

```shell
exe "keepj norm! 0\<c-v>G$h\"ad"
```

هذا ينفذ الأمر في وضع العادي للذهاب إلى بداية السطر (`0`)، استخدام التمييز الكتلي للذهاب إلى السطر الأخير وآخر حرف في ذلك السطر (`<c-v>G$`). الـ `h` هو لضبط المؤشر (عند القيام بـ `$`، يتحرك Vim سطرًا إضافيًا إلى اليمين). أخيرًا، تحذف النص المميز وتخزنه في السجل a (`"ad`).

السطر التالي:

```shell
exe "keepj " . l:startLine
```

تنقل المؤشر الخاص بك مرة أخرى إلى حيث كان `startLine`.

التالي:

```shell
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
```

كونك في موقع `startLine`، الآن تقفز إلى العمود المحدد بواسطة `startCol`. `\<bar>\` هو حركة الشريط `|`. حركة الشريط في Vim تنقل المؤشر الخاص بك إلى العمود nth (دعنا نقول أن `startCol` كان 4. تشغيل `4|` سيجعل المؤشر الخاص بك يقفز إلى موضع العمود 4). تذكر أن `startCol` كان الموقع الذي خزنت فيه موضع العمود للنص الذي أردت تكبيره. أخيرًا، `"aP` يلصق النصوص المخزنة في السجل a. هذا يعيد النص إلى حيث تم حذفه سابقًا.

دعنا نلقي نظرة على الأربعة أسطر التالية:

```shell
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

`exe "keepj " . l:lastLine` ينقل المؤشر الخاص بك مرة أخرى إلى موقع `lastLine` من السابق. `sil! keepj norm! "_dG` يحذف المساحة الإضافية التي تم إنشاؤها باستخدام السجل الأسود (`"_dG`) حتى يبقى سجل غير مسمى نظيفًا. `exe "keepj " . l:startLine` ينقل المؤشر الخاص بك مرة أخرى إلى `startLine`. أخيرًا، `exe "sil! keepj norm! " . l:startCol . "\<bar>"` ينقل المؤشر الخاص بك إلى عمود `startCol`.

هذه هي جميع الإجراءات التي يمكنك القيام بها يدويًا في Vim. ومع ذلك، فإن فائدة تحويل هذه الإجراءات إلى وظائف قابلة لإعادة الاستخدام هي أنها ستوفر لك من تشغيل 30+ سطرًا من التعليمات في كل مرة تحتاج فيها إلى تكبير أي شيء. الخلاصة هنا هي، أي شيء يمكنك القيام به يدويًا في Vim، يمكنك تحويله إلى وظيفة قابلة لإعادة الاستخدام، وبالتالي إلى مكون إضافي!

إليك كيف سيبدو الأمر.

بالنظر إلى نص ما:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner

... بعض النصوص
```

أولاً، تبرزها بصريًا بطريقة كتلية:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner

... بعض النصوص
```

ثم تحذفها وتخزن ذلك النص في السجل a:

```shell
pan for breakfast
pan for lunch
pan for dinner

... بعض النصوص
```

ثم تلصقها في أسفل الملف:

```shell
pan for breakfast
pan for lunch
pan for dinner

... بعض النصوص
cake
cake
cake
```

ثم تكبرها:

```shell
pan for breakfast
pan for lunch
pan for dinner

... بعض النصوص
Cake
Cake
Cake
```

أخيرًا، تعيد النص المكبر:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner

... بعض النصوص
```

## التعامل مع عمليات السطر والحرف

لم تنته بعد. لقد تناولت فقط الحالة الحدية عندما تقوم بتشغيل `gt` على نصوص الكتلة. لا يزال يتعين عليك التعامل مع عمليات 'line' و 'char'. دعنا نلقي نظرة على كود `else` لمعرفة كيفية القيام بذلك.

إليك الأكواد:

```shell
if a:type ==# "block"
  # ... 
else
  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
  let l:titlecased = s:capitalizeFirstWord(l:titlecased)
  call setreg('"', l:titlecased)
  let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
  silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
endif
```

دعنا نمر عبرها سطرًا بسطر. الصلصة السرية لهذه الإضافة موجودة في هذا السطر:

```shell
let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
```

`@@` يحتوي على النص من السجل غير المسمى ليتم تكبيره. `l:WORD_PATTERN` هو تطابق الكلمة الفردية. `l:UPCASE_REPLACEMENT` هو الاستدعاء لأمر `capitalize()` (الذي سترى لاحقًا). الـ `'g'` هو العلم العالمي الذي instructs أمر الاستبدال لاستبدال جميع الكلمات المعطاة، وليس فقط الكلمة الأولى.

السطر التالي:

```shell
let l:titlecased = s:capitalizeFirstWord(l:titlecased)
```

هذا يضمن أن الكلمة الأولى ستكون دائمًا مكتوبة بحرف كبير. إذا كان لديك عبارة مثل "an apple a day keeps the doctor away"، بما أن الكلمة الأولى، "an"، هي كلمة خاصة، فإن أمر الاستبدال الخاص بك لن يكبرها. تحتاج إلى طريقة تضمن تكبير الحرف الأول بغض النظر عن أي شيء. هذه الوظيفة تفعل ذلك (سترَى تفاصيل هذه الوظيفة لاحقًا). نتيجة هذه الطرق في التكبير يتم تخزينها في المتغير المحلي `l:titlecased`.

السطر التالي:

```shell
call setreg('"', l:titlecased)
```

هذا يضع السلسلة المكتوبة بحرف كبير في السجل غير المسمى (`"`).

بعد ذلك، السطرين التاليين:

```shell
let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
```

مرحبًا، يبدو أن هذا مألوفًا! لقد رأيت نمطًا مشابهًا من قبل مع `l:commands`. بدلاً من الرفع، هنا تستخدم اللصق (`p`). تحقق من القسم السابق حيث ناقشت `l:commands` للحصول على تذكير.

أخيرًا، هذان السطران:

```shell
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

أنت تنقل المؤشر الخاص بك مرة أخرى إلى السطر والعمود حيث بدأت. هذا كل شيء!

دعنا نلخص. طريقة الاستبدال أعلاه ذكية بما يكفي لتكبير النصوص المعطاة وتخطي الكلمات الخاصة (المزيد عن هذا لاحقًا). بعد أن تحصل على سلسلة مكتوبة بحرف كبير، تخزنها في السجل غير المسمى. ثم تبرز بصريًا نفس النص الذي عملت عليه `g@` من قبل، ثم تلصق من السجل غير المسمى (هذا بشكل فعال يستبدل النصوص غير المكتوبة بحرف كبير بالنصوص المكتوبة بحرف كبير. أخيرًا، تنقل المؤشر الخاص بك مرة أخرى إلى حيث بدأت.
## التنظيفات

أنت تقنيًا انتهيت. النصوص الآن بحالة عنوان. كل ما تبقى هو استعادة السجلات والإعدادات.

```shell
call setreg('"', l:reg_save)
call setpos("'<", l:visual_marks_save[0])
call setpos("'>", l:visual_marks_save[1])
let &clipboard = l:cb_save
let &selection = l:sel_save
```

هذه تستعيد:
- السجل غير المسمي.
- العلامات `<` و `>`.
- خيارات `'clipboard'` و `'selection'`.

أوه، لقد انتهيت. كانت تلك وظيفة طويلة. كان بإمكاني جعل الوظيفة أقصر عن طريق تقسيمها إلى وظائف أصغر، لكن في الوقت الحالي، سيتعين أن يكون هذا كافيًا. الآن دعنا نستعرض باختصار وظائف التسمية.

## وظيفة التسمية

في هذا القسم، دعنا نستعرض وظيفة `s:capitalize()`. هذه هي شكل الوظيفة:

```shell
function! s:capitalize(string)
    if(toupper(a:string) ==# a:string && a:string != 'A')
        return a:string
    endif

    let l:str = tolower(a:string)
    let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
      return l:str
    endif

    return toupper(l:str[0]) . l:str[1:]
endfunction
```

تذكر أن الحجة لوظيفة `capitalize()`، `a:string`، هي الكلمة الفردية التي تمررها عامل `g@`. لذا إذا كنت أشغل `gt` على النص "فطيرة للافطار"، ستقوم `ToTitle` باستدعاء `capitalize(string)` *ثلاث مرات*، مرة لـ "فطيرة"، ومرة لـ "لـ"، ومرة لـ "لافطار".

الجزء الأول من الوظيفة هو:

```shell
if(toupper(a:string) ==# a:string && a:string != 'A')
  return a:string
endif
```

الشرط الأول (`toupper(a:string) ==# a:string`) يتحقق مما إذا كانت النسخة المكتوبة بأحرف كبيرة من الحجة هي نفسها السلسلة وما إذا كانت السلسلة نفسها هي "A". إذا كانت هذه صحيحة، فارجع تلك السلسلة. هذا يعتمد على الافتراض أنه إذا كانت كلمة معينة مكتوبة بالكامل بأحرف كبيرة، فهي اختصار. على سبيل المثال، الكلمة "CEO" ستتحول خلاف ذلك إلى "Ceo". همم، لن يكون مديرك التنفيذي سعيدًا. لذا من الأفضل ترك أي كلمة مكتوبة بالكامل بأحرف كبيرة كما هي. الشرط الثاني، `a:string != 'A'`، يعالج حالة خاصة لحرف "A" الكبير. إذا كانت `a:string` بالفعل "A" كبيرة، فسيكون قد اجتاز عن طريق الخطأ اختبار `toupper(a:string) ==# a:string`. لأن "a" هو أداة نكرة في الإنجليزية، يجب أن تكون مكتوبة بأحرف صغيرة.

الجزء التالي يجبر السلسلة على أن تكون مكتوبة بأحرف صغيرة:

```shell
let l:str = tolower(a:string)
```

الجزء التالي هو تعبير عادي لقائمة جميع الاستثناءات للكلمات. حصلت عليها من https://titlecaseconverter.com/rules/ :

```shell
let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
```

الجزء التالي:

```shell
if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
  return l:str
endif
```

أولاً، تحقق مما إذا كانت سلسلتك جزءًا من قائمة الكلمات المستثناة (`l:exclusions`). إذا كانت كذلك، فلا تقم بتسمية الحرف. ثم تحقق مما إذا كانت سلسلتك جزءًا من قائمة الاستثناءات المحلية (`s:local_exclusion_list`). هذه القائمة الاستثنائية هي قائمة مخصصة يمكن للمستخدم إضافتها في vimrc (في حال كان لدى المستخدم متطلبات إضافية لكلمات خاصة).

الجزء الأخير يعيد النسخة المكتوبة بأحرف كبيرة من الكلمة. الحرف الأول مكتوب بأحرف كبيرة بينما البقية تبقى كما هي.

```shell
return toupper(l:str[0]) . l:str[1:]
```

دعنا نستعرض وظيفة التسمية الثانية. الوظيفة تبدو هكذا:

```shell
function! s:capitalizeFirstWord(string)
  if (a:string =~ "\n")
    let l:lineArr = trim(a:string)->split('\n')
    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
    return l:lineArr->join("\n")
  endif
  return toupper(a:string[0]) . a:string[1:]
endfunction
```

تم إنشاء هذه الوظيفة لمعالجة حالة خاصة إذا كان لديك جملة تبدأ بكلمة مستثناة، مثل "تفاحة في اليوم تبقي الطبيب بعيدًا". بناءً على قواعد التسمية في اللغة الإنجليزية، يجب أن تكون جميع الكلمات الأولى في الجملة، بغض النظر عما إذا كانت كلمة خاصة أم لا، مكتوبة بأحرف كبيرة. مع أمر `substitute()` الخاص بك فقط، سيتم كتابة "تفاحة" في جملتك بأحرف صغيرة. تحتاج إلى إجبار الحرف الأول على أن يكون مكتوبًا بأحرف كبيرة.

في هذه الوظيفة `capitalizeFirstWord`، الحجة `a:string` ليست كلمة فردية مثل `a:string` داخل وظيفة `capitalize`، بل هي النص الكامل. لذا إذا كان لديك "فطيرة للافطار"، فإن قيمة `a:string` هي "فطيرة للافطار". يتم تشغيل `capitalizeFirstWord` مرة واحدة فقط للنص الكامل.

سيناريو واحد تحتاج إلى الانتباه له هو إذا كان لديك سلسلة متعددة الأسطر مثل `"تفاحة في اليوم\nتبقي الطبيب بعيدًا"`. تريد كتابة الحرف الأول من جميع الأسطر بأحرف كبيرة. إذا لم يكن لديك أسطر جديدة، فقم ببساطة بكتابة الحرف الأول بأحرف كبيرة.

```shell
return toupper(a:string[0]) . a:string[1:]
```

إذا كان لديك أسطر جديدة، تحتاج إلى كتابة الحرف الأول من كل سطر بأحرف كبيرة، لذا تقوم بتقسيمها إلى مصفوفة مفصولة بأسطر جديدة:

```shell
let l:lineArr = trim(a:string)->split('\n')
```

ثم تقوم بتطبيق كل عنصر في المصفوفة وكتابة الكلمة الأولى من كل عنصر بأحرف كبيرة:

```shell
let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
```

أخيرًا، تقوم بجمع عناصر المصفوفة معًا:

```shell
return l:lineArr->join("\n")
```

وانتهيت!

## الوثائق

الدليل الثاني في المستودع هو دليل `docs/`. من الجيد توفير الوثائق الشاملة للإضافة. في هذا القسم، سأستعرض باختصار كيفية إنشاء وثائق الإضافة الخاصة بك.

دليل `docs/` هو واحد من مسارات التشغيل الخاصة بـ Vim. يقرأ Vim جميع الملفات داخل `docs/` لذا عندما تبحث عن كلمة خاصة وتجد تلك الكلمة في أحد الملفات في دليل `docs/`، ستظهر في صفحة المساعدة. هنا لديك `totitle.txt`. أسميته بهذه الطريقة لأن هذا هو اسم الإضافة، ولكن يمكنك تسميته بأي شيء تريده.

ملف وثائق Vim هو في جوهره ملف نصي. الفرق بين ملف نصي عادي وملف مساعدة في Vim هو أن الأخير يستخدم صيغ "مساعدة" خاصة. لكن أولاً، تحتاج إلى إخبار Vim بمعاملته ليس كنوع ملف نصي، ولكن كنوع ملف `help`. لإخبار Vim بتفسير هذا `totitle.txt` كملف *مساعدة*، قم بتشغيل `:set ft=help` (`:h 'filetype'` للمزيد). بالمناسبة، إذا كنت تريد إخبار Vim بتفسير هذا `totitle.txt` كملف نصي *عادي*، قم بتشغيل `:set ft=txt`.

### صيغة ملف المساعدة الخاصة

لجعل كلمة قابلة للاكتشاف، قم بإحاطة تلك الكلمة بالنجوم. لجعل الكلمة `totitle` قابلة للاكتشاف عندما يبحث المستخدم عن `:h totitle`، اكتبها كـ `*totitle*` في ملف المساعدة.

على سبيل المثال، لدي هذه الأسطر في أعلى جدول المحتويات الخاص بي:

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

// المزيد من محتويات TOC
```

لاحظ أنني استخدمت كلمتين رئيسيتين: `*totitle*` و `*totitle-toc*` لتحديد قسم جدول المحتويات. يمكنك استخدام أي عدد من الكلمات الرئيسية كما تريد. هذا يعني أنه كلما بحثت عن `:h totitle` أو `:h totitle-toc`، سيأخذك Vim إلى هذا الموقع.

إليك مثال آخر، في مكان ما في أسفل الملف:

```shell
2. الاستخدام                                                       *totitle-usage*

// الاستخدام
```

إذا بحثت عن `:h totitle-usage`، سيأخذك Vim إلى هذا القسم.

يمكنك أيضًا استخدام الروابط الداخلية للإشارة إلى قسم آخر في ملف المساعدة عن طريق إحاطة كلمة رئيسية بصيغة الشريط `|`. في قسم TOC، ترى الكلمات الرئيسية محاطة بالشرائط، مثل `|totitle-intro|`، `|totitle-usage|`، إلخ.

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

    1. المقدمة ........................... |totitle-intro|
    2. الاستخدام ........................... |totitle-usage|
    3. الكلمات التي يجب كتابتها بأحرف كبيرة ............. |totitle-words|
    4. العامل ........................ |totitle-operator|
    5. الربط بالاختصارات ..................... |totitle-keybinding|
    6. الأخطاء ............................ |totitle-bug-report|
    7. المساهمة .................... |totitle-contributing|
    8. الشكر ......................... |totitle-credits|

```
هذا يتيح لك الانتقال إلى التعريف. إذا وضعت المؤشر في مكان ما على `|totitle-intro|` وضغطت `Ctrl-]`، سيقفز Vim إلى تعريف تلك الكلمة. في هذه الحالة، سيقفز إلى موقع `*totitle-intro*`. هذه هي الطريقة التي يمكنك من خلالها الربط بين كلمات مختلفة في وثيقة المساعدة.

لا توجد طريقة صحيحة أو خاطئة لكتابة ملف وثائق في Vim. إذا نظرت إلى إضافات مختلفة من مؤلفين مختلفين، ستجد أن العديد منهم يستخدمون تنسيقات مختلفة. النقطة هي جعل وثيقة مساعدة سهلة الفهم لمستخدميك.

أخيرًا، إذا كنت تكتب إضافتك الخاصة محليًا في البداية وتريد اختبار صفحة الوثائق، فإن إضافة ملف نصي داخل `~/.vim/docs/` لن تجعل كلماتك الرئيسية قابلة للبحث تلقائيًا. تحتاج إلى إخبار Vim بإضافة صفحة الوثائق الخاصة بك. قم بتشغيل أمر helptags: `:helptags ~/.vim/doc` لإنشاء ملفات علامات جديدة. الآن يمكنك البدء في البحث عن كلماتك الرئيسية.

## الخاتمة

لقد وصلت إلى النهاية! هذا الفصل هو تجميع لجميع فصول Vimscript. هنا أنت أخيرًا تطبق ما تعلمته حتى الآن. نأمل أن تكون قد فهمت من خلال قراءة هذا، ليس فقط كيفية إنشاء إضافات Vim، ولكن أيضًا تشجيعك على كتابة إضافتك الخاصة.

كلما وجدت نفسك تكرر نفس تسلسل الإجراءات عدة مرات، يجب أن تحاول إنشاء إضافتك الخاصة! قيل إنه لا ينبغي عليك إعادة اختراع العجلة. ومع ذلك، أعتقد أنه يمكن أن يكون مفيدًا إعادة اختراع العجلة من أجل التعلم. اقرأ إضافات الآخرين. أعد إنشاءها. تعلم منها. اكتب الخاصة بك! من يدري، ربما ستكتب الإضافة الرائعة والشعبية التالية بعد قراءة هذا. ربما ستكون الأسطورة التالية تيم بوب. عندما يحدث ذلك، دعني أعرف!