---
description: هذا الفصل يشرح كيفية التجميع من خلال فيم، ويستعرض كيفية استخدام أمر `:make`
  للاستفادة من ملفات make في عملية التجميع.
title: Ch19. Compile
---

تجميع الأكواد هو موضوع مهم للعديد من اللغات. في هذا الفصل، ستتعلم كيفية التجميع من خلال Vim. ستنظر أيضًا في طرق الاستفادة من أمر `:make` في Vim.

## التجميع من سطر الأوامر

يمكنك استخدام عامل bang (`!`) للتجميع. إذا كنت بحاجة إلى تجميع ملف `.cpp` الخاص بك باستخدام `g++`، قم بتشغيل:

```shell
:!g++ hello.cpp -o hello
```

ومع ذلك، فإن الحاجة إلى كتابة اسم الملف واسم الملف الناتج يدويًا في كل مرة قد تكون عرضة للأخطاء ومملة. ملف make هو الحل المناسب.

## أمر make

يمتلك Vim أمر `:make` لتشغيل ملف make. عند تشغيله، يبحث Vim عن ملف make في الدليل الحالي لتنفيذه.

قم بإنشاء ملف باسم `makefile` في الدليل الحالي وضع بداخله:

```shell
all:
	echo "Hello all"
foo:
	echo "Hello foo"
list_pls:
	ls
```

قم بتشغيل هذا من Vim:

```shell
:make
```

ينفذ Vim الأمر بنفس الطريقة كما لو كنت تقوم بتشغيله من الطرفية. يقبل أمر `:make` معلمات تمامًا مثل أمر make في الطرفية. قم بتشغيل:

```shell
:make foo
" الناتج "Hello foo"

:make list_pls
" الناتج نتيجة أمر ls
```

يستخدم أمر `:make` ميزة quickfix في Vim لتخزين أي خطأ إذا قمت بتشغيل أمر غير صحيح. دعنا نشغل هدفًا غير موجود:

```shell
:make dontexist
```

يجب أن ترى خطأ عند تشغيل هذا الأمر. لعرض ذلك الخطأ، قم بتشغيل أمر quickfix `:copen` لعرض نافذة quickfix:

```shell
|| make: *** No rule to make target `dontexist'.  Stop.
```

## التجميع باستخدام make

دعنا نستخدم ملف make لتجميع برنامج `.cpp` أساسي. أولاً، دعنا ننشئ ملف `hello.cpp`:

```shell
#include <iostream>

int main() {
    std::cout << "Hello!\n";
    return 0;
}
```

قم بتحديث ملف make الخاص بك لبناء وتشغيل ملف `.cpp`:

```shell
all:
	echo "build, run"
build:
	g++ hello.cpp -o hello
run:
	./hello
```

الآن قم بتشغيل:

```shell
:make build
```

يقوم `g++` بتجميع `./hello.cpp` وينشئ `./hello`. ثم قم بتشغيل:

```shell
:make run
```

يجب أن ترى `"Hello!"` مطبوعة على الطرفية.

## برنامج make مختلف

عند تشغيل `:make`، يقوم Vim فعليًا بتشغيل أي أمر تم تعيينه تحت خيار `makeprg`. إذا قمت بتشغيل `:set makeprg?`، سترى:

```shell
makeprg=make
```

الأمر الافتراضي `:make` هو الأمر الخارجي `make`. لتغيير أمر `:make` لتنفيذ `g++ {اسم-ملفك}` في كل مرة تقوم بتشغيله، قم بتشغيل:

```shell
:set makeprg=g++\ %
```

الـ `\` هو للهروب من المسافة بعد `g++`. يمثل الرمز `%` في Vim الملف الحالي. الأمر `g++\\ %` يعادل تشغيل `g++ hello.cpp`.

انتقل إلى `./hello.cpp` ثم قم بتشغيل `:make`. يقوم Vim بتجميع `hello.cpp` وينشئ `a.out` لأنك لم تحدد الناتج. دعنا نعيد هيكلته بحيث يتم تسمية الناتج المجمّع باسم الملف الأصلي بدون الامتداد. قم بتشغيل أو إضافة هذا إلى vimrc:

```shell
set makeprg=g++\ %\ -o\ %<
```

التفصيل:
- `g++\ %` هو نفسه كما في الأعلى. يعادل تشغيل `g++ <اسم-ملفك>`.
- `-o` هو خيار الناتج.
- `%<` في Vim يمثل اسم الملف الحالي بدون امتداد (`hello.cpp` يصبح `hello`).

عند تشغيل `:make` من داخل `./hello.cpp`، يتم تجميعه إلى `./hello`. لتشغيل `./hello` بسرعة من داخل `./hello.cpp`، قم بتشغيل `:!./%<`. مرة أخرى، هذا هو نفسه كتشغيل `:!./{اسم-ملفك-الحالي-بدون-الامتداد}`.

للمزيد، تحقق من `:h :compiler` و `:h write-compiler-plugin`.

## التجميع التلقائي عند الحفظ

يمكنك تسهيل الحياة أكثر من خلال أتمتة التجميع. تذكر أنه يمكنك استخدام `autocmd` في Vim لتحفيز إجراءات تلقائية بناءً على أحداث معينة. لتجميع ملفات `.cpp` تلقائيًا عند كل حفظ، أضف هذا إلى vimrc:

```shell
autocmd BufWritePost *.cpp make
```

في كل مرة تقوم فيها بالحفظ داخل ملف `.cpp`، يقوم Vim بتنفيذ أمر `make`.

## تغيير المترجم

يمتلك Vim أمر `:compiler` لتغيير المترجمين بسرعة. من المحتمل أن يأتي بناء Vim الخاص بك مع العديد من تكوينات المترجمين المسبقة. للتحقق من المترجمين المتاحين لديك، قم بتشغيل:

```shell
:e $VIMRUNTIME/compiler/<Tab>
```

يجب أن ترى قائمة بالمترجمين للغات برمجة مختلفة.

لاستخدام أمر `:compiler`، افترض أن لديك ملف Ruby، `hello.rb` وداخله:

```shell
puts "Hello ruby"
```

تذكر أنه إذا قمت بتشغيل `:make`، يقوم Vim بتنفيذ أي أمر تم تعيينه لـ `makeprg` (الافتراضي هو `make`). إذا قمت بتشغيل:

```shell
:compiler ruby
```

يقوم Vim بتشغيل البرنامج النصي `$VIMRUNTIME/compiler/ruby.vim` ويغير `makeprg` لاستخدام أمر `ruby`. الآن إذا قمت بتشغيل `:set makeprg?`، يجب أن تقول `makeprg=ruby` (هذا يعتمد على ما هو داخل ملفك `$VIMRUNTIME/compiler/ruby.vim` أو إذا كان لديك مترجمين مخصصين آخرين لـ Ruby. قد يكون لديك شيء مختلف). يسمح لك أمر `:compiler {لغتك}` بالتبديل إلى مترجمين مختلفين بسرعة. هذا مفيد إذا كان مشروعك يستخدم لغات متعددة.

لا تحتاج إلى استخدام `:compiler` و `makeprg` لتجميع برنامج. يمكنك تشغيل برنامج اختبار، أو فحص ملف، أو إرسال إشارة، أو أي شيء تريده.

## إنشاء مترجم مخصص

دعنا ننشئ مترجم Typescript بسيط. قم بتثبيت Typescript (`npm install -g typescript`) على جهازك. يجب أن يكون لديك الآن أمر `tsc`. إذا لم تكن قد جربت Typescript من قبل، يقوم `tsc` بتجميع ملف Typescript إلى ملف Javascript. افترض أن لديك ملفًا، `hello.ts`:

```shell
const hello = "hello";
console.log(hello);
```

إذا قمت بتشغيل `tsc hello.ts`، سيتم تجميعه إلى `hello.js`. ومع ذلك، إذا كان لديك التعبيرات التالية داخل `hello.ts`:

```shell
const hello = "hello";
hello = "hello again";
console.log(hello);
```

سيؤدي ذلك إلى حدوث خطأ لأنه لا يمكنك تعديل متغير `const`. تشغيل `tsc hello.ts` سيؤدي إلى ظهور خطأ:

```shell
hello.ts:2:1 - error TS2588: Cannot assign to 'person' because it is a constant.

2 person = "hello again";
  ~~~~~~


Found 1 error.
```

لإنشاء مترجم Typescript بسيط، في دليل `~/.vim/` الخاص بك، أضف دليل `compiler` (`~/.vim/compiler/`)، ثم أنشئ ملف `typescript.vim` (`~/.vim/compiler/typescript.vim`). ضع هذا بداخله:

```shell
CompilerSet makeprg=tsc
CompilerSet errorformat=%f:\ %m
```

السطر الأول يحدد `makeprg` لتشغيل أمر `tsc`. السطر الثاني يحدد تنسيق الخطأ لعرض الملف (`%f`)، متبوعًا بنقطتين (`:`) ومسافة هاربة (`\ `)، متبوعة برسالة الخطأ (`%m`). لمعرفة المزيد عن تنسيق الأخطاء، تحقق من `:h errorformat`.

يجب عليك أيضًا قراءة بعض المترجمين المسبقين لمعرفة كيفية قيام الآخرين بذلك. تحقق من `:e $VIMRUNTIME/compiler/<some-language>.vim`.

نظرًا لأن بعض المكونات الإضافية قد تتداخل مع ملف Typescript، دعنا نفتح `hello.ts` بدون أي مكون إضافي، باستخدام علامة `--noplugin`:

```shell
vim --noplugin hello.ts
```

تحقق من `makeprg`:

```shell
:set makeprg?
```

يجب أن تقول البرنامج الافتراضي `make`. لاستخدام مترجم Typescript الجديد، قم بتشغيل:

```shell
:compiler typescript
```

عند تشغيل `:set makeprg?`، يجب أن تقول `tsc` الآن. دعنا نختبر ذلك. قم بتشغيل:

```shell
:make %
```

تذكر أن `%` تعني الملف الحالي. شاهد مترجم Typescript الخاص بك يعمل كما هو متوقع! لرؤية قائمة بالأخطاء، قم بتشغيل `:copen`.

## مترجم غير متزامن

أحيانًا قد يستغرق التجميع وقتًا طويلاً. لا تريد أن تظل تحدق في Vim المجمد أثناء انتظار انتهاء عملية التجميع. ألن يكون من الرائع إذا كان بإمكانك التجميع بشكل غير متزامن حتى تتمكن من استخدام Vim أثناء التجميع؟

لحسن الحظ، هناك مكونات إضافية لتشغيل العمليات غير المتزامنة. اثنان من الأسماء الكبيرة هما:

- [vim-dispatch](https://github.com/tpope/vim-dispatch)
- [asyncrun.vim](https://github.com/skywind3000/asyncrun.vim)

في بقية هذا الفصل، سأستعرض vim-dispatch، لكنني أشجعك بشدة على تجربة جميع الخيارات المتاحة.

*يدعم Vim وNeoVim في الواقع الوظائف غير المتزامنة، لكن هذا يتجاوز نطاق هذا الفصل. إذا كنت فضوليًا، تحقق من `:h job-channel-overview.txt`.*

## المكون الإضافي: Vim-dispatch

يمتلك Vim-dispatch العديد من الأوامر، لكن الأمرين الرئيسيين هما `:Make` و `:Dispatch`.

### التجميع غير المتزامن

أمر `:Make` في Vim-dispatch مشابه لأمر `:make` في Vim، لكنه يعمل بشكل غير متزامن. إذا كنت في مشروع Javascript وتحتاج إلى تشغيل `npm t`، قد تحاول تعيين `makeprg` ليكون:

```shell
:set makeprg=npm\\ t
```

إذا قمت بتشغيل:

```shell
:make
```

سيقوم Vim بتنفيذ `npm t`، لكنك ستظل تحدق في الشاشة المجمدة بينما يتم تشغيل اختبار JavaScript الخاص بك. مع vim-dispatch، يمكنك فقط تشغيل:

```shell
:Make
```

سيقوم Vim بتشغيل `npm t` بشكل غير متزامن. بهذه الطريقة، بينما يتم تشغيل `npm t` في عملية خلفية، يمكنك الاستمرار في القيام بما كنت تفعله. رائع!

### الإرسال غير المتزامن

أمر `:Dispatch` يشبه أمر `:compiler` وأمر `:!`. يمكنه تشغيل أي أمر خارجي بشكل غير متزامن في Vim.

افترض أنك داخل ملف spec لـ Ruby وتحتاج إلى تشغيل اختبار. قم بتشغيل:

```shell
:Dispatch bundle exec rspec %
```

سيقوم Vim بتشغيل أمر `rspec` بشكل غير متزامن ضد الملف الحالي (`%`).

### أتمتة الإرسال

يمتلك Vim-dispatch متغير `b:dispatch` الذي يمكنك تكوينه لتقييم أمر معين تلقائيًا. يمكنك الاستفادة منه مع `autocmd`. إذا أضفت هذا في vimrc:

```shell
autocmd BufEnter *_spec.rb let b:dispatch = 'bundle exec rspec %'
```

الآن في كل مرة تدخل فيها ملف (`BufEnter`) ينتهي بـ `_spec.rb`، سيؤدي تشغيل `:Dispatch` تلقائيًا إلى تنفيذ `bundle exec rspec {ملف-الـRuby-الحالي}`.

## تعلم التجميع بطريقة ذكية

في هذا الفصل، تعلمت أنه يمكنك استخدام أوامر `make` و `compiler` لتشغيل *أي* عملية من داخل Vim بشكل غير متزامن لتكملة سير عمل البرمجة الخاص بك. قدرة Vim على توسيع نفسها مع برامج أخرى تجعلها قوية.