---
description: เอกสารนี้สอนการใช้คำสั่ง global ใน Vim เพื่อรันคำสั่งในหลายบรรทัดพร้อมกัน
  พร้อมอธิบายเกี่ยวกับคำสั่ง Ex และการใช้งานต่างๆ
title: Ch13. the Global Command
---

จนถึงตอนนี้คุณได้เรียนรู้วิธีการทำซ้ำการเปลี่ยนแปลงล่าสุดด้วยคำสั่งจุด (`.`), การเล่นซ้ำการกระทำด้วยมาโคร (`q`), และการเก็บข้อความในรีจิสเตอร์ (`"`).

ในบทนี้คุณจะได้เรียนรู้วิธีการทำซ้ำคำสั่งในบรรทัดคำสั่งด้วยคำสั่งทั่วโลก

## ภาพรวมของคำสั่งทั่วโลก

คำสั่งทั่วโลกของ Vim ใช้เพื่อเรียกใช้คำสั่งในบรรทัดคำสั่งในหลายบรรทัดพร้อมกัน

โดยทั่วไปแล้ว คุณอาจเคยได้ยินคำว่า "คำสั่ง Ex" มาก่อน ในคู่มือนี้ฉันจะเรียกมันว่าคำสั่งในบรรทัดคำสั่ง คำสั่ง Ex และคำสั่งในบรรทัดคำสั่งเป็นสิ่งเดียวกัน พวกมันคือคำสั่งที่เริ่มต้นด้วยโคลอน (`:`) คำสั่งแทนที่ในบทก่อนหน้าเป็นตัวอย่างของคำสั่ง Ex พวกมันถูกเรียกว่า Ex เพราะเดิมมาจากโปรแกรมแก้ไขข้อความ Ex ฉันจะเรียกพวกมันว่าคำสั่งในบรรทัดคำสั่งในคู่มือนี้ สำหรับรายการคำสั่ง Ex ทั้งหมดให้ตรวจสอบที่ `:h ex-cmd-index`.

คำสั่งทั่วโลกมีไวยากรณ์ดังนี้:

```shell
:g/pattern/command
```

`pattern` จะตรงกับบรรทัดทั้งหมดที่มีรูปแบบนั้น คล้ายกับรูปแบบในคำสั่งแทนที่ `command` สามารถเป็นคำสั่งในบรรทัดคำสั่งใดก็ได้ คำสั่งทั่วโลกทำงานโดยการเรียกใช้ `command` กับแต่ละบรรทัดที่ตรงกับ `pattern`.

ถ้าคุณมีนิพจน์ดังต่อไปนี้:

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

เพื่อเอาบรรทัดทั้งหมดที่มี "console" คุณสามารถรัน:

```shell
:g/console/d
```

ผลลัพธ์:

```shell
const one = 1;

const two = 2;

const three = 3;
```

คำสั่งทั่วโลกจะดำเนินการคำสั่งลบ (`d`) บนบรรทัดทั้งหมดที่ตรงกับรูปแบบ "console".

เมื่อรันคำสั่ง `g`, Vim จะทำการสแกนไฟล์สองครั้ง ในการรันครั้งแรก มันจะสแกนแต่ละบรรทัดและทำเครื่องหมายบรรทัดที่ตรงกับรูปแบบ `/console/` เมื่อบรรทัดที่ตรงกันทั้งหมดถูกทำเครื่องหมายแล้ว มันจะไปอีกครั้งและดำเนินการคำสั่ง `d` บนบรรทัดที่ทำเครื่องหมาย.

ถ้าคุณต้องการลบบรรทัดทั้งหมดที่มี "const" แทน ให้รัน:

```shell
:g/const/d
```

ผลลัพธ์:

```shell
console.log("one: ", one);

console.log("two: ", two);

console.log("three: ", three);
```

## การจับคู่แบบย้อนกลับ

เพื่อรันคำสั่งทั่วโลกบนบรรทัดที่ไม่ตรงกัน คุณสามารถรัน:

```shell
:g!/pattern/command
```

หรือ

```shell
:v/pattern/command
```

ถ้าคุณรัน `:v/console/d`, มันจะลบบรรทัดทั้งหมดที่ *ไม่มี* "console".

## รูปแบบ

คำสั่งทั่วโลกใช้ระบบรูปแบบเดียวกับคำสั่งแทนที่ ดังนั้นส่วนนี้จะทำหน้าที่เป็นการทบทวน คุณสามารถข้ามไปยังส่วนถัดไปหรืออ่านต่อได้!

ถ้าคุณมีนิพจน์เหล่านี้:

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

เพื่อเอาบรรทัดที่มี "one" หรือ "two" ให้รัน:

```shell
:g/one\|two/d
```

เพื่อเอาบรรทัดที่มีตัวเลขใดๆ ให้รัน:

```shell
:g/[0-9]/d
```

หรือ

```shell
:g/\d/d
```

ถ้าคุณมีนิพจน์:

```shell
const oneMillion = 1000000;
const oneThousand = 1000;
const one = 1;
```

เพื่อจับคู่บรรทัดที่มีศูนย์ระหว่างสามถึงหกตัว ให้รัน:

```shell
:g/0\{3,6\}/d
```

## การส่งช่วง

คุณสามารถส่งช่วงก่อนคำสั่ง `g` ได้ นี่คือวิธีที่คุณสามารถทำได้:
- `:1,5g/console/d` จะตรงกับสตริง "console" ระหว่างบรรทัด 1 ถึง 5 และลบมัน
- `:,5g/console/d` ถ้าไม่มีที่อยู่ก่อนเครื่องหมายจุลภาค มันจะเริ่มจากบรรทัดปัจจุบัน มันจะมองหาสตริง "console" ระหว่างบรรทัดปัจจุบันและบรรทัด 5 และลบมัน
- `:3,g/console/d` ถ้าไม่มีที่อยู่หลังเครื่องหมายจุลภาค มันจะสิ้นสุดที่บรรทัดปัจจุบัน มันจะมองหาสตริง "console" ระหว่างบรรทัด 3 และบรรทัดปัจจุบันและลบมัน
- `:3g/console/d` ถ้าคุณส่งที่อยู่เพียงที่เดียวโดยไม่มีเครื่องหมายจุลภาค มันจะดำเนินการคำสั่งเฉพาะที่บรรทัด 3 มันจะมองที่บรรทัด 3 และลบมันถ้ามีสตริง "console".

นอกจากตัวเลขแล้ว คุณยังสามารถใช้สัญลักษณ์เหล่านี้เป็นช่วง:
- `.` หมายถึงบรรทัดปัจจุบัน ช่วง `.,3` หมายถึงระหว่างบรรทัดปัจจุบันและบรรทัด 3
- `$` หมายถึงบรรทัดสุดท้ายในไฟล์ ช่วง `3,$` หมายถึงระหว่างบรรทัด 3 และบรรทัดสุดท้าย
- `+n` หมายถึง n บรรทัดหลังจากบรรทัดปัจจุบัน คุณสามารถใช้มันกับ `.` หรือไม่ใช้ก็ได้ `3,+1` หรือ `3,.+1` หมายถึงระหว่างบรรทัด 3 และบรรทัดถัดไปหลังจากบรรทัดปัจจุบัน

ถ้าคุณไม่ให้ช่วงใดๆ โดยค่าเริ่มต้นมันจะมีผลต่อไฟล์ทั้งหมด นี่ไม่ใช่เรื่องปกติ คำสั่งในบรรทัดคำสั่งส่วนใหญ่ของ Vim จะทำงานเฉพาะกับบรรทัดปัจจุบันถ้าคุณไม่ส่งช่วงใดๆ สองข้อยกเว้นที่สำคัญคือคำสั่งทั่วโลก (`:g`) และคำสั่งบันทึก (`:w`).

## คำสั่งปกติ

คุณสามารถรันคำสั่งปกติด้วยคำสั่งทั่วโลกด้วยคำสั่งในบรรทัดคำสั่ง `:normal`.

ถ้าคุณมีข้อความนี้:
```shell
const one = 1
console.log("one: ", one)

const two = 2
console.log("two: ", two)

const three = 3
console.log("three: ", three)
```

เพื่อเพิ่ม ";" ที่ท้ายแต่ละบรรทัด ให้รัน:

```shell
:g/./normal A;
```

มาวิเคราะห์กัน:
- `:g` คือคำสั่งทั่วโลก
- `/./` คือรูปแบบสำหรับ "บรรทัดที่ไม่ว่างเปล่า" มันจะตรงกับบรรทัดที่มีอย่างน้อยหนึ่งตัวอักษร ดังนั้นมันจะตรงกับบรรทัดที่มี "const" และ "console" และจะไม่ตรงกับบรรทัดว่างเปล่า
- `normal A;` รันคำสั่งในบรรทัดคำสั่ง `:normal` คำสั่ง `A;` คือคำสั่งในโหมดปกติเพื่อแทรก ";" ที่ท้ายบรรทัด

## การเรียกใช้มาโคร

คุณยังสามารถเรียกใช้มาโครด้วยคำสั่งทั่วโลก มาโครสามารถถูกเรียกใช้ด้วยคำสั่ง `normal` ถ้าคุณมีนิพจน์:

```shell
const one = 1
console.log("one: ", one);

const two = 2
console.log("two: ", two);

const three = 3
console.log("three: ", three);
```

สังเกตว่าบรรทัดที่มี "const" ไม่มีเซมิโคลอน มาสร้างมาโครเพื่อเพิ่มเครื่องหมายจุลภาคที่ท้ายบรรทัดเหล่านั้นในรีจิสเตอร์ a:

```shell
qaA;<Esc>q
```

ถ้าคุณต้องการการทบทวน ให้ตรวจสอบบทเกี่ยวกับมาโคร ตอนนี้รัน:

```shell
:g/const/normal @a
```

ตอนนี้บรรทัดทั้งหมดที่มี "const" จะมี ";" ที่ท้าย.

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

ถ้าคุณทำตามขั้นตอนนี้อย่างละเอียด คุณจะมีเซมิโคลอนสองตัวในบรรทัดแรก เพื่อหลีกเลี่ยงสิ่งนั้น ให้รันคำสั่งทั่วโลกตั้งแต่บรรทัดที่สองเป็นต้นไป `:2,$g/const/normal @a`.

## คำสั่งทั่วโลกแบบวนซ้ำ

คำสั่งทั่วโลกเองเป็นประเภทของคำสั่งในบรรทัดคำสั่ง ดังนั้นคุณสามารถเรียกใช้คำสั่งทั่วโลกภายในคำสั่งทั่วโลกได้

ให้มีนิพจน์ดังต่อไปนี้ ถ้าคุณต้องการลบคำสั่ง `console.log` ที่สอง:

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

ถ้าคุณรัน:

```shell
:g/console/g/two/d
```

ก่อนอื่น `g` จะมองหาบรรทัดที่มีรูปแบบ "console" และจะพบ 3 การจับคู่ จากนั้น `g` ที่สองจะมองหาบรรทัดที่มีรูปแบบ "two" จากการจับคู่สามตัวนั้น สุดท้ายมันจะลบการจับคู่นั้น.

คุณยังสามารถรวม `g` กับ `v` เพื่อค้นหารูปแบบบวกและลบ ตัวอย่างเช่น:

```shell
:g/console/v/two/d
```

แทนที่จะมองหาบรรทัดที่มีรูปแบบ "two" มันจะมองหาบรรทัดที่ *ไม่มี* รูปแบบ "two".

## การเปลี่ยนตัวแบ่ง

คุณสามารถเปลี่ยนตัวแบ่งของคำสั่งทั่วโลกได้เหมือนกับคำสั่งแทนที่ กฎจะเหมือนกัน: คุณสามารถใช้ตัวอักษรไบต์เดียวใดก็ได้ ยกเว้นอักษร, ตัวเลข, `"`, `|`, และ `\`.

เพื่อเอาบรรทัดที่มี "console":

```shell
:g@console@d
```

ถ้าคุณใช้คำสั่งแทนที่กับคำสั่งทั่วโลก คุณสามารถมีตัวแบ่งที่แตกต่างกันสองตัว:

```shell
g@one@s+const+let+g
```

ที่นี่คำสั่งทั่วโลกจะมองหาบรรทัดทั้งหมดที่มี "one" คำสั่งแทนที่จะแทนที่จากการจับคู่เหล่านั้น สตริง "const" ด้วย "let".

## คำสั่งเริ่มต้น

เกิดอะไรขึ้นถ้าคุณไม่ระบุคำสั่งในบรรทัดคำสั่งในคำสั่งทั่วโลก?

คำสั่งทั่วโลกจะใช้คำสั่งพิมพ์ (`:p`) เพื่อพิมพ์ข้อความของบรรทัดปัจจุบัน ถ้าคุณรัน:

```shell
:g/console
```

มันจะพิมพ์ที่ด้านล่างของหน้าจอทุกบรรทัดที่มี "console".

โดยทั่วไปแล้ว นี่คือข้อเท็จจริงที่น่าสนใจ เนื่องจากคำสั่งเริ่มต้นที่ใช้โดยคำสั่งทั่วโลกคือ `p`, ทำให้ไวยากรณ์ `g` เป็น:

```shell
:g/re/p
```

- `g` = คำสั่งทั่วโลก
- `re` = รูปแบบ regex
- `p` = คำสั่งพิมพ์

มันสะกด *"grep"*, เช่นเดียวกับ `grep` จากบรรทัดคำสั่ง นี่ **ไม่ใช่** เรื่องบังเอิญ คำสั่ง `g/re/p` เดิมมาจากโปรแกรม Ed Editor ซึ่งเป็นหนึ่งในโปรแกรมแก้ไขข้อความแบบบรรทัดดั้งเดิม คำสั่ง `grep` ได้ชื่อมาจาก Ed.

คอมพิวเตอร์ของคุณอาจยังมีโปรแกรม Ed Editor รัน `ed` จากเทอร์มินัล (คำแนะนำ: เพื่อออก ให้พิมพ์ `q`).

## การย้อนกลับทั้งบัฟเฟอร์

เพื่อย้อนกลับทั้งไฟล์ ให้รัน:

```shell
:g/^/m 0
```

`^` เป็นรูปแบบสำหรับจุดเริ่มต้นของบรรทัด ใช้ `^` เพื่อจับคู่ทุกบรรทัด รวมถึงบรรทัดว่างเปล่า.

ถ้าคุณต้องการย้อนกลับเพียงไม่กี่บรรทัด ให้ส่งช่วงไปด้วย เพื่อย้อนกลับบรรทัดระหว่างบรรทัดห้าถึงบรรทัดสิบ ให้รัน:

```shell
:5,10g/^/m 0
```

เพื่อเรียนรู้เพิ่มเติมเกี่ยวกับคำสั่งย้าย ให้ตรวจสอบที่ `:h :move`.

## การรวม TODO ทั้งหมด

เมื่อเขียนโค้ด บางครั้งฉันจะเขียน TODO ในไฟล์ที่ฉันกำลังแก้ไข:

```shell
const one = 1;
console.log("one: ", one);
// TODO: feed the puppy

const two = 2;
// TODO: feed the puppy automatically
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
// TODO: create a startup selling an automatic puppy feeder
```

มันอาจยากที่จะติดตาม TODO ทั้งหมดที่สร้างขึ้น Vim มีวิธี `:t` (คัดลอก) เพื่อคัดลอกการจับคู่ทั้งหมดไปยังที่อยู่ เพื่อเรียนรู้เพิ่มเติมเกี่ยวกับวิธีการคัดลอก ให้ตรวจสอบที่ `:h :copy`.

เพื่อคัดลอก TODO ทั้งหมดไปยังท้ายไฟล์เพื่อการตรวจสอบที่ง่ายขึ้น ให้รัน:

```shell
:g/TODO/t $
```

ผลลัพธ์:

```shell
const one = 1;
console.log("one: ", one);
// TODO: feed the puppy

const two = 2;
// TODO: feed the puppy automatically
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
// TODO: create a startup selling an automatic puppy feeder

// TODO: feed the puppy
// TODO: feed the puppy automatically
// TODO: create a startup selling an automatic puppy feeder
```

ตอนนี้ฉันสามารถตรวจสอบ TODO ทั้งหมดที่ฉันสร้างขึ้น หาช่วงเวลาที่จะทำพวกมันหรือมอบหมายให้คนอื่น และดำเนินการต่อไปยังงานถัดไปของฉัน.

ถ้าแทนที่จะคัดลอกพวกมัน คุณต้องการย้าย TODO ทั้งหมดไปยังท้าย ให้ใช้คำสั่งย้าย `:m`:

```shell
:g/TODO/m $
```

ผลลัพธ์:

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);

// TODO: feed the puppy
// TODO: feed the puppy automatically
// TODO: create a startup selling an automatic puppy feeder
```

## การลบแบบหลุมดำ

จำได้จากบทรีจิสเตอร์ว่าข้อความที่ถูกลบจะถูกเก็บไว้ในรีจิสเตอร์หมายเลข (ถ้าขนาดเพียงพอ) ทุกครั้งที่คุณรัน `:g/console/d`, Vim จะเก็บบรรทัดที่ถูกลบในรีจิสเตอร์หมายเลข ถ้าคุณลบบรรทัดหลายบรรทัด คุณอาจเติมรีจิสเตอร์หมายเลขทั้งหมดได้อย่างรวดเร็ว เพื่อหลีกเลี่ยงสิ่งนี้ คุณสามารถใช้รีจิสเตอร์หลุมดำ (`"_`) เพื่อ *ไม่* เก็บบรรทัดที่ถูกลบของคุณในรีจิสเตอร์ รัน:

```shell
:g/console/d_
```

โดยการส่ง `_` หลัง `d`, Vim จะไม่ใช้รีจิสเตอร์สำรองของคุณ.
## ลดหลายบรรทัดว่างให้เหลือเพียงหนึ่งบรรทัดว่าง

ถ้าคุณมีข้อความที่มีหลายบรรทัดว่าง:

```shell
const one = 1;
console.log("one: ", one);


const two = 2;
console.log("two: ", two);





const three = 3;
console.log("three: ", three);
```

คุณสามารถลดบรรทัดว่างให้เหลือเพียงหนึ่งบรรทัดว่างได้อย่างรวดเร็วด้วย:

```shell
:g/^$/,/./-1j
```

ผลลัพธ์:

```shell
const one = 1;
console.log("one: ", one);

const two = 2;
console.log("two: ", two);

const three = 3;
console.log("three: ", three);
```

โดยปกติแล้วคำสั่ง global จะรับรูปแบบต่อไปนี้: `:g/pattern/command` อย่างไรก็ตาม คุณยังสามารถเรียกใช้คำสั่ง global ด้วยรูปแบบต่อไปนี้: `:g/pattern1/,/pattern2/command` ด้วยวิธีนี้ Vim จะใช้ `command` ภายใน `pattern1` และ `pattern2` 

ด้วยความคิดนี้ มาวิเคราะห์คำสั่ง `:g/^$/,/./-1j` ตามรูปแบบ `:g/pattern1/,/pattern2/command`:
- `/pattern1/` คือ `/^$/` ซึ่งแสดงถึงบรรทัดว่าง (บรรทัดที่ไม่มีตัวอักษร)
- `/pattern2/` คือ `/./` พร้อมกับตัวแก้ไขบรรทัด `-1` `/./` แสดงถึงบรรทัดที่ไม่ว่าง (บรรทัดที่มีอย่างน้อยหนึ่งตัวอักษร) `-1` หมายถึงบรรทัดด้านบน
- `command` คือ `j` คำสั่ง join (`:j`) ในบริบทนี้ คำสั่ง global นี้จะรวมบรรทัดทั้งหมดที่กำหนด

โดยที่ถ้าคุณต้องการลดหลายบรรทัดว่างให้เหลือไม่มีบรรทัดเลย ให้เรียกใช้คำสั่งนี้แทน:

```shell
:g/^$/,/./j
```

ทางเลือกที่ง่ายกว่า:

```shell
:g/^$/-j
```

ข้อความของคุณตอนนี้ลดลงเหลือ:

```shell
const one = 1;
console.log("one: ", one);
const two = 2;
console.log("two: ", two);
const three = 3;
console.log("three: ", three);
```

## การจัดเรียงขั้นสูง

Vim มีคำสั่ง `:sort` เพื่อจัดเรียงบรรทัดภายในช่วงหนึ่ง ตัวอย่างเช่น:

```shell
d
b
a
e
c
```

คุณสามารถจัดเรียงได้โดยการเรียกใช้ `:sort` หากคุณให้ช่วง มันจะจัดเรียงเฉพาะบรรทัดภายในช่วงนั้น ตัวอย่างเช่น `:3,5sort` จะจัดเรียงเฉพาะบรรทัดที่สามและห้า

ถ้าคุณมีนิพจน์ต่อไปนี้:

```shell
const arrayB = [
  "i",
  "g",
  "h",
  "b",
  "f",
  "d",
  "e",
  "c",
  "a",
]

const arrayA = [
  "h",
  "b",
  "f",
  "d",
  "e",
  "a",
  "c",
]
```

ถ้าคุณต้องการจัดเรียงองค์ประกอบภายในอาร์เรย์ แต่ไม่ต้องการจัดเรียงอาร์เรย์เอง คุณสามารถเรียกใช้คำสั่งนี้:

```shell
:g/\[/+1,/\]/-1sort
```

ผลลัพธ์:

```shell
const arrayB = [
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
]

const arrayA = [
  "a"
  "b",
  "c",
  "d",
  "e",
  "f",
  "h",
]
```

นี่เยี่ยมมาก! แต่คำสั่งดูซับซ้อน มาวิเคราะห์กัน คำสั่งนี้ยังคงตามรูปแบบ `:g/pattern1/,/pattern2/command`

- `:g` คือรูปแบบคำสั่ง global
- `/\[/+1` คือรูปแบบแรก มันจับคู่กับสัญลักษณ์วงเล็บเหลี่ยมซ้าย "[" `+1` หมายถึงบรรทัดด้านล่าง
- `/\]/-1` คือรูปแบบที่สอง มันจับคู่กับสัญลักษณ์วงเล็บเหลี่ยมขวา "]" `-1` หมายถึงบรรทัดด้านบน
- `/\[/+1,/\]/-1` หมายถึงบรรทัดใด ๆ ระหว่าง "[" และ "]"
- `sort` คือคำสั่งในบรรทัดเพื่อจัดเรียง

## เรียนรู้คำสั่ง Global อย่างชาญฉลาด

คำสั่ง global จะดำเนินการคำสั่งในบรรทัดกับบรรทัดที่ตรงกันทั้งหมด ด้วยมัน คุณเพียงแค่ต้องเรียกใช้คำสั่งครั้งเดียวและ Vim จะทำที่เหลือให้คุณ เพื่อให้เชี่ยวชาญในคำสั่ง global ต้องการสองสิ่ง: คำศัพท์ที่ดีของคำสั่งในบรรทัดและความรู้เกี่ยวกับนิพจน์ปกติ ขณะที่คุณใช้ Vim มากขึ้น คุณจะเรียนรู้คำสั่งในบรรทัดมากขึ้นโดยธรรมชาติ ความรู้เกี่ยวกับนิพจน์ปกติจะต้องการวิธีการที่มีความกระตือรือร้นมากขึ้น แต่เมื่อคุณรู้สึกสบายใจกับนิพจน์ปกติ คุณจะอยู่ข้างหน้าหลายคน

ตัวอย่างบางอย่างที่นี่อาจซับซ้อน อย่ารู้สึกหวาดกลัว ใช้เวลาในการทำความเข้าใจพวกเขา เรียนรู้ที่จะอ่านรูปแบบ อย่ายอมแพ้

เมื่อใดก็ตามที่คุณต้องการเรียกใช้หลายคำสั่ง ให้หยุดและดูว่าคุณสามารถใช้คำสั่ง `g` ได้หรือไม่ ระบุคำสั่งที่ดีที่สุดสำหรับงานและเขียนรูปแบบเพื่อกำหนดเป้าหมายหลายสิ่งในครั้งเดียว

ตอนนี้ที่คุณรู้ว่าคำสั่ง global มีพลังแค่ไหน มาศึกษาวิธีการใช้คำสั่งภายนอกเพื่อเพิ่มเครื่องมือของคุณกันเถอะ