---
description: เรียนรู้การใช้คำสั่งจุด (dot command) ใน Vim เพื่อทำซ้ำการเปลี่ยนแปลงล่าสุดอย่างมีประสิทธิภาพ
  ลดการพิมพ์ซ้ำที่ไม่จำเป็น
title: Ch07. the Dot Command
---

โดยทั่วไปแล้ว คุณควรพยายามหลีกเลี่ยงการทำสิ่งที่คุณเพิ่งทำไปเมื่อใดก็ตามที่เป็นไปได้ ในบทนี้ คุณจะได้เรียนรู้วิธีการใช้คำสั่งจุดเพื่อทำการทำซ้ำการเปลี่ยนแปลงก่อนหน้าได้อย่างง่ายดาย มันเป็นคำสั่งที่มีความหลากหลายสำหรับการลดการทำซ้ำที่ง่าย

## การใช้งาน

เหมือนกับชื่อของมัน คุณสามารถใช้คำสั่งจุดโดยการกดปุ่มจุด (`.`)

ตัวอย่างเช่น หากคุณต้องการแทนที่ "let" ทั้งหมดด้วย "const" ในการแสดงออกต่อไปนี้:

```shell
let one = "1";
let two = "2";
let three = "3";
```

- ค้นหาด้วย `/let` เพื่อไปยังการจับคู่
- เปลี่ยนด้วย `cwconst<Esc>` เพื่อแทนที่ "let" ด้วย "const"
- นำทางด้วย `n` เพื่อค้นหาการจับคู่ถัดไปโดยใช้การค้นหาก่อนหน้า
- ทำซ้ำสิ่งที่คุณเพิ่งทำด้วยคำสั่งจุด (`.`)
- ดำเนินการกด `n . n .` ต่อไปจนกว่าคุณจะแทนที่ทุกคำ

ที่นี่คำสั่งจุดทำการทำซ้ำลำดับ `cwconst<Esc>` มันช่วยคุณจากการพิมพ์แปดครั้งในราคาเพียงหนึ่งครั้ง

## การเปลี่ยนแปลงคืออะไร?

หากคุณดูที่คำจำกัดความของคำสั่งจุด (`:h .`) มันบอกว่าคำสั่งจุดทำการทำซ้ำการเปลี่ยนแปลงล่าสุด การเปลี่ยนแปลงคืออะไร?

ทุกครั้งที่คุณอัปเดต (เพิ่ม แก้ไข หรือ ลบ) เนื้อหาของบัฟเฟอร์ปัจจุบัน คุณกำลังทำการเปลี่ยนแปลง ข้อยกเว้นคือการอัปเดตที่ทำโดยคำสั่งในบรรทัดคำสั่ง (คำสั่งที่เริ่มต้นด้วย `:`) จะไม่นับเป็นการเปลี่ยนแปลง

ในตัวอย่างแรก `cwconst<Esc>` คือการเปลี่ยนแปลง ตอนนี้สมมติว่าคุณมีข้อความนี้:

```shell
pancake, potatoes, fruit-juice,
```

เพื่อลบข้อความจากจุดเริ่มต้นของบรรทัดไปยังการเกิดขึ้นถัดไปของเครื่องหมายจุลภาค ก่อนอื่นให้ลบไปยังเครื่องหมายจุลภาค จากนั้นทำซ้ำสองครั้งด้วย `df,..` 

ลองตัวอย่างอีกหนึ่ง:

```shell
pancake, potatoes, fruit-juice,
```

ครั้งนี้ งานของคุณคือการลบเครื่องหมายจุลภาค ไม่ใช่รายการอาหารเช้า ด้วยเคอร์เซอร์ที่จุดเริ่มต้นของบรรทัด ไปยังเครื่องหมายจุลภาคแรก ลบมัน จากนั้นทำซ้ำอีกสองครั้งด้วย `f,x..` ง่ายใช่ไหม? รอสักครู่ มันไม่ได้ผล! ทำไม?

การเปลี่ยนแปลงไม่รวมการเคลื่อนไหวเพราะมันไม่อัปเดตเนื้อหาของบัฟเฟอร์ คำสั่ง `f,x` ประกอบด้วยสองการกระทำ: คำสั่ง `f,` เพื่อเคลื่อนที่เคอร์เซอร์ไปยัง "," และ `x` เพื่อลบอักขระ เท่านั้นที่เป็นการเปลี่ยนแปลงคือ `x` เปรียบเทียบกับ `df,` จากตัวอย่างก่อนหน้า ในที่นี้ `f,` เป็นคำสั่งให้กับตัวดำเนินการลบ `d` ไม่ใช่การเคลื่อนไหวเพื่อเคลื่อนที่เคอร์เซอร์ `f,` ใน `df,` และ `f,x` มีบทบาทที่แตกต่างกันมาก

มาทำภารกิจสุดท้ายกัน หลังจากที่คุณรัน `f,` แล้ว `x` ไปยังเครื่องหมายจุลภาคถัดไปด้วย `;` เพื่อทำซ้ำ `f` ล่าสุด สุดท้าย ใช้ `.` เพื่อลบอักขระใต้เคอร์เซอร์ ทำซ้ำ `; . ; .` จนกว่าทุกอย่างจะถูกลบ คำสั่งทั้งหมดคือ `f,x;.;.`

ลองอีกหนึ่ง:

```shell
pancake
potatoes
fruit-juice
```

มาลงเครื่องหมายจุลภาคที่ท้ายแต่ละบรรทัด เริ่มจากบรรทัดแรก ทำ `A,<Esc>j` จนถึงตอนนี้ คุณตระหนักว่า `j` ไม่ทำให้เกิดการเปลี่ยนแปลง การเปลี่ยนแปลงที่นี่มีเพียง `A,` คุณสามารถเคลื่อนที่และทำซ้ำการเปลี่ยนแปลงด้วย `j . j .` คำสั่งทั้งหมดคือ `A,<Esc>j.j.`

ทุกการกระทำตั้งแต่ช่วงเวลาที่คุณกดคำสั่งแทรก (`A`) จนถึงการออกจากคำสั่งแทรก (`<Esc>`) ถือเป็นการเปลี่ยนแปลง

## การทำซ้ำหลายบรรทัด

สมมติว่าคุณมีข้อความนี้:

```shell
let one = "1";
let two = "2";
let three = "3";
const foo = "bar';
let four = "4";
let five = "5";
let six = "6";
let seven = "7";
let eight = "8";
let nine = "9";
```

เป้าหมายของคุณคือการลบทุกบรรทัดยกเว้นบรรทัด "foo" ก่อนอื่นให้ลบสามบรรทัดแรกด้วย `d2j` จากนั้นไปยังบรรทัดด้านล่างของบรรทัด "foo" ในบรรทัดถัดไป ใช้คำสั่งจุดสองครั้ง คำสั่งทั้งหมดคือ `d2jj..`

ที่นี่การเปลี่ยนแปลงคือ `d2j` ในบริบทนี้ `2j` ไม่ใช่การเคลื่อนไหว แต่เป็นส่วนหนึ่งของตัวดำเนินการลบ

มาดูตัวอย่างอีกหนึ่ง:

```shell
zlet zzone = "1";
zlet zztwo = "2";
zlet zzthree = "3";
let four = "4";
```

มาลบตัว z ทั้งหมด เริ่มจากอักขระแรกในบรรทัดแรก เลือกอย่างมองเห็นเฉพาะ z ตัวแรกจากสามบรรทัดแรกด้วยโหมดเลือกแบบบล็อก (`Ctrl-Vjj`) หากคุณไม่คุ้นเคยกับโหมดเลือกแบบบล็อก ฉันจะพูดถึงในบทถัดไป เมื่อคุณเลือก z สามตัวอย่างมองเห็นแล้ว ให้ลบด้วยตัวดำเนินการลบ (`d`) จากนั้นเคลื่อนไปยังคำถัดไป (`w`) ไปยัง z ถัดไป ทำซ้ำการเปลี่ยนแปลงอีกสองครั้ง (`..`) คำสั่งทั้งหมดคือ `Ctrl-vjjdw..`

เมื่อคุณลบคอลัมน์ของ z สามตัว (`Ctrl-vjjd`) มันถูกนับเป็นการเปลี่ยนแปลง การดำเนินการในโหมดมองเห็นสามารถใช้เพื่อกำหนดเป้าหมายหลายบรรทัดเป็นส่วนหนึ่งของการเปลี่ยนแปลง

## รวมการเคลื่อนไหวในการเปลี่ยนแปลง

มาทบทวนตัวอย่างแรกในบทนี้ จำได้ว่าคำสั่ง `/letcwconst<Esc>` ตามด้วย `n . n .` แทนที่ "let" ทั้งหมดด้วย "const" ในการแสดงออกต่อไปนี้:

```shell
let one = "1";
let two = "2";
let three = "3";
```

มีวิธีที่เร็วกว่าในการทำสิ่งนี้ หลังจากที่คุณค้นหา `/let` ให้รัน `cgnconst<Esc>` แล้ว `. .`

`gn` เป็นการเคลื่อนไหวที่ค้นหาข้างหน้าเพื่อหาลวดลายการค้นหาล่าสุด (ในกรณีนี้คือ `/let`) และทำการเน้นแบบมองเห็นโดยอัตโนมัติ เพื่อแทนที่การเกิดขึ้นถัดไป คุณไม่ต้องเคลื่อนที่และทำซ้ำการเปลี่ยนแปลง (`n . n .`) แต่เพียงแค่ทำซ้ำ (`. .`) คุณไม่จำเป็นต้องใช้การเคลื่อนไหวการค้นหาอีกต่อไปเพราะการค้นหาการจับคู่ถัดไปตอนนี้เป็นส่วนหนึ่งของการเปลี่ยนแปลง!

เมื่อคุณกำลังแก้ไข ให้มองหาการเคลื่อนไหวที่สามารถทำหลายสิ่งในครั้งเดียวเช่น `gn` เมื่อใดก็ตามที่เป็นไปได้

## เรียนรู้คำสั่งจุดอย่างชาญฉลาด

พลังของคำสั่งจุดมาจากการแลกเปลี่ยนหลายการกดปุ่มเป็นหนึ่งครั้ง มันอาจจะไม่คุ้มค่าที่จะใช้คำสั่งจุดสำหรับการดำเนินการด้วยปุ่มเดียวเช่น `x` หากการเปลี่ยนแปลงล่าสุดของคุณต้องการการดำเนินการที่ซับซ้อนเช่น `cgnconst<Esc>` คำสั่งจุดจะลดการกดปุ่มเก้าครั้งให้เหลือหนึ่งครั้ง ซึ่งเป็นการแลกเปลี่ยนที่คุ้มค่า

เมื่อแก้ไข ให้คิดเกี่ยวกับความสามารถในการทำซ้ำ ตัวอย่างเช่น หากฉันต้องการลบคำถัดไปสามคำ มันจะประหยัดกว่าที่จะใช้ `d3w` หรือทำ `dw` แล้ว `.` สองครั้ง? คุณจะลบคำอีกครั้งไหม? ถ้าใช่ มันก็สมเหตุสมผลที่จะใช้ `dw` และทำซ้ำหลายครั้งแทนที่จะใช้ `d3w` เพราะ `dw` ใช้งานซ้ำได้มากกว่า `d3w` 

คำสั่งจุดเป็นคำสั่งที่หลากหลายสำหรับการทำให้การเปลี่ยนแปลงเดียวเป็นอัตโนมัติ ในบทถัดไป คุณจะได้เรียนรู้วิธีการทำให้การกระทำที่ซับซ้อนมากขึ้นเป็นอัตโนมัติด้วยมาโครของ Vim แต่ก่อนอื่น มาศึกษาเกี่ยวกับรีจิสเตอร์เพื่อจัดเก็บและเรียกคืนข้อความกันเถอะ