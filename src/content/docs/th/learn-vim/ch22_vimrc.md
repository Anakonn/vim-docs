---
description: ในเอกสารนี้ คุณจะได้เรียนรู้วิธีการจัดระเบียบและกำหนดค่าไฟล์ vimrc รวมถึงวิธีที่
  Vim ค้นหาไฟล์ vimrc ในระบบต่างๆ
title: Ch22. Vimrc
---

ในบทก่อนหน้านี้ คุณได้เรียนรู้วิธีการใช้ Vim ในบทนี้ คุณจะได้เรียนรู้วิธีการจัดระเบียบและกำหนดค่า vimrc

## Vim ค้นหา Vimrc อย่างไร

ความรู้ทั่วไปเกี่ยวกับ vimrc คือการเพิ่มไฟล์จุด `.vimrc` ในไดเรกทอรีบ้าน `~/.vimrc` (อาจแตกต่างกันไปตามระบบปฏิบัติการของคุณ)

เบื้องหลัง Vim จะมองหาหลายที่สำหรับไฟล์ vimrc นี่คือสถานที่ที่ Vim ตรวจสอบ:
- `$VIMINIT`
- `$HOME/.vimrc`
- `$HOME/.vim/vimrc`
- `$EXINIT`
- `$HOME/.exrc`
- `$VIMRUNTIME/defaults.vim`

เมื่อคุณเริ่ม Vim มันจะตรวจสอบหกตำแหน่งข้างต้นตามลำดับสำหรับไฟล์ vimrc ไฟล์ vimrc ที่พบเป็นไฟล์แรกจะถูกใช้และไฟล์ที่เหลือจะถูกละเลย

Vim จะมองหาที่ `$VIMINIT` ก่อน หากไม่มีอะไรอยู่ที่นั่น Vim จะตรวจสอบที่ `$HOME/.vimrc` หากไม่มีอะไรอยู่ที่นั่น Vim จะตรวจสอบที่ `$HOME/.vim/vimrc` หาก Vim พบมัน มันจะหยุดค้นหาและใช้ `$HOME/.vim/vimrc`

ตำแหน่งแรก `$VIMINIT` เป็นตัวแปรสภาพแวดล้อม โดยค่าเริ่มต้นจะไม่มีการกำหนด หากคุณต้องการใช้ `~/dotfiles/testvimrc` เป็นค่าของ `$VIMINIT` คุณสามารถสร้างตัวแปรสภาพแวดล้อมที่มีเส้นทางของ vimrc นั้น หลังจากที่คุณรัน `export VIMINIT='let $MYVIMRC="$HOME/dotfiles/testvimrc" | source $MYVIMRC'` Vim จะใช้ `~/dotfiles/testvimrc` เป็นไฟล์ vimrc ของคุณ

ตำแหน่งที่สอง `$HOME/.vimrc` เป็นเส้นทางทั่วไปสำหรับผู้ใช้ Vim หลายคน `$HOME` ในหลายกรณีคือไดเรกทอรีบ้านของคุณ (`~`) หากคุณมีไฟล์ `~/.vimrc` Vim จะใช้ไฟล์นี้เป็นไฟล์ vimrc ของคุณ

ตำแหน่งที่สาม `$HOME/.vim/vimrc` ตั้งอยู่ภายในไดเรกทอรี `~/.vim` คุณอาจมีไดเรกทอรี `~/.vim` สำหรับปลั๊กอิน สคริปต์ที่กำหนดเอง หรือไฟล์ View โปรดทราบว่าไม่มีจุดในชื่อไฟล์ vimrc (`$HOME/.vim/.vimrc` จะไม่ทำงาน แต่ `$HOME/.vim/vimrc` จะทำงาน)

ตำแหน่งที่สี่ `$EXINIT` ทำงานคล้ายกับ `$VIMINIT`

ตำแหน่งที่ห้า `$HOME/.exrc` ทำงานคล้ายกับ `$HOME/.vimrc`

ตำแหน่งที่หก `$VIMRUNTIME/defaults.vim` เป็น vimrc เริ่มต้นที่มาพร้อมกับการติดตั้ง Vim ของคุณ ในกรณีของฉัน ฉันมี Vim 8.2 ติดตั้งโดยใช้ Homebrew ดังนั้นเส้นทางของฉันคือ (`/usr/local/share/vim/vim82`) หาก Vim ไม่พบไฟล์ vimrc หกไฟล์ข้างต้น มันจะใช้ไฟล์นี้

สำหรับส่วนที่เหลือของบทนี้ ฉันจะสมมติว่า vimrc ใช้เส้นทาง `~/.vimrc`

## ควรใส่อะไรใน Vimrc ของฉัน?

คำถามที่ฉันถามเมื่อเริ่มต้นคือ "ฉันควรใส่อะไรใน vimrc ของฉัน?"

คำตอบคือ "อะไรก็ได้ที่คุณต้องการ" ความล่อลวงในการคัดลอกและวาง vimrc ของคนอื่นเป็นสิ่งที่มีอยู่จริง แต่คุณควรต้านทานมัน หากคุณยืนยันที่จะใช้ vimrc ของคนอื่น ให้แน่ใจว่าคุณรู้ว่ามันทำอะไร ทำไมและเขา/เธอใช้มันอย่างไร และที่สำคัญที่สุดคือมันเกี่ยวข้องกับคุณหรือไม่ เพียงเพราะมีคนใช้มันไม่ได้หมายความว่าคุณจะใช้มันด้วย

## เนื้อหาพื้นฐานของ Vimrc

โดยสรุป vimrc คือการรวบรวมของ:
- ปลั๊กอิน
- การตั้งค่า
- ฟังก์ชันที่กำหนดเอง
- คำสั่งที่กำหนดเอง
- การแมพ

มีสิ่งอื่น ๆ ที่ไม่ได้กล่าวถึงข้างต้น แต่โดยทั่วไปแล้ว สิ่งนี้ครอบคลุมกรณีการใช้งานส่วนใหญ่

### ปลั๊กอิน

ในบทก่อนหน้านี้ ฉันได้กล่าวถึงปลั๊กอินต่าง ๆ เช่น [fzf.vim](https://github.com/junegunn/fzf.vim), [vim-mundo](https://github.com/simnalamburt/vim-mundo), และ [vim-fugitive](https://github.com/tpope/vim-fugitive)

เมื่อสิบปีที่แล้ว การจัดการปลั๊กอินเป็นฝันร้าย อย่างไรก็ตาม ด้วยการเกิดขึ้นของผู้จัดการปลั๊กอินสมัยใหม่ การติดตั้งปลั๊กอินสามารถทำได้ในไม่กี่วินาที ขณะนี้ฉันกำลังใช้ [vim-plug](https://github.com/junegunn/vim-plug) เป็นผู้จัดการปลั๊กอินของฉัน ดังนั้นฉันจะใช้มันในส่วนนี้ แนวคิดควรจะคล้ายกับผู้จัดการปลั๊กอินยอดนิยมอื่น ๆ ฉันขอแนะนำให้คุณตรวจสอบผู้จัดการปลั๊กอินที่แตกต่างกัน เช่น:
- [vundle.vim](https://github.com/VundleVim/Vundle.vim)
- [vim-pathogen](https://github.com/tpope/vim-pathogen)
- [dein.vim](https://github.com/Shougo/dein.vim)

มีผู้จัดการปลั๊กอินมากกว่าที่ระบุไว้ข้างต้น โปรดรู้สึกอิสระที่จะมองไปรอบ ๆ เพื่อทำการติดตั้ง vim-plug หากคุณมีเครื่อง Unix ให้รัน:

```shell
curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```

ในการเพิ่มปลั๊กอินใหม่ ให้วางชื่อปลั๊กอินของคุณ (`Plug 'github-username/repository-name'`) ระหว่างบรรทัด `call plug#begin()` และ `call plug#end()` ดังนั้นหากคุณต้องการติดตั้ง `emmet-vim` และ `nerdtree` ให้ใส่โค้ดต่อไปนี้ลงใน vimrc ของคุณ:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

บันทึกการเปลี่ยนแปลง แหล่งที่มา (`:source %`) และรัน `:PlugInstall` เพื่อติดตั้งพวกเขา

ในอนาคตหากคุณต้องการลบปลั๊กอินที่ไม่ได้ใช้งาน คุณเพียงแค่ต้องลบชื่อปลั๊กอินจากบล็อก `call` บันทึกและแหล่งที่มา และรันคำสั่ง `:PlugClean` เพื่อลบออกจากเครื่องของคุณ

Vim 8 มีผู้จัดการแพ็คเกจในตัวของตัวเอง คุณสามารถตรวจสอบ `:h packages` สำหรับข้อมูลเพิ่มเติม ในบทถัดไป ฉันจะแสดงวิธีการใช้มัน

### การตั้งค่า

เป็นเรื่องปกติที่จะเห็นตัวเลือก `set` จำนวนมากใน vimrc ใด ๆ หากคุณรันคำสั่ง set จากโหมดบรรทัดคำสั่ง มันจะไม่ถาวร คุณจะสูญเสียมันเมื่อคุณปิด Vim ตัวอย่างเช่น แทนที่จะรัน `:set relativenumber number` จากโหมดบรรทัดคำสั่งทุกครั้งที่คุณรัน Vim คุณสามารถใส่สิ่งเหล่านี้ไว้ใน vimrc:

```shell
set relativenumber number
```

การตั้งค่าบางอย่างต้องการให้คุณส่งค่ามัน เช่น `set tabstop=2` ตรวจสอบหน้าช่วยเหลือสำหรับการตั้งค่าแต่ละอย่างเพื่อเรียนรู้ว่ามันรับค่าประเภทใดบ้าง

คุณยังสามารถใช้ `let` แทน `set` (ให้แน่ใจว่าต้องใส่ `&` ข้างหน้า) ด้วย `let` คุณสามารถใช้การแสดงออกเป็นค่า ตัวอย่างเช่น เพื่อกำหนดตัวเลือก `'dictionary'` เป็นเส้นทางเฉพาะก็ต่อเมื่อเส้นทางนั้นมีอยู่:

```shell
let s:english_dict = "/usr/share/dict/words"

if filereadable(s:english_dict)
  let &dictionary=s:english_dict
endif
```

คุณจะได้เรียนรู้เกี่ยวกับการกำหนดค่าและเงื่อนไขใน Vimscript ในบทถัดไป

สำหรับรายการตัวเลือกทั้งหมดที่เป็นไปได้ใน Vim ให้ตรวจสอบ `:h E355`

### ฟังก์ชันที่กำหนดเอง

Vimrc เป็นสถานที่ที่ดีสำหรับฟังก์ชันที่กำหนดเอง คุณจะได้เรียนรู้วิธีการเขียนฟังก์ชัน Vimscript ของคุณเองในบทถัดไป

### คำสั่งที่กำหนดเอง

คุณสามารถสร้างคำสั่งบรรทัดคำสั่งที่กำหนดเองด้วย `command`

เพื่อสร้างคำสั่งพื้นฐาน `GimmeDate` เพื่อแสดงวันที่ของวันนี้:

```shell
:command! GimmeDate echo call("strftime", ["%F"])
```

เมื่อคุณรัน `:GimmeDate` Vim จะแสดงวันที่เช่น "2021-01-1"

เพื่อสร้างคำสั่งพื้นฐานที่มีการป้อนข้อมูล คุณสามารถใช้ `<args>` หากคุณต้องการส่งรูปแบบเวลา/วันที่เฉพาะไปยัง `GimmeDate`:

```shell
:command! GimmeDate echo call("strftime", [<args>])

:GimmeDate "%F"
" 2020-01-01

:GimmeDate "%H:%M"
" 11:30
```

หากคุณต้องการจำกัดจำนวนอาร์กิวเมนต์ คุณสามารถส่งธง `-nargs` ใช้ `-nargs=0` เพื่อส่งอาร์กิวเมนต์ไม่มี, `-nargs=1` เพื่อส่งอาร์กิวเมนต์หนึ่ง, `-nargs=+` เพื่อส่งอย่างน้อยหนึ่งอาร์กิวเมนต์, `-nargs=*` เพื่อส่งอาร์กิวเมนต์จำนวนใด ๆ และ `-nargs=?` เพื่อส่ง 0 หรือหนึ่งอาร์กิวเมนต์ หากคุณต้องการส่งอาร์กิวเมนต์ที่ n ให้ใช้ `-nargs=n` (โดยที่ `n` เป็นจำนวนเต็มใด ๆ)

`<args>` มีสองรูปแบบ: `<f-args>` และ `<q-args>` รูปแบบแรกใช้เพื่อส่งอาร์กิวเมนต์ไปยังฟังก์ชัน Vimscript รูปแบบหลังใช้เพื่อแปลงข้อมูลที่ผู้ใช้ป้อนเป็นสตริงโดยอัตโนมัติ

การใช้ `args`:

```shell
:command! -nargs=1 Hello echo "Hello " . <args>
:Hello "Iggy"
" returns 'Hello Iggy'

:Hello Iggy
" Undefined variable error
```

การใช้ `q-args`:

```shell
:command! -nargs=1 Hello echo "Hello " . <q-args>
:Hello Iggy
" returns 'Hello Iggy'
```

การใช้ `f-args`:

```shell
:function! PrintHello(person1, person2)
:  echo "Hello " . a:person1 . " and " . a:person2
:endfunction

:command! -nargs=* Hello call PrintHello(<f-args>)

:Hello Iggy1 Iggy2
" returns "Hello Iggy1 and Iggy2"
```

ฟังก์ชันข้างต้นจะมีความหมายมากขึ้นเมื่อคุณไปถึงบทฟังก์ชัน Vimscript

หากต้องการเรียนรู้เพิ่มเติมเกี่ยวกับคำสั่งและ args ให้ตรวจสอบ `:h command` และ `:args`
### แผนที่

หากคุณพบว่าตัวเองทำงานที่ซับซ้อนซ้ำ ๆ นี่เป็นสัญญาณที่ดีว่าคุณควรสร้างการแมพสำหรับงานนั้น

ตัวอย่างเช่น ฉันมีการแมพสองอันใน vimrc ของฉัน:

```shell
nnoremap <silent> <C-f> :GFiles<CR>

nnoremap <Leader>tn :call ToggleNumber()<CR>
```

ในอันแรก ฉันแมพ `Ctrl-F` ไปที่คำสั่ง `:Gfiles` ของปลั๊กอิน [fzf.vim](https://github.com/junegunn/fzf.vim) (ค้นหาไฟล์ Git อย่างรวดเร็ว) ในอันที่สอง ฉันแมพ `<Leader>tn` เพื่อเรียกฟังก์ชันที่กำหนดเอง `ToggleNumber` (สลับตัวเลือก `norelativenumber` และ `relativenumber`) การแมพ `Ctrl-F` จะเขียนทับการเลื่อนหน้าของ Vim การแมพของคุณจะเขียนทับการควบคุมของ Vim หากมีการชนกัน เนื่องจากฉันแทบจะไม่เคยใช้ฟีเจอร์นั้น ฉันจึงตัดสินใจว่ามันปลอดภัยที่จะเขียนทับ

โดยเฉพาะอย่างยิ่ง "คีย์ผู้นำ" ใน `<Leader>tn` คืออะไร?

Vim มีคีย์ผู้นำเพื่อช่วยในการแมพ ตัวอย่างเช่น ฉันแมพ `<Leader>tn` เพื่อเรียกฟังก์ชัน `ToggleNumber()` หากไม่มีคีย์ผู้นำ ฉันจะใช้ `tn` แต่ Vim มี `t` อยู่แล้ว (การนำทางการค้นหา "till") ด้วยคีย์ผู้นำ ตอนนี้ฉันสามารถกดคีย์ที่กำหนดเป็นผู้นำ จากนั้น `tn` โดยไม่รบกวนคำสั่งที่มีอยู่ คีย์ผู้นำคือคีย์ที่คุณสามารถตั้งค่าเพื่อเริ่มชุดการแมพของคุณ โดยค่าเริ่มต้น Vim ใช้แบ็คสแลชเป็นคีย์ผู้นำ (ดังนั้น `<Leader>tn` จึงกลายเป็น "แบ็คสแลช-t-n")

ฉันชอบใช้ `<Space>` เป็นคีย์ผู้นำแทนค่าเริ่มต้นแบ็คสแลช เพื่อเปลี่ยนคีย์ผู้นำของคุณ ให้เพิ่มสิ่งนี้ใน vimrc ของคุณ:

```shell
let mapleader = "\<space>"
```

คำสั่ง `nnoremap` ที่ใช้ข้างต้นสามารถแบ่งออกเป็นสามส่วน:
- `n` แทนโหมดปกติ
- `nore` หมายถึงไม่ทำซ้ำ
- `map` คือคำสั่งแมพ

อย่างน้อย คุณสามารถใช้ `nmap` แทน `nnoremap` (`nmap <silent> <C-f> :Gfiles<CR>`) อย่างไรก็ตาม เป็นการดีที่จะใช้ตัวแปรที่ไม่ทำซ้ำเพื่อหลีกเลี่ยงการวนลูปที่อาจเกิดขึ้น

นี่คือสิ่งที่อาจเกิดขึ้นหากคุณไม่แมพแบบไม่ทำซ้ำ สมมติว่าคุณต้องการเพิ่มการแมพไปที่ `B` เพื่อเพิ่มเซมิ-โคลอนที่ท้ายบรรทัด จากนั้นกลับไปหนึ่ง WORD (จำไว้ว่าการกด `B` ใน Vim คือคีย์นำทางในโหมดปกติเพื่อย้อนกลับหนึ่ง WORD)

```shell
nmap B A;<esc>B
```

เมื่อคุณกด `B`... โอ้ไม่! Vim เพิ่ม `;` อย่างควบคุมไม่ได้ (หยุดด้วย `Ctrl-C`) ทำไมถึงเกิดขึ้น? เพราะในการแมพ `A;<esc>B` ตัว `B` ไม่ได้หมายถึงฟังก์ชัน `B` ของ Vim (ย้อนกลับหนึ่ง WORD) แต่หมายถึงฟังก์ชันที่ถูกแมพ สิ่งที่คุณมีจริง ๆ คือ:

```shell
A;<esc>A;<esc>A;<esc>A;esc>...
```

เพื่อแก้ปัญหานี้ คุณต้องเพิ่มการแมพแบบไม่ทำซ้ำ:

```shell
nnoremap B A;<esc>B
```

ตอนนี้ลองเรียก `B` อีกครั้ง ครั้งนี้จะเพิ่ม `;` ที่ท้ายบรรทัดและย้อนกลับหนึ่ง WORD ได้สำเร็จ ตัว `B` ในการแมพนี้แทนฟังก์ชัน `B` ดั้งเดิมของ Vim

Vim มีการแมพที่แตกต่างกันสำหรับโหมดที่แตกต่างกัน หากคุณต้องการสร้างการแมพสำหรับโหมดการแทรกเพื่อออกจากโหมดการแทรกเมื่อคุณกด `jk`:

```shell
inoremap jk <esc>
```

โหมดการแมพอื่น ๆ ได้แก่: `map` (ปกติ, วิชวล, เลือก, และรอการดำเนินการ), `vmap` (วิชวลและเลือก), `smap` (เลือก), `xmap` (วิชวล), `omap` (รอการดำเนินการ), `map!` (การแทรกและบรรทัดคำสั่ง), `lmap` (การแทรก, บรรทัดคำสั่ง, Lang-arg), `cmap` (บรรทัดคำสั่ง), และ `tmap` (งานเทอร์มินัล) ฉันจะไม่พูดถึงรายละเอียดของพวกเขา หากต้องการเรียนรู้เพิ่มเติม ให้ตรวจสอบ `:h map.txt`

สร้างการแมพที่เข้าใจง่าย สอดคล้อง และจำง่าย

## การจัดระเบียบ Vimrc

เมื่อเวลาผ่านไป vimrc ของคุณจะขยายใหญ่ขึ้นและซับซ้อน มีสองวิธีในการทำให้ vimrc ของคุณดูสะอาด:
- แบ่ง vimrc ของคุณออกเป็นหลายไฟล์
- พับไฟล์ vimrc ของคุณ

### การแบ่ง vimrc ของคุณ

คุณสามารถแบ่ง vimrc ของคุณออกเป็นหลายไฟล์โดยใช้คำสั่ง `source` ของ Vim คำสั่งนี้อ่านคำสั่งจากไฟล์ที่กำหนด

มาสร้างไฟล์ภายในไดเรกทอรี `~/.vim` และตั้งชื่อว่า `/settings` (`~/.vim/settings`) ชื่อเองเป็นเรื่องสุ่มและคุณสามารถตั้งชื่ออะไรก็ได้ที่คุณชอบ

คุณจะต้องแบ่งออกเป็นสี่ส่วน:
- ปลั๊กอินของบุคคลที่สาม (`~/.vim/settings/plugins.vim`)
- การตั้งค่าทั่วไป (`~/.vim/settings/configs.vim`)
- ฟังก์ชันที่กำหนดเอง (`~/.vim/settings/functions.vim`)
- การแมพคีย์ (`~/.vim/settings/mappings.vim`)

ภายใน `~/.vimrc`:

```shell
source $HOME/.vim/settings/plugins.vim
source $HOME/.vim/settings/configs.vim
source $HOME/.vim/settings/functions.vim
source $HOME/.vim/settings/mappings.vim
```

คุณสามารถแก้ไขไฟล์เหล่านี้ได้โดยการวางเคอร์เซอร์ใต้เส้นทางและกด `gf`

ภายใน `~/.vim/settings/plugins.vim`:

```shell
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
```

ภายใน `~/.vim/settings/configs.vim`:

```shell
set nocompatible
set relativenumber
set number
```

ภายใน `~/.vim/settings/functions.vim`:

```shell
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
```

ภายใน `~/.vim/settings/mappings.vim`:

```shell
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
```

vimrc ของคุณควรทำงานตามปกติ แต่ตอนนี้มันมีเพียงสี่บรรทัด!

ด้วยการตั้งค่านี้ คุณจะรู้ได้ง่ายว่าควรไปที่ไหน หากคุณต้องการเพิ่มการแมพเพิ่มเติม ให้เพิ่มลงในไฟล์ `/mappings.vim` ในอนาคต คุณสามารถเพิ่มไดเรกทอรีเพิ่มเติมได้เมื่อ vimrc ของคุณขยายใหญ่ขึ้น ตัวอย่างเช่น หากคุณต้องการสร้างการตั้งค่าสำหรับธีมสีของคุณ คุณสามารถเพิ่ม `~/.vim/settings/themes.vim`

### การเก็บไฟล์ vimrc ไว้ในไฟล์เดียว

หากคุณต้องการเก็บไฟล์ vimrc ไว้ในไฟล์เดียวเพื่อให้พกพาได้ คุณสามารถใช้การพับเครื่องหมายเพื่อให้มันเป็นระเบียบ เพิ่มสิ่งนี้ที่ด้านบนของ vimrc ของคุณ:

```shell
" setup folds {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}
```

Vim สามารถตรวจจับประเภทไฟล์ที่บัฟเฟอร์ปัจจุบันมีอยู่ (`:set filetype?`) หากเป็นประเภทไฟล์ `vim` คุณสามารถใช้วิธีการพับเครื่องหมายได้ จำไว้ว่าการพับเครื่องหมายใช้ `{{{` และ `}}}` เพื่อระบุการเริ่มต้นและสิ้นสุดของการพับ

เพิ่มการพับ `{{{` และ `}}}` ไปยังส่วนที่เหลือของ vimrc ของคุณ (อย่าลืมใส่คอมเมนต์ด้วย `"`):

```shell
" setup folds {{{
augroup filetype_vim
  autocmd!
  autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}

" plugins {{{
call plug#begin('~/.vim/plugged')
  Plug 'mattn/emmet-vim'
  Plug 'preservim/nerdtree'
call plug#end()
" }}}

" configs {{{
set nocompatible
set relativenumber
set number
" }}}

" functions {{{
function! ToggleNumber()
  if(&relativenumber == 1)
    set norelativenumber
  else
    set relativenumber
  endif
endfunc
" }}}

" mappings {{{
inoremap jk <esc>
nnoremap <silent> <C-f> :GFiles<CR>
nnoremap <Leader>tn :call ToggleNumber()<CR>
" }}}
```

vimrc ของคุณควรมีลักษณะดังนี้:

```shell
+-- 6 lines: setup folds -----

+-- 6 lines: plugins ---------

+-- 5 lines: configs ---------

+-- 9 lines: functions -------

+-- 5 lines: mappings --------
```

## การเรียกใช้ Vim โดยไม่มี vimrc และปลั๊กอิน

หากคุณต้องการเรียกใช้ Vim โดยไม่มีทั้ง vimrc และปลั๊กอิน ให้รัน:

```shell
vim -u NONE
```

หากคุณต้องการเปิด Vim โดยไม่มี vimrc แต่มีปลั๊กอิน ให้รัน:

```shell
vim -u NORC
```

หากคุณต้องการเรียกใช้ Vim โดยมี vimrc แต่ไม่มีปลั๊กอิน ให้รัน:

```shell
vim --noplugin
```

หากคุณต้องการเรียกใช้ Vim ด้วย vimrc *ที่แตกต่าง* เช่น `~/.vimrc-backup` ให้รัน:

```shell
vim -u ~/.vimrc-backup
```

หากคุณต้องการเรียกใช้ Vim ด้วยเพียง `defaults.vim` และไม่มีปลั๊กอิน ซึ่งมีประโยชน์ในการแก้ไข vimrc ที่เสียหาย ให้รัน:

```shell
vim --clean
```

## การกำหนดค่า vimrc อย่างชาญฉลาด

vimrc เป็นส่วนสำคัญของการปรับแต่ง Vim วิธีที่ดีในการเริ่มสร้าง vimrc ของคุณคือการอ่าน vimrc ของคนอื่นและค่อย ๆ สร้างมันขึ้นมาในระยะเวลา การมี vimrc ที่ดีที่สุดไม่ใช่การใช้ของนักพัฒนา X แต่เป็นการปรับให้เหมาะกับกรอบความคิดและสไตล์การแก้ไขของคุณโดยเฉพาะ