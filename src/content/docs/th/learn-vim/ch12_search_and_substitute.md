---
description: เอกสารนี้อธิบายเกี่ยวกับการค้นหาและการแทนที่ใน Vim โดยใช้การแสดงออกปกติและการตั้งค่าความไวต่ออักษรตัวใหญ่และตัวเล็ก
title: Ch12. Search and Substitute
---

บทนี้ครอบคลุมแนวคิดที่แยกจากกันสองแนวคิดแต่เกี่ยวข้องกัน: การค้นหาและการแทนที่ บ่อยครั้งเมื่อทำการแก้ไข คุณจำเป็นต้องค้นหาข้อความหลาย ๆ ข้อความตามรูปแบบที่มีตัวหารร่วมที่น้อยที่สุด โดยการเรียนรู้วิธีการใช้การแสดงออกปกติในการค้นหาและแทนที่แทนที่จะใช้สตริงที่เป็นตัวอักษร คุณจะสามารถกำหนดเป้าหมายข้อความใด ๆ ได้อย่างรวดเร็ว

เป็นหมายเหตุข้างเคียง ในบทนี้ ฉันจะใช้ `/` เมื่อพูดถึงการค้นหา ทุกสิ่งที่คุณสามารถทำได้ด้วย `/` ก็สามารถทำได้ด้วย `?` เช่นกัน

## ความไวต่อการใช้ตัวพิมพ์ใหญ่และเล็กอย่างชาญฉลาด

มันอาจจะยุ่งยากในการจับคู่ตัวพิมพ์ของคำค้นหา หากคุณกำลังค้นหาข้อความ "Learn Vim" คุณอาจพิมพ์ตัวพิมพ์ผิดในตัวอักษรหนึ่งและได้รับผลลัพธ์การค้นหาที่ผิดพลาด จะไม่ง่ายและปลอดภัยกว่าหรือถ้าคุณสามารถจับคู่ตัวพิมพ์ใด ๆ ได้? นี่คือจุดที่ตัวเลือก `ignorecase` เปล่งประกาย เพียงแค่เพิ่ม `set ignorecase` ใน vimrc ของคุณและคำค้นหาทั้งหมดของคุณจะไม่สนใจตัวพิมพ์ ตอนนี้คุณไม่จำเป็นต้องพิมพ์ `/Learn Vim` อีกต่อไป `/learn vim` จะทำงาน

อย่างไรก็ตาม มีบางครั้งที่คุณต้องค้นหาวลีที่เฉพาะเจาะจงในตัวพิมพ์ หนึ่งในวิธีการทำเช่นนั้นคือการปิดตัวเลือก `ignorecase` โดยการรัน `set noignorecase` แต่การเปิดและปิดทุกครั้งที่คุณต้องค้นหาวลีที่มีตัวพิมพ์ใหญ่เป็นเรื่องที่ยุ่งยาก

เพื่อหลีกเลี่ยงการสลับ `ignorecase` Vim มีตัวเลือก `smartcase` เพื่อค้นหาสตริงที่ไม่สนใจตัวพิมพ์หากรูปแบบการค้นหา *มีตัวอักษรพิมพ์ใหญ่อย่างน้อยหนึ่งตัว* คุณสามารถรวมทั้ง `ignorecase` และ `smartcase` เพื่อทำการค้นหาที่ไม่สนใจตัวพิมพ์เมื่อคุณป้อนตัวอักษรทั้งหมดเป็นตัวพิมพ์เล็กและค้นหาที่สนใจตัวพิมพ์เมื่อคุณป้อนตัวอักษรพิมพ์ใหญ่หนึ่งตัวหรือมากกว่า

ใน vimrc ของคุณ ให้เพิ่ม:

```shell
set ignorecase smartcase
```

หากคุณมีข้อความเหล่านี้:

```shell
hello
HELLO
Hello
```

- `/hello` จะตรงกับ "hello", "HELLO", และ "Hello"
- `/HELLO` จะตรงกับ "HELLO" เท่านั้น
- `/Hello` จะตรงกับ "Hello" เท่านั้น

มีข้อเสียอยู่ข้อหนึ่ง ถ้าคุณต้องการค้นหาเฉพาะสตริงตัวพิมพ์เล็ก? เมื่อคุณทำ `/hello` Vim ตอนนี้ทำการค้นหาที่ไม่สนใจตัวพิมพ์ คุณสามารถใช้รูปแบบ `\C` ที่ใดก็ได้ในคำค้นหาของคุณเพื่อบอก Vim ว่าคำค้นหาที่ตามมาจะต้องสนใจตัวพิมพ์ หากคุณทำ `/\Chello` มันจะตรงกับ "hello" เท่านั้น ไม่ใช่ "HELLO" หรือ "Hello"

## ตัวอักษรแรกและตัวอักษรสุดท้ายในบรรทัด

คุณสามารถใช้ `^` เพื่อจับคู่ตัวอักษรแรกในบรรทัดและ `$` เพื่อจับคู่ตัวอักษรสุดท้ายในบรรทัด

หากคุณมีข้อความนี้:

```shell
hello hello
```

คุณสามารถกำหนดเป้าหมาย "hello" ตัวแรกด้วย `/^hello` ตัวอักษรที่ตามหลัง `^` จะต้องเป็นตัวอักษรแรกในบรรทัด เพื่อกำหนดเป้าหมาย "hello" ตัวสุดท้าย ให้รัน `/hello$` ตัวอักษรก่อน `$` จะต้องเป็นตัวอักษรสุดท้ายในบรรทัด

หากคุณมีข้อความนี้:

```shell
hello hello friend
```

การรัน `/hello$` จะไม่ตรงกับอะไรเลยเพราะ "friend" เป็นคำสุดท้ายในบรรทัดนั้น ไม่ใช่ "hello"

## การค้นหาซ้ำ

คุณสามารถทำการค้นหาครั้งก่อนซ้ำด้วย `//` หากคุณเพิ่งค้นหา `/hello` การรัน `//` จะเท่ากับการรัน `/hello` ชอร์ตคัตนี้สามารถช่วยประหยัดการกดปุ่มของคุณโดยเฉพาะหากคุณเพิ่งค้นหาสตริงยาว ๆ นอกจากนี้ยังจำไว้ว่าคุณสามารถใช้ `n` และ `N` เพื่อทำการค้นหาครั้งสุดท้ายซ้ำในทิศทางเดียวกันและทิศทางตรงกันข้ามตามลำดับ

ถ้าคุณต้องการเรียกคืนคำค้นหาล่าสุด *n* คำอย่างรวดเร็ว? คุณสามารถเรียกดูประวัติการค้นหาได้อย่างรวดเร็วโดยการกด `/` ก่อน จากนั้นกดปุ่มลูกศรขึ้น/ลง (หรือ `Ctrl-N`/`Ctrl-P`) จนกว่าคุณจะพบคำค้นหาที่คุณต้องการ หากต้องการดูประวัติการค้นหาทั้งหมดของคุณ คุณสามารถรัน `:history /`

เมื่อคุณถึงจุดสิ้นสุดของไฟล์ในขณะที่ค้นหา Vim จะโยนข้อผิดพลาด: `"Search hit the BOTTOM without match for: {your-search}"` บางครั้งนี่อาจเป็นการป้องกันที่ดีจากการค้นหามากเกินไป แต่บางครั้งคุณต้องการหมุนการค้นกลับไปที่ด้านบนอีกครั้ง คุณสามารถใช้ตัวเลือก `set wrapscan` เพื่อทำให้ Vim ค้นหากลับไปที่ด้านบนของไฟล์เมื่อคุณถึงจุดสิ้นสุดของไฟล์ หากต้องการปิดฟีเจอร์นี้ ให้ทำ `set nowrapscan`

## การค้นหาคำที่เป็นทางเลือก

เป็นเรื่องปกติที่จะค้นหาหลายคำในครั้งเดียว หากคุณต้องการค้นหา *หรือ* "hello vim" หรือ "hola vim" แต่ไม่ใช่ "salve vim" หรือ "bonjour vim" คุณสามารถใช้รูปแบบ `|`

ให้ข้อความนี้:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

เพื่อจับคู่ทั้ง "hello" และ "hola" คุณสามารถทำ `/hello\|hola` คุณต้องหลีกเลี่ยง (`\`) ตัวดำเนินการหรือ (`|`) มิฉะนั้น Vim จะค้นหาสตริง "|" อย่างแท้จริง

หากคุณไม่ต้องการพิมพ์ `\|` ทุกครั้ง คุณสามารถใช้ไวยากรณ์ `magic` (`\v`) ที่จุดเริ่มต้นของการค้นหา: `/\vhello|hola` ฉันจะไม่ครอบคลุม `magic` ในคู่มือนี้ แต่ด้วย `\v` คุณไม่จำเป็นต้องหลีกเลี่ยงอักขระพิเศษอีกต่อไป หากต้องการเรียนรู้เพิ่มเติมเกี่ยวกับ `\v` คุณสามารถตรวจสอบ `:h \v`

## การตั้งค่าจุดเริ่มต้นและจุดสิ้นสุดของการจับคู่

บางทีคุณอาจต้องค้นหาข้อความที่เป็นส่วนหนึ่งของคำประกอบ หากคุณมีข้อความเหล่านี้:

```shell
11vim22
vim22
11vim
vim
```

หากคุณต้องการเลือก "vim" แต่เฉพาะเมื่อมันเริ่มต้นด้วย "11" และสิ้นสุดด้วย "22" คุณสามารถใช้ตัวดำเนินการ `\zs` (เริ่มการจับคู่) และ `\ze` (สิ้นสุดการจับคู่) รัน:

```shell
/11\zsvim\ze22
```

Vim ยังคงต้องจับคู่รูปแบบทั้งหมด "11vim22" แต่จะเน้นเฉพาะรูปแบบที่อยู่ระหว่าง `\zs` และ `\ze` ตัวอย่างอีกหนึ่ง:

```shell
foobar
foobaz
```

หากคุณต้องการจับคู่ "foo" ใน "foobaz" แต่ไม่ใน "foobar" ให้รัน:

```shell
/foo\zebaz
```

## การค้นหาช่วงตัวอักษร

คำค้นหาทั้งหมดของคุณจนถึงจุดนี้เป็นการค้นหาคำที่เป็นตัวอักษร ในชีวิตจริง คุณอาจต้องใช้รูปแบบทั่วไปเพื่อค้นหาข้อความของคุณ รูปแบบที่พื้นฐานที่สุดคือช่วงตัวอักษร `[ ]`

หากคุณต้องการค้นหาหมายเลขใด ๆ คุณอาจไม่ต้องการพิมพ์ `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0` ทุกครั้ง แทนที่จะใช้ `/[0-9]` เพื่อจับคู่ตัวเลขเดียว รูปแบบ `0-9` แทนช่วงของหมายเลข 0-9 ที่ Vim จะพยายามจับคู่ ดังนั้นหากคุณกำลังมองหาหมายเลขระหว่าง 1 ถึง 5 แทน ให้ใช้ `/[1-5]`

ตัวเลขไม่ใช่ประเภทข้อมูลเดียวที่ Vim สามารถค้นหาได้ คุณยังสามารถทำ `/[a-z]` เพื่อค้นหาตัวอักษรพิมพ์เล็กและ `/[A-Z]` เพื่อค้นหาตัวอักษรพิมพ์ใหญ่

คุณสามารถรวมช่วงเหล่านี้เข้าด้วยกัน หากคุณต้องการค้นหาหมายเลข 0-9 และตัวอักษรพิมพ์เล็กและพิมพ์ใหญ่จาก "a" ถึง "f" (เช่นเลขฐานสิบหก) คุณสามารถทำ `/[0-9a-fA-F]`

ในการค้นหาที่เป็นลบ คุณสามารถเพิ่ม `^` ภายในวงเล็บช่วงตัวอักษร เพื่อค้นหาตัวอักษรที่ไม่ใช่หมายเลข ให้รัน `/[^0-9]` Vim จะจับคู่ตัวอักษรใด ๆ ตราบใดที่มันไม่ใช่หมายเลข โปรดระวังว่า caret (`^`) ภายในวงเล็บช่วงจะแตกต่างจาก caret ที่จุดเริ่มต้นของบรรทัด (เช่น `/^hello`) หาก caret อยู่ภายนอกวงเล็บและเป็นตัวอักษรแรกในคำค้นหาหมายถึง "ตัวอักษรแรกในบรรทัด" หาก caret อยู่ภายในวงเล็บและเป็นตัวอักษรแรกภายในวงเล็บ หมายถึงตัวดำเนินการค้นหาที่เป็นลบ `/^abc` จับคู่ "abc" ตัวแรกในบรรทัดและ `/[^abc]` จับคู่ตัวอักษรใด ๆ ยกเว้น "a", "b", หรือ "c"

## การค้นหาตัวอักษรที่ซ้ำกัน

หากคุณต้องการค้นหาหมายเลขสองหลักในข้อความนี้:

```shell
1aa
11a
111
```

คุณสามารถใช้ `/[0-9][0-9]` เพื่อจับคู่ตัวอักษรสองหลัก แต่วิธีนี้ไม่สามารถขยายได้ หากคุณต้องการจับคู่หมายเลขยี่สิบหลัก การพิมพ์ `[0-9]` ยี่สิบครั้งไม่ใช่ประสบการณ์ที่สนุก นั่นคือเหตุผลที่คุณต้องการอาร์กิวเมนต์ `count`

คุณสามารถส่ง `count` ไปยังการค้นหาของคุณ โดยมีไวยากรณ์ดังนี้:

```shell
{n,m}
```

โดยวิธีการเหล่านี้ วงเล็บ `count` ต้องถูกหลีกเลี่ยงเมื่อคุณใช้ใน Vim ตัวดำเนินการ `count` จะถูกวางหลังตัวอักษรเดียวที่คุณต้องการเพิ่ม

นี่คือสี่รูปแบบที่แตกต่างกันของไวยากรณ์ `count`:
- `{n}` เป็นการจับคู่ที่แน่นอน `/[0-9]\{2\}` จับคู่หมายเลขสองหลัก: "11" และ "11" ใน "111"
- `{n,m}` เป็นการจับคู่ช่วง `/[0-9]\{2,3\}` จับคู่ระหว่างหมายเลขสองถึงสามหลัก: "11" และ "111"
- `{,m}` เป็นการจับคู่สูงสุด `/[0-9]\{,3\}` จับคู่หมายเลขสูงสุดสามหลัก: "1", "11", และ "111"
- `{n,}` เป็นการจับคู่ขั้นต่ำ `/[0-9]\{2,\}` จับคู่หมายเลขสองหลักขึ้นไป: "11" และ "111"

อาร์กิวเมนต์ `count` `\{0,\}` (ศูนย์หรือมากกว่า) และ `\{1,\}` (หนึ่งหรือมากกว่า) เป็นรูปแบบการค้นหาที่พบบ่อยและ Vim มีตัวดำเนินการพิเศษสำหรับพวกเขา: `*` และ `+` (`+` ต้องถูกหลีกเลี่ยงในขณะที่ `*` ทำงานได้ดีโดยไม่ต้องหลีกเลี่ยง) หากคุณทำ `/[0-9]*` มันจะเหมือนกับ `/[0-9]\{0,\}` มันค้นหาหมายเลขศูนย์หรือมากกว่า มันจะตรงกับ "", "1", "123" โดยวิธีการนี้ มันจะจับคู่ตัวอักษรที่ไม่ใช่หมายเลขเช่น "a" เพราะมีหมายเลขศูนย์ในตัวอักษร "a" คิดให้รอบคอบก่อนที่จะใช้ `*` หากคุณทำ `/[0-9]\+` มันจะเหมือนกับ `/[0-9]\{1,\}` มันค้นหาหมายเลขหนึ่งหรือมากกว่า มันจะตรงกับ "1" และ "12"

## ช่วงตัวอักษรที่กำหนดไว้ล่วงหน้า

Vim มีช่วงที่กำหนดไว้ล่วงหน้าสำหรับตัวอักษรทั่วไปเช่นหมายเลขและตัวอักษร ฉันจะไม่ผ่านทุกตัวที่นี่ แต่คุณสามารถค้นหารายการทั้งหมดได้ใน `:h /character-classes` นี่คือสิ่งที่มีประโยชน์:

```shell
\d    หมายเลข [0-9]
\D    ไม่ใช่หมายเลข [^0-9]
\s    อักขระว่าง (ช่องว่างและแท็บ)
\S    อักขระที่ไม่ใช่ช่องว่าง (ทุกอย่างยกเว้นช่องว่างและแท็บ)
\w    อักขระคำ [0-9A-Za-z_]
\l    ตัวอักษรพิมพ์เล็ก [a-z]
\u    ตัวอักษรพิมพ์ใหญ่ [A-Z]
```

คุณสามารถใช้พวกเขาเหมือนที่คุณใช้ช่วงตัวอักษร เพื่อค้นหาหมายเลขเดียวแทนที่จะใช้ `/[0-9]` คุณสามารถใช้ `/\d` สำหรับไวยากรณ์ที่กระชับมากขึ้น

## ตัวอย่างการค้นหา: การจับข้อความระหว่างคู่ของตัวอักษรที่คล้ายกัน

หากคุณต้องการค้นหาวลีที่ถูกล้อมรอบด้วยคู่ของเครื่องหมายคำพูดคู่:

```shell
"Vim is awesome!"
```

ให้รันนี้:

```shell
/"[^"]\+"
```

มาวิเคราะห์กัน:
- `"` เป็นเครื่องหมายคำพูดคู่ที่เป็นตัวอักษร มันจับคู่เครื่องหมายคำพูดคู่ตัวแรก
- `[^"]` หมายถึงตัวอักษรใด ๆ ยกเว้นเครื่องหมายคำพูดคู่ มันจับคู่ตัวอักษรที่เป็นตัวเลขและช่องว่างตราบใดที่มันไม่ใช่เครื่องหมายคำพูดคู่
- `\+` หมายถึงหนึ่งหรือมากกว่า เนื่องจากมันถูกนำหน้าด้วย `[^"]` Vim จะมองหาตัวอักษรหนึ่งหรือมากกว่าที่ไม่ใช่เครื่องหมายคำพูดคู่
- `"` เป็นเครื่องหมายคำพูดคู่ที่เป็นตัวอักษร มันจับคู่เครื่องหมายคำพูดคู่ที่ปิด

เมื่อ Vim เห็น `"`, มันเริ่มการจับรูปแบบ ในขณะที่มันเห็นเครื่องหมายคำพูดคู่ตัวที่สองในบรรทัด มันจับคู่รูปแบบ `"` ตัวที่สองและหยุดการจับรูปแบบ ในขณะเดียวกัน ตัวอักษรที่ไม่ใช่เครื่องหมายคำพูดคู่ทั้งหมดในระหว่างจะถูกจับโดยรูปแบบ `[^"]\+` ในกรณีนี้ วลี `Vim is awesome!` นี่เป็นรูปแบบทั่วไปในการจับวลีที่ถูกล้อมรอบด้วยคู่ของตัวแบ่งที่คล้ายกัน

- เพื่อจับวลีที่ถูกล้อมรอบด้วยเครื่องหมายคำพูดเดี่ยว คุณสามารถใช้ `/'[^']\+'`
- เพื่อจับวลีที่ถูกล้อมรอบด้วยศูนย์ คุณสามารถใช้ `/0[^0]\+0`

## ตัวอย่างการค้นหา: การจับหมายเลขโทรศัพท์

หากคุณต้องการจับคู่หมายเลขโทรศัพท์ของสหรัฐอเมริกาที่แยกด้วยขีด (`-`), เช่น `123-456-7890`, คุณสามารถใช้:

```shell
/\d\{3\}-\d\{3\}-\d\{4\}
```

หมายเลขโทรศัพท์ของสหรัฐอเมริกาประกอบด้วยชุดหมายเลขสามหลัก ตามด้วยอีกสามหลัก และสุดท้ายโดยสี่หลัก มาวิเคราะห์กัน:
- `\d\{3\}` จับคู่หมายเลขที่ซ้ำกันสามครั้ง
- `-` เป็นขีดที่เป็นตัวอักษร

คุณสามารถหลีกเลี่ยงการพิมพ์การหลีกเลี่ยงด้วย `\v`:

```shell
/\v\d{3}-\d{3}-\d{4}
```

รูปแบบนี้ยังมีประโยชน์ในการจับหมายเลขที่ซ้ำกัน เช่น หมายเลข IP และรหัสไปรษณีย์

นั่นคือการครอบคลุมส่วนการค้นหาของบทนี้ ตอนนี้เรามาเปลี่ยนไปที่การแทนที่

## การแทนที่พื้นฐาน

คำสั่งแทนที่ของ Vim เป็นคำสั่งที่มีประโยชน์ในการค้นหาและแทนที่รูปแบบใด ๆ อย่างรวดเร็ว ไวยากรณ์การแทนที่คือ:

```shell
:s/{old-pattern}/{new-pattern}/
```

มาลองใช้การใช้งานพื้นฐานกัน
## การทำซ้ำการแทนที่ครั้งล่าสุด

คุณสามารถทำซ้ำคำสั่งแทนที่ครั้งล่าสุดด้วยคำสั่งปกติ `&` หรือโดยการรัน `:s` หากคุณเพิ่งรัน `:s/good/awesome/` การรัน `&` หรือ `:s` จะทำให้มันทำซ้ำ

นอกจากนี้ ในบทนี้ฉันได้กล่าวถึงว่าคุณสามารถใช้ `//` เพื่อทำซ้ำรูปแบบการค้นหาก่อนหน้าได้ เทคนิคนี้ใช้ได้กับคำสั่งแทนที่ หาก `/good` ถูกทำเมื่อเร็ว ๆ นี้และคุณทิ้งอาร์กิวเมนต์รูปแบบการแทนที่แรกว่างเปล่า เช่นใน `:s//awesome/` มันจะทำงานเหมือนกับการรัน `:s/good/awesome/`

## ช่วงการแทนที่

เช่นเดียวกับคำสั่ง Ex หลาย ๆ คำสั่ง คุณสามารถส่งอาร์กิวเมนต์ช่วงเข้าไปในคำสั่งแทนที่ได้ ไวยากรณ์คือ:

```shell
:[range]s/old/new/
```

หากคุณมีนิพจน์เหล่านี้:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

เพื่อแทนที่ "let" เป็น "const" ในบรรทัดที่สามถึงห้า คุณสามารถทำได้:

```shell
:3,5s/let/const/
```

นี่คือความหลากหลายของช่วงที่คุณสามารถส่งได้:

- `:,3s/let/const/` - หากไม่มีอะไรระบุไว้ก่อนเครื่องหมายจุลภาค มันจะแทนที่บรรทัดปัจจุบัน แทนที่จากบรรทัดปัจจุบันไปยังบรรทัดที่ 3
- `:1,s/let/const/` - หากไม่มีอะไรระบุไว้หลังเครื่องหมายจุลภาค มันก็จะแทนที่บรรทัดปัจจุบัน แทนที่จากบรรทัดที่ 1 ไปยังบรรทัดปัจจุบัน
- `:3s/let/const/` - หากมีค่าเพียงค่าเดียวที่ระบุเป็นช่วง (ไม่มีจุลภาค) มันจะทำการแทนที่ในบรรทัดนั้นเท่านั้น

ใน Vim `%` มักหมายถึงไฟล์ทั้งหมด หากคุณรัน `:%s/let/const/` มันจะทำการแทนที่ในทุกบรรทัด โปรดจำไวยากรณ์ช่วงนี้ไว้ คำสั่งในบรรทัดคำสั่งหลาย ๆ คำสั่งที่คุณจะได้เรียนรู้ในบทถัดไปจะมีรูปแบบนี้

## การจับคู่รูปแบบ

ในส่วนถัดไปจะครอบคลุมเกี่ยวกับนิพจน์ปกติพื้นฐาน ความรู้เกี่ยวกับรูปแบบที่แข็งแกร่งเป็นสิ่งจำเป็นในการเชี่ยวชาญคำสั่งแทนที่

หากคุณมีนิพจน์ดังต่อไปนี้:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

เพื่อเพิ่มคู่ของเครื่องหมายคำพูดคู่รอบตัวเลข:

```shell
:%s/\d/"\0"/
```

ผลลัพธ์:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

มาวิเคราะห์คำสั่งนี้กัน:
- `:%s` เป้าหมายคือไฟล์ทั้งหมดเพื่อทำการแทนที่
- `\d` คือช่วงที่กำหนดไว้ล่วงหน้าสำหรับตัวเลข (คล้ายกับการใช้ `[0-9]`)
- `"\0"` ที่นี่เครื่องหมายคำพูดคู่คือเครื่องหมายคำพูดคู่ที่เป็นตัวอักษร `\0` เป็นอักขระพิเศษที่แทนที่ "รูปแบบที่ตรงกันทั้งหมด" รูปแบบที่ตรงกันที่นี่คือหมายเลขหลักเดียว `\d`

ทางเลือกคือ `&` ก็แทนที่รูปแบบที่ตรงกันทั้งหมดเช่นเดียวกับ `\0` `:s/\d/"&"/` ก็จะทำงานได้เช่นกัน

มาพิจารณาตัวอย่างอีกตัวอย่างหนึ่ง สมมติว่าคุณมีนิพจน์เหล่านี้และคุณต้องการสลับ "let" ทั้งหมดกับชื่อของตัวแปร

```shell
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

เพื่อทำเช่นนั้น ให้รัน:

```shell
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

คำสั่งข้างต้นมีเครื่องหมายแบ็คสแลชมากเกินไปและอ่านยาก ในกรณีนี้สะดวกกว่าที่จะใช้ตัวดำเนินการ `\v`:

```shell
:%s/\v(\w+) (\w+)/\2 \1/
```

ผลลัพธ์:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

ยอดเยี่ยม! มาวิเคราะห์คำสั่งนั้นกัน:
- `:%s` เป้าหมายคือทุกบรรทัดในไฟล์เพื่อทำการแทนที่
- `(\w+) (\w+)` คือการจับคู่กลุ่ม `\w` เป็นหนึ่งในช่วงที่กำหนดไว้ล่วงหน้าของ Vim สำหรับอักขระคำ (`[0-9A-Za-z_]`) `( )` ที่ล้อมรอบมันจับคู่การจับอักขระคำในกลุ่ม สังเกตว่ามีช่องว่างระหว่างการจัดกลุ่มทั้งสอง `(\w+) (\w+)` จับคู่สองกลุ่ม กลุ่มแรกจับคู่ "one" และกลุ่มที่สองจับคู่ "two"
- `\2 \1` คืนค่ากลุ่มที่จับคู่ในลำดับที่กลับกัน `\2` มีสตริงที่จับคู่ "let" และ `\1` มีสตริง "one" การมี `\2 \1` คืนค่าสตริง "let one"

จำไว้ว่า `\0` แทนที่รูปแบบที่ตรงกันทั้งหมด คุณสามารถแบ่งสตริงที่ตรงกันออกเป็นกลุ่มเล็ก ๆ ด้วย `( )` แต่ละกลุ่มจะแทนที่ด้วย `\1`, `\2`, `\3`, ฯลฯ

มาทำตัวอย่างอีกตัวอย่างหนึ่งเพื่อทำให้แนวคิดการจับคู่กลุ่มนี้มั่นคง หากคุณมีตัวเลขเหล่านี้:

```shell
123
456
789
```

เพื่อสลับลำดับ ให้รัน:

```shell
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

ผลลัพธ์คือ:

```shell
321
654
987
```

แต่ละ `(\d)` จับคู่แต่ละหลักและสร้างกลุ่ม ในบรรทัดแรก `(\d)` แรกมีค่าเป็น 1, `(\d)` ที่สองมีค่าเป็น 2, และ `(\d)` ที่สามมีค่าเป็น 3 พวกเขาถูกเก็บไว้ในตัวแปร `\1`, `\2`, และ `\3` ในครึ่งหลังของการแทนที่ของคุณ รูปแบบใหม่ `\3\2\1` ส่งผลให้ค่า "321" ในบรรทัดหนึ่ง

หากคุณรันสิ่งนี้แทน:

```shell
:%s/\v(\d\d)(\d)/\2\1/
```
คุณจะได้ผลลัพธ์ที่แตกต่าง:

```shell
312
645
978
```

นี่เป็นเพราะคุณมีเพียงสองกลุ่ม กลุ่มแรกที่จับคู่โดย `(\d\d)` ถูกเก็บไว้ใน `\1` และมีค่าเป็น 12 กลุ่มที่สองที่จับคู่โดย `(\d)` ถูกเก็บไว้ใน `\2` และมีค่าเป็น 3 `\2\1` จึงคืนค่า 312

## ธงการแทนที่

หากคุณมีประโยค:

```shell
chocolate pancake, strawberry pancake, blueberry pancake
```

เพื่อแทนที่แพนเค้กทั้งหมดเป็นโดนัท คุณไม่สามารถรันแค่:

```shell
:s/pancake/donut
```

คำสั่งข้างต้นจะทำการแทนที่เพียงการจับคู่แรก ทำให้คุณได้:

```shell
chocolate donut, strawberry pancake, blueberry pancake
```

มีสองวิธีในการแก้ไขปัญหานี้ คุณสามารถรันคำสั่งแทนที่อีกสองครั้งหรือคุณสามารถส่งธงทั่วโลก (`g`) เพื่อแทนที่การจับคู่ทั้งหมดในบรรทัด

มาพูดคุยเกี่ยวกับธงทั่วโลก รัน:

```shell
:s/pancake/donut/g
```

Vim แทนที่แพนเค้กทั้งหมดด้วยโดนัทในคำสั่งเดียว ธงทั่วโลกเป็นหนึ่งในหลาย ๆ ธงที่คำสั่งแทนที่ยอมรับ คุณส่งธงที่ท้ายคำสั่งแทนที่ นี่คือรายการธงที่มีประโยชน์:

```shell
&    ใช้ธงจากคำสั่งแทนที่ก่อนหน้า
g    แทนที่การจับคู่ทั้งหมดในบรรทัด
c    ขอการยืนยันการแทนที่
e    ป้องกันไม่ให้แสดงข้อความผิดพลาดเมื่อการแทนที่ล้มเหลว
i    ทำการแทนที่โดยไม่คำนึงถึงตัวพิมพ์ใหญ่
I    ทำการแทนที่โดยคำนึงถึงตัวพิมพ์ใหญ่
```

ยังมีธงอื่น ๆ ที่ฉันไม่ได้ระบุไว้ข้างต้น หากต้องการอ่านเกี่ยวกับธงทั้งหมด ให้ตรวจสอบ `:h s_flags`

โดยวิธีการ คำสั่งทำซ้ำการแทนที่ (`&` และ `:s`) จะไม่เก็บธง การรัน `&` จะทำการซ้ำ `:s/pancake/donut/` โดยไม่มี `g` หากต้องการทำซ้ำคำสั่งแทนที่ครั้งล่าสุดอย่างรวดเร็วพร้อมกับธงทั้งหมด ให้รัน `:&&`

## การเปลี่ยนตัวแบ่ง

หากคุณต้องการแทนที่ URL ด้วยเส้นทางยาว:

```shell
https://mysite.com/a/b/c/d/e
```

เพื่อแทนที่ด้วยคำว่า "hello" ให้รัน:

```shell
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

อย่างไรก็ตาม มันยากที่จะบอกว่าเครื่องหมายทับ (`/`) ไหนเป็นส่วนหนึ่งของรูปแบบการแทนที่และเครื่องหมายใดเป็นตัวแบ่ง คุณสามารถเปลี่ยนตัวแบ่งด้วยอักขระแบบไบต์เดียวใด ๆ (ยกเว้นอักษร, ตัวเลข, หรือ `"`, `|`, และ `\`) มาทดแทนด้วย `+` คำสั่งแทนที่ข้างต้นจึงสามารถเขียนใหม่ได้ว่า:

```shell
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

ตอนนี้มันง่ายกว่าที่จะเห็นว่าตัวแบ่งอยู่ที่ไหน

## การแทนที่พิเศษ

คุณยังสามารถปรับเปลี่ยนตัวพิมพ์ของข้อความที่คุณกำลังแทนที่ได้ สมมติว่ามีนิพจน์ดังต่อไปนี้และงานของคุณคือการทำให้ตัวแปร "one", "two", "three" เป็นต้น เป็นตัวพิมพ์ใหญ่

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

รัน:

```shell
:%s/\v(\w+) (\w+)/\1 \U\2/
```

คุณจะได้:

```shell
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

การวิเคราะห์:
- `(\w+) (\w+)` จับคู่กลุ่มที่ตรงกันสองกลุ่มแรก เช่น "let" และ "one"
- `\1` คืนค่าค่าของกลุ่มแรก "let"
- `\U\2` ทำให้กลุ่มที่สอง (`\2`) เป็นตัวพิมพ์ใหญ่ (`\U`)

เคล็ดลับของคำสั่งนี้คือการแสดงออก `\U\2` `\U` สั่งให้ตัวอักษรถัดไปถูกทำให้เป็นตัวพิมพ์ใหญ่

มาทำตัวอย่างอีกตัวอย่างหนึ่ง สมมติว่าคุณกำลังเขียนคู่มือ Vim และคุณต้องการทำให้ตัวอักษรแรกของแต่ละคำในบรรทัดเป็นตัวพิมพ์ใหญ่

```shell
vim is the greatest text editor in the whole galaxy
```

คุณสามารถรัน:

```shell
:s/\<./\U&/g
```

ผลลัพธ์:

```shell
Vim Is The Greatest Text Editor In The Whole Galaxy
```

นี่คือการวิเคราะห์:
- `:s` แทนที่บรรทัดปัจจุบัน
- `\<.` ประกอบด้วยสองส่วน: `\<` เพื่อจับคู่จุดเริ่มต้นของคำและ `.` เพื่อจับคู่ตัวอักษรใด ๆ `\<` ทำให้ตัวอักษรถัดไปเป็นตัวอักษรแรกของคำ เนื่องจาก `.` เป็นตัวอักษรถัดไป มันจะจับคู่ตัวอักษรแรกของคำใด ๆ
- `\U&` ทำให้สัญลักษณ์ถัดไป `&` เป็นตัวพิมพ์ใหญ่ จำไว้ว่า `&` (หรือ `\0`) แทนที่การจับคู่ทั้งหมด มันจับคู่ตัวอักษรแรกของคำใด ๆ
- `g` ธงทั่วโลก หากไม่มีมัน คำสั่งนี้จะทำการแทนที่เพียงการจับคู่แรก คุณต้องแทนที่การจับคู่ทุกครั้งในบรรทัดนี้

หากต้องการเรียนรู้เพิ่มเติมเกี่ยวกับสัญลักษณ์การแทนที่พิเศษของการแทนที่ เช่น `\U` ให้ตรวจสอบ `:h sub-replace-special`

## รูปแบบทางเลือก

บางครั้งคุณต้องจับคู่หลายรูปแบบในเวลาเดียวกัน หากคุณมีคำทักทายดังต่อไปนี้:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

คุณต้องแทนที่คำว่า "vim" ด้วย "friend" แต่เฉพาะในบรรทัดที่มีคำว่า "hello" หรือ "hola" จำไว้จากบทก่อนหน้านี้ คุณสามารถใช้ `|` สำหรับรูปแบบทางเลือกหลายรูปแบบ

```shell
:%s/\v(hello|hola) vim/\1 friend/g
```

ผลลัพธ์:

```shell
hello friend
hola friend
salve vim
bonjour vim
```

นี่คือการวิเคราะห์:
- `%s` รันคำสั่งแทนที่ในแต่ละบรรทัดในไฟล์
- `(hello|hola)` จับคู่ *หรือ* "hello" หรือ "hola" และถือเป็นกลุ่ม
- `vim` คือคำว่า "vim" ที่เป็นตัวอักษร
- `\1` คือกลุ่มแรก ซึ่งคือข้อความ "hello" หรือ "hola"
- `friend` คือคำว่า "friend" ที่เป็นตัวอักษร

## การแทนที่จุดเริ่มต้นและจุดสิ้นสุดของรูปแบบ

จำไว้ว่าคุณสามารถใช้ `\zs` และ `\ze` เพื่อกำหนดจุดเริ่มต้นและจุดสิ้นสุดของการจับคู่ เทคนิคนี้ใช้ได้กับการแทนที่ด้วย หากคุณมี:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

เพื่อแทนที่ "cake" ใน "hotcake" ด้วย "dog" เพื่อให้ได้ "hotdog":

```shell
:%s/hot\zscake/dog/g
```

ผลลัพธ์:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotdog
```
## โลภและไม่โลภ

คุณสามารถแทนที่การจับคู่ที่ n ในบรรทัดด้วยกลเม็ดนี้:

```shell
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

เพื่อแทนที่ "Mississippi" ที่สามด้วย "Arkansas" ให้รัน:

```shell
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

การแยกส่วน:
- `:s/` คำสั่งแทนที่
- `\v` เป็นคำสำคัญที่ทำให้คุณไม่ต้องหนีคำสำคัญพิเศษ
- `.` จับคู่กับอักขระเดียวใด ๆ
- `{-}` ทำการจับคู่แบบไม่โลภของ 0 หรือมากกว่าของอะตอมที่อยู่ก่อนหน้า
- `\zsMississippi` ทำให้ "Mississippi" เป็นจุดเริ่มต้นของการจับคู่
- `(...){3}` มองหาการจับคู่ที่สาม

คุณได้เห็นไวยากรณ์ `{3}` นี้ในบทก่อนหน้านี้ ในกรณีนี้ `{3}` จะจับคู่กับการจับคู่ที่สามอย่างแน่นอน กลเม็ดใหม่ที่นี่คือ `{-}` ซึ่งเป็นการจับคู่แบบไม่โลภ มันหาการจับคู่ที่สั้นที่สุดของรูปแบบที่กำหนด ในกรณีนี้ `(.{-}Mississippi)` จับคู่กับ "Mississippi" ที่น้อยที่สุดที่มีอักขระใด ๆ อยู่ข้างหน้า เปรียบเทียบกับ `(.*Mississippi)` ซึ่งจะหาการจับคู่ที่ยาวที่สุดของรูปแบบที่กำหนด

หากคุณใช้ `(.{-}Mississippi)` คุณจะได้ห้าการจับคู่: "One Mississippi", "Two Mississippi" เป็นต้น หากคุณใช้ `(.*Mississippi)` คุณจะได้การจับคู่หนึ่ง: "Mississippi" ตัวสุดท้าย `*` เป็นตัวจับคู่แบบโลภและ `{-}` เป็นตัวจับคู่แบบไม่โลภ หากต้องการเรียนรู้เพิ่มเติมให้ตรวจสอบ `:h /\{-` และ `:h non-greedy`

มาลองทำตัวอย่างที่ง่ายขึ้น หากคุณมีสตริง:

```shell
abc1de1
```

คุณสามารถจับคู่ "abc1de1" (โลภ) ด้วย:

```shell
/a.*1
```

คุณสามารถจับคู่ "abc1" (ไม่โลภ) ด้วย:

```shell
/a.\{-}1
```

ดังนั้นหากคุณต้องการทำให้การจับคู่ที่ยาวที่สุด (โลภ) เป็นตัวพิมพ์ใหญ่ ให้รัน:

```shell
:s/a.*1/\U&/g
```

เพื่อให้ได้:

```shell
ABC1DEFG1
```

หากคุณต้องการทำให้การจับคู่ที่สั้นที่สุด (ไม่โลภ) เป็นตัวพิมพ์ใหญ่ ให้รัน:

```shell
:s/a.\{-}1/\U&/g
```

เพื่อให้ได้:

```shell
ABC1defg1
```

หากคุณเป็นมือใหม่ในแนวคิดโลภและไม่โลภ อาจจะยากที่จะเข้าใจ ลองทดลองกับการรวมกันที่แตกต่างกันจนกว่าคุณจะเข้าใจ

## การแทนที่ในหลายไฟล์

สุดท้าย มาศึกษาวิธีการแทนที่วลีในหลายไฟล์ สำหรับส่วนนี้ สมมติว่าคุณมีสองไฟล์: `food.txt` และ `animal.txt`

ภายใน `food.txt`:

```shell
corndog
hotdog
chilidog
```

ภายใน `animal.txt`:

```shell
large dog
medium dog
small dog
```

สมมติว่าโครงสร้างไดเรกทอรีของคุณมีลักษณะดังนี้:

```shell
- food.txt
- animal.txt
```

ก่อนอื่นให้จับคู่ทั้ง `food.txt` และ `animal.txt` ภายใน `:args` จำได้จากบทก่อนหน้านี้ว่า `:args` สามารถใช้เพื่อสร้างรายการชื่อไฟล์ มีหลายวิธีในการทำเช่นนี้จากภายใน Vim หนึ่งในนั้นคือการรันจากภายใน Vim:

```shell
:args *.txt                  จับคู่ไฟล์ txt ทั้งหมดในตำแหน่งปัจจุบัน
```

เพื่อทดสอบ เมื่อคุณรัน `:args` คุณควรเห็น:

```shell
[food.txt] animal.txt
```

ตอนนี้ที่ไฟล์ที่เกี่ยวข้องทั้งหมดถูกเก็บไว้ในรายการอาร์กิวเมนต์ คุณสามารถทำการแทนที่หลายไฟล์ด้วยคำสั่ง `:argdo` รัน:

```shell
:argdo %s/dog/chicken/
```

นี่จะทำการแทนที่ในไฟล์ทั้งหมดภายในรายการ `:args` สุดท้าย บันทึกไฟล์ที่เปลี่ยนแปลงด้วย:

```shell
:argdo update
```

`:args` และ `:argdo` เป็นเครื่องมือที่มีประโยชน์ในการใช้คำสั่งบรรทัดคำสั่งในหลายไฟล์ ลองใช้กับคำสั่งอื่น ๆ!

## การแทนที่ในหลายไฟล์ด้วยมาโคร

อีกทางเลือกหนึ่ง คุณยังสามารถรันคำสั่งแทนที่ในหลายไฟล์ด้วยมาโคร รัน:

```shell
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

การแยกส่วน:
- `:args *.txt` เพิ่มไฟล์ข้อความทั้งหมดลงในรายการ `:args`
- `qq` เริ่มมาโครในรีจิสเตอร์ "q"
- `:%s/dog/chicken/g` แทนที่ "dog" ด้วย "chicken" ในทุกบรรทัดในไฟล์ปัจจุบัน
- `:wnext` บันทึกไฟล์แล้วไปที่ไฟล์ถัดไปในรายการ `args`
- `q` หยุดการบันทึกมาโคร
- `99@q` รันมาโครเก้าสิบเก้าครั้ง Vim จะหยุดการรันมาโครเมื่อพบข้อผิดพลาดแรก ดังนั้น Vim จะไม่รันมาโครเก้าสิบเก้าครั้งจริง ๆ

## เรียนรู้การค้นหาและการแทนที่อย่างชาญฉลาด

ความสามารถในการค้นหาได้ดีเป็นทักษะที่จำเป็นในการแก้ไข การเชี่ยวชาญในการค้นหาจะช่วยให้คุณใช้ความยืดหยุ่นของนิพจน์ปกติเพื่อค้นหารูปแบบใด ๆ ในไฟล์ ใช้เวลาในการเรียนรู้สิ่งเหล่านี้ เพื่อให้ดีขึ้นกับนิพจน์ปกติคุณต้องใช้งานนิพจน์ปกติอย่างต่อเนื่อง ฉันเคยอ่านหนังสือเกี่ยวกับนิพจน์ปกติโดยไม่ทำจริง ๆ และลืมเกือบทุกอย่างที่อ่านไปแล้ว การเขียนโค้ดอย่างกระตือรือร้นเป็นวิธีที่ดีที่สุดในการเชี่ยวชาญทักษะใด ๆ

วิธีที่ดีในการปรับปรุงทักษะการจับคู่รูปแบบคือเมื่อใดก็ตามที่คุณต้องการค้นหารูปแบบ (เช่น "hello 123") แทนที่จะค้นหาคำค้นหาตรง ๆ (`/hello 123`) ให้ลองคิดค้นรูปแบบสำหรับมัน (เช่น `/\v(\l+) (\d+)`) หลายแนวคิดของนิพจน์ปกติเหล่านี้ยังสามารถนำไปใช้ในโปรแกรมทั่วไป ไม่เพียงแต่เมื่อใช้ Vim

ตอนนี้ที่คุณได้เรียนรู้เกี่ยวกับการค้นหาและการแทนที่ขั้นสูงใน Vim มาศึกษาหนึ่งในคำสั่งที่หลากหลายที่สุด คำสั่งทั่วโลก