---
description: เอกสารนี้นำเสนอการสร้างปลั๊กอิน Vim ชื่อ totitle-vim ซึ่งช่วยในการจัดรูปแบบตัวอักษรให้เป็น
  Title Case สำหรับหัวข้อในเอกสาร.
title: 'Ch29. Write a Plugin: Creating a Titlecase Operator'
---

เมื่อคุณเริ่มเก่งขึ้นใน Vim คุณอาจต้องการเขียนปลั๊กอินของตัวเอง เมื่อเร็ว ๆ นี้ฉันได้เขียนปลั๊กอิน Vim ตัวแรกของฉัน [totitle-vim](https://github.com/iggredible/totitle-vim) มันเป็นปลั๊กอินที่ทำงานเกี่ยวกับ titlecase คล้ายกับตัวดำเนินการ uppercase `gU` lowercase `gu` และ togglecase `g~` ของ Vim

ในบทนี้ ฉันจะนำเสนอการวิเคราะห์ปลั๊กอิน `totitle-vim` หวังว่าจะช่วยให้คุณเข้าใจในกระบวนการและอาจจะสร้างแรงบันดาลใจให้คุณสร้างปลั๊กอินที่ไม่เหมือนใครของคุณเอง!

## ปัญหา

ฉันใช้ Vim ในการเขียนบทความของฉัน รวมถึงคู่มือนี้ด้วย

ปัญหาหลักคือการสร้าง title case ที่เหมาะสมสำหรับหัวข้อ วิธีหนึ่งในการทำให้เป็นอัตโนมัติคือการทำให้ตัวอักษรแรกของแต่ละคำในหัวข้อเป็นตัวพิมพ์ใหญ่ด้วยคำสั่ง `g/^#/ s/\<./\u\0/g` สำหรับการใช้งานพื้นฐาน คำสั่งนี้ก็เพียงพอ แต่ยังไม่ดีเท่าการมี title case ที่แท้จริง คำว่า "The" และ "Of" ใน "Capitalize The First Letter Of Each Word" ควรจะถูกทำให้เป็นตัวพิมพ์ใหญ่ หากไม่มีการทำให้ตัวพิมพ์ใหญ่ที่เหมาะสม ประโยคจะดูแปลก ๆ เล็กน้อย

ในตอนแรก ฉันไม่ได้วางแผนที่จะเขียนปลั๊กอิน นอกจากนี้ยังพบว่ามีปลั๊กอิน titlecase อยู่แล้ว: [vim-titlecase](https://github.com/christoomey/vim-titlecase) อย่างไรก็ตาม มีบางอย่างที่ไม่ทำงานตามที่ฉันต้องการ สิ่งที่สำคัญคือพฤติกรรมของโหมด visual แบบ block หากฉันมีวลี:

```shell
test title one
test title two
test title three
```

ถ้าฉันใช้การเน้นแบบ block บน "tle":

```shell
test ti[tle] one
test ti[tle] two
test ti[tle] three
```

ถ้าฉันกด `gt` ปลั๊กอินจะไม่ทำให้มันเป็นตัวพิมพ์ใหญ่ ฉันพบว่ามันไม่สอดคล้องกับพฤติกรรมของ `gu`, `gU`, และ `g~` ดังนั้นฉันจึงตัดสินใจที่จะทำงานจาก repo ของปลั๊กอิน titlecase นั้นและใช้มันเพื่อสร้างปลั๊กอิน titlecase ของตัวเองที่สอดคล้องกับ `gu`, `gU`, และ `g~`! อีกครั้ง ปลั๊กอิน vim-titlecase เองก็เป็นปลั๊กอินที่ยอดเยี่ยมและควรค่าแก่การใช้งานด้วยตัวมันเอง (ความจริงคือ บางทีลึก ๆ แล้วฉันแค่ต้องการเขียนปลั๊กอิน Vim ของตัวเอง ฉันไม่สามารถมองเห็นฟีเจอร์การทำ titlecase แบบ block จะถูกใช้บ่อยในชีวิตจริงนอกจากกรณีเฉพาะ)

### การวางแผนสำหรับปลั๊กอิน

ก่อนที่จะเขียนบรรทัดแรกของโค้ด ฉันต้องตัดสินใจว่ากฎของ titlecase คืออะไร ฉันพบตารางที่เรียบร้อยของกฎการทำตัวพิมพ์ใหญ่ที่แตกต่างกันจาก [titlecaseconverter site](https://titlecaseconverter.com/rules/) คุณรู้ไหมว่ามีกฎการทำตัวพิมพ์ใหญ่ที่แตกต่างกันอย่างน้อย 8 ข้อในภาษาอังกฤษ? *อึ้ง!*

ในที่สุด ฉันใช้ตัวหารทั่วไปจากรายการนั้นเพื่อสร้างกฎพื้นฐานที่ดีพอสำหรับปลั๊กอิน นอกจากนี้ฉันสงสัยว่าผู้คนจะบ่นว่า "เฮ้เพื่อน คุณใช้ AMA ทำไมคุณไม่ใช้ APA?" นี่คือกฎพื้นฐาน:
- คำแรกจะต้องเป็นตัวพิมพ์ใหญ่เสมอ
- คำกริยาวิเศษณ์ บทเชื่อม และคำบุพบทบางคำจะต้องเป็นตัวพิมพ์เล็ก
- หากคำที่ป้อนเป็นตัวพิมพ์ใหญ่ทั้งหมด ก็ไม่ต้องทำอะไร (อาจเป็นตัวย่อ)

สำหรับคำที่ต้องทำเป็นตัวพิมพ์เล็ก กฎที่แตกต่างกันก็มีรายการที่แตกต่างกัน ฉันตัดสินใจที่จะยึดตาม `a an and at but by en for in nor of off on or out per so the to up yet vs via`

### การวางแผนสำหรับอินเทอร์เฟซผู้ใช้

ฉันต้องการให้ปลั๊กอินเป็นตัวดำเนินการเพื่อเสริมตัวดำเนินการ case ที่มีอยู่ใน Vim: `gu`, `gU`, และ `g~` ในฐานะที่เป็นตัวดำเนินการ มันต้องรับการเคลื่อนไหวหรือวัตถุข้อความ (`gtw` ควรทำให้ titlecase คำถัดไป, `gtiw` ควรทำให้ titlecase คำภายใน, `gt$` ควรทำให้ titlecase คำจากตำแหน่งปัจจุบันจนถึงจบบรรทัด, `gtt` ควรทำให้ titlecase บรรทัดปัจจุบัน, `gti(` ควรทำให้ titlecase คำภายในวงเล็บ เป็นต้น) ฉันยังต้องการให้มันถูกแมพไปที่ `gt` เพื่อให้ง่ายต่อการจดจำ นอกจากนี้มันยังควรทำงานกับโหมด visual ทั้งหมด: `v`, `V`, และ `Ctrl-V` ฉันควรสามารถเน้นมันใน *โหมด visual ใด ๆ* กด `gt` แล้วข้อความที่ถูกเน้นทั้งหมดจะถูกทำให้เป็น titlecase

## Vim Runtime

สิ่งแรกที่คุณเห็นเมื่อคุณดูที่ repo คือมันมีสองไดเรกทอรี: `plugin/` และ `doc/` เมื่อคุณเริ่ม Vim มันจะมองหาไฟล์และไดเรกทอรีพิเศษภายในไดเรกทอรี `~/.vim` และรันไฟล์สคริปต์ทั้งหมดภายในไดเรกทอรีนั้น สำหรับข้อมูลเพิ่มเติม ให้ตรวจสอบบทที่เกี่ยวกับ Vim Runtime

ปลั๊กอินใช้สองไดเรกทอรี runtime ของ Vim: `doc/` และ `plugin/` `doc/` เป็นสถานที่สำหรับใส่เอกสารช่วยเหลือ (ดังนั้นคุณสามารถค้นหาคำสำคัญในภายหลัง เช่น `:h totitle`) ฉันจะอธิบายวิธีการสร้างหน้าช่วยเหลือในภายหลัง สำหรับตอนนี้ ให้เรามุ่งเน้นไปที่ `plugin/` ไดเรกทอรี `plugin/` จะถูกดำเนินการเพียงครั้งเดียวเมื่อ Vim เริ่มต้น มีไฟล์หนึ่งไฟล์ภายในไดเรกทอรีนี้: `totitle.vim` การตั้งชื่อไม่สำคัญ (ฉันสามารถตั้งชื่อมันว่า `whatever.vim` และมันก็ยังทำงานได้) โค้ดทั้งหมดที่รับผิดชอบในการทำงานของปลั๊กอินอยู่ภายในไฟล์นี้

## การแมพ

มาดูโค้ดกันเถอะ!

ที่จุดเริ่มต้นของไฟล์ คุณจะเห็นว่า:

```shell
if !exists('g:totitle_default_keys')
  let g:totitle_default_keys = 1
endif
```

เมื่อคุณเริ่ม Vim `g:totitle_default_keys` จะยังไม่ถูกสร้างขึ้น ดังนั้น `!exists(...)` จะคืนค่า true ในกรณีนี้ ให้กำหนด `g:totitle_default_keys` ให้เท่ากับ 1 ใน Vim, 0 คือ false และ non-zero คือ true (ใช้ 1 เพื่อระบุว่าเป็น true)

มาที่ด้านล่างของไฟล์ คุณจะเห็นว่า:

```shell
if g:totitle_default_keys
  nnoremap <expr> gt ToTitle()
  xnoremap <expr> gt ToTitle()
  nnoremap <expr> gtt ToTitle() .. '_'
endif
```

นี่คือที่ที่การแมพ `gt` หลักถูกกำหนด ในกรณีนี้ เมื่อคุณมาถึงเงื่อนไข `if` ที่ด้านล่างของไฟล์ `if g:totitle_default_keys` จะคืนค่า 1 (true) ดังนั้น Vim จะทำการแมพดังต่อไปนี้:
- `nnoremap <expr> gt ToTitle()` แมพตัวดำเนินการโหมดปกติ ซึ่งช่วยให้คุณเรียกใช้ตัวดำเนินการ + การเคลื่อนไหว/วัตถุข้อความ เช่น `gtw` เพื่อทำให้ titlecase คำถัดไปหรือ `gtiw` เพื่อทำให้ titlecase คำภายใน ฉันจะอธิบายรายละเอียดเกี่ยวกับวิธีการทำงานของการแมพตัวดำเนินการในภายหลัง
- `xnoremap <expr> gt ToTitle()` แมพตัวดำเนินการโหมด visual ซึ่งช่วยให้คุณทำให้ titlecase ข้อความที่ถูกเน้น
- `nnoremap <expr> gtt ToTitle() .. '_'` แมพตัวดำเนินการแบบ linewise ในโหมดปกติ (เทียบเท่ากับ `guu` และ `gUU`) คุณอาจสงสัยว่า `.. '_'` ทำอะไรที่ท้าย คำว่า `..` คือ operator การเชื่อมโยงสตริงของ Vim `_` ถูกใช้เป็นการเคลื่อนไหวร่วมกับตัวดำเนินการ หากคุณดูใน `:help _` มันบอกว่าขีดล่างถูกใช้เพื่อระบุ 1 บรรทัดลงไป มันทำการดำเนินการกับบรรทัดปัจจุบัน (ลองใช้กับตัวดำเนินการอื่น ๆ ลองรัน `gU_` หรือ `d_` สังเกตว่ามันทำเหมือนกับ `gUU` หรือ `dd`)
- สุดท้าย อาร์กิวเมนต์ `<expr>` ช่วยให้คุณระบุจำนวนได้ ดังนั้นคุณสามารถทำ `3gtw` เพื่อทำให้ titlecase คำถัดไป 3 คำ

ถ้าคุณไม่ต้องการใช้การแมพ `gt` เริ่มต้นล่ะ? หลังจากทั้งหมด คุณกำลังเขียนทับการแมพ `gt` เริ่มต้นของ Vim (tab ถัดไป) ถ้าคุณต้องการใช้ `gz` แทน `gt` จำได้ไหมเมื่อสักครู่คุณได้ผ่านการตรวจสอบ `if !exists('g:totitle_default_keys')` และ `if g:totitle_default_keys`? หากคุณใส่ `let g:totitle_default_keys = 0` ใน vimrc ของคุณ `g:totitle_default_keys` จะมีอยู่แล้วเมื่อปลั๊กอินทำงาน (โค้ดใน vimrc ของคุณจะถูกดำเนินการก่อนไฟล์ runtime `plugin/`) ดังนั้น `!exists('g:totitle_default_keys')` จะคืนค่า false นอกจากนี้ `if g:totitle_default_keys` จะเป็น false (เพราะมันจะมีค่าเป็น 0) ดังนั้นมันจะไม่ทำการแมพ `gt` ด้วย! นี่ทำให้คุณสามารถกำหนดการแมพที่กำหนดเองใน Vimrc ได้

เพื่อกำหนดการแมพ titlecase ของคุณเองไปที่ `gz` ให้เพิ่มสิ่งนี้ใน vimrc ของคุณ:

```shell
let g:totitle_default_keys = 0

nnoremap <expr> gz ToTitle()
xnoremap <expr> gz ToTitle()
nnoremap <expr> gzz ToTitle() .. '_'
```

ง่ายมาก

## ฟังก์ชัน ToTitle

ฟังก์ชัน `ToTitle()` เป็นฟังก์ชันที่ยาวที่สุดในไฟล์นี้

```shell
 function! ToTitle(type = '')
  if a:type ==# ''
    set opfunc=ToTitle
    return 'g@'
  endif

  " invoke this when calling the ToTitle() function
  if a:type != 'block' && a:type != 'line' && a:type != 'char'
    let l:words = a:type
    let l:wordsArr = trim(l:words)->split('\s\+')
    call map(l:wordsArr, 's:capitalize(v:val)')
    return l:wordsArr->join(' ')
  endif

  " save the current settings
  let l:sel_save = &selection
  let l:reg_save = getreginfo('"')
  let l:cb_save = &clipboard
  let l:visual_marks_save = [getpos("'<"), getpos("'>")]

  try
    set clipboard= selection=inclusive
    let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

    silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
    let l:selected_phrase = getreg('"')
    let l:WORD_PATTERN = '\<\k*\>'
    let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

    let l:startLine = line("'<")
    let l:startCol = virtcol(".")

    " when user calls a block operation
    if a:type ==# "block"
      sil! keepj norm! gv"ad
      keepj $
      keepj pu_

      let l:lastLine = line("$")

      sil! keepj norm "ap

      let l:curLine = line(".")

      sil! keepj norm! VGg@
      exe "keepj norm! 0\<c-v>G$h\"ad"
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
      exe "keepj " . l:lastLine
      sil! keepj norm! "_dG
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"

    " when user calls a char or line operation
    else
      let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
      let l:titlecased = s:capitalizeFirstWord(l:titlecased)
      call setreg('"', l:titlecased)
      let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
      silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
      exe "keepj " . l:startLine
      exe "sil! keepj norm! " . l:startCol . "\<bar>"
    endif
  finally

    " restore the settings
    call setreg('"', l:reg_save)
    call setpos("'<", l:visual_marks_save[0])
    call setpos("'>", l:visual_marks_save[1])
    let &clipboard = l:cb_save
    let &selection = l:sel_save
  endtry
  return
endfunction
```

นี่เป็นฟังก์ชันที่ยาวมาก ดังนั้นให้เราทำการแบ่งมันออกเป็นส่วน ๆ

*ฉันสามารถปรับโครงสร้างนี้ให้เป็นส่วนที่เล็กลงได้ แต่เพื่อให้บทนี้เสร็จสมบูรณ์ ฉันจึงปล่อยให้มันเป็นแบบนี้*
## ฟังก์ชันโอเปอเรเตอร์

นี่คือส่วนแรกของโค้ด:

```shell
if a:type ==# ''
  set opfunc=ToTitle
  return 'g@'
endif
```

โอ้ มันคืออะไร `opfunc`? ทำไมมันถึงคืนค่า `g@`?

Vim มีโอเปอเรเตอร์พิเศษ โอเปอเรเตอร์ฟังก์ชัน `g@` โอเปอเรเตอร์นี้ให้คุณใช้ฟังก์ชัน *ใดๆ* ที่ถูกกำหนดให้กับตัวเลือก `opfunc` ถ้าผมมีฟังก์ชัน `Foo()` ที่กำหนดให้กับ `opfunc` แล้วเมื่อผมรัน `g@w` ผมจะรัน `Foo()` บนคำถัดไป ถ้าผมรัน `g@i(` ผมจะรัน `Foo()` บนวงเล็บภายใน ฟังก์ชันโอเปอเรเตอร์นี้มีความสำคัญในการสร้างโอเปอเรเตอร์ Vim ของคุณเอง

บรรทัดถัดไปกำหนด `opfunc` ให้กับฟังก์ชัน `ToTitle`

```shell
set opfunc=ToTitle
```

บรรทัดถัดไปจะคืนค่า `g@`:

```shell
return g@
```

ดังนั้นสองบรรทัดนี้ทำงานอย่างไรและทำไมถึงคืนค่า `g@`?

สมมติว่าคุณมีการแมพดังต่อไปนี้:

```shell
nnoremap <expr> gt ToTitle()`
```

จากนั้นคุณกด `gtw` (เปลี่ยนคำถัดไปให้เป็นตัวพิมพ์ใหญ่) ครั้งแรกที่คุณรัน `gtw` Vim จะเรียกใช้เมธอด `ToTitle()` แต่ตอนนี้ `opfunc` ยังว่างอยู่ คุณยังไม่ได้ส่งอาร์กิวเมนต์ใดๆ ให้กับ `ToTitle()` ดังนั้นมันจะมีค่า `a:type` เป็น `''` สิ่งนี้ทำให้การตรวจสอบเงื่อนไข `if a:type ==# ''` เป็นจริง ภายในคุณกำหนด `opfunc` ให้กับฟังก์ชัน `ToTitle` ด้วย `set opfunc=ToTitle` ตอนนี้ `opfunc` ถูกกำหนดให้กับ `ToTitle` สุดท้ายหลังจากที่คุณกำหนด `opfunc` ให้กับฟังก์ชัน `ToTitle` คุณคืนค่า `g@` ผมจะอธิบายว่าทำไมมันถึงคืนค่า `g@` ด้านล่าง

คุณยังไม่เสร็จสิ้น จำไว้ว่าคุณเพิ่งกด `gtw` การกด `gt` ทำทุกอย่างข้างต้น แต่คุณยังมี `w` ที่ต้องประมวลผล โดยการคืนค่า `g@` ณ จุดนี้ คุณมี `g@w` (นี่คือเหตุผลที่คุณมี `return g@`) เนื่องจาก `g@` เป็นฟังก์ชันโอเปอเรเตอร์ คุณกำลังส่งการเคลื่อนไหว `w` ให้กับมัน ดังนั้น Vim เมื่อได้รับ `g@w` จะเรียกใช้ `ToTitle` *อีกครั้งหนึ่ง* (ไม่ต้องกังวล คุณจะไม่จบลงด้วยการวนลูปไม่สิ้นสุดตามที่คุณจะเห็นในอีกสักครู่)

เพื่อสรุป โดยการกด `gtw` Vim จะตรวจสอบว่า `opfunc` ว่างหรือไม่ ถ้ามันว่าง Vim จะกำหนดให้กับ `ToTitle` จากนั้นมันจะคืนค่า `g@` ซึ่งเป็นการเรียกใช้ `ToTitle` อีกครั้งหนึ่งเพื่อให้คุณสามารถใช้มันเป็นโอเปอเรเตอร์ได้ นี่คือส่วนที่ยากที่สุดในการสร้างโอเปอเรเตอร์ที่กำหนดเองและคุณทำมันได้! ต่อไปคุณต้องสร้างลอจิกสำหรับ `ToTitle()` เพื่อเปลี่ยนข้อความให้เป็นตัวพิมพ์ใหญ่จริงๆ

## การประมวลผลข้อมูลนำเข้า

ตอนนี้คุณมี `gt` ทำงานเป็นโอเปอเรเตอร์ที่เรียกใช้ `ToTitle()` แต่คุณจะทำอะไรต่อไป? คุณจะเปลี่ยนข้อความให้เป็นตัวพิมพ์ใหญ่จริงๆ ได้อย่างไร?

เมื่อใดก็ตามที่คุณรันโอเปอเรเตอร์ใดๆ ใน Vim จะมีสามประเภทการเคลื่อนไหวที่แตกต่างกัน: ตัวอักษร, บรรทัด, และบล็อก `g@w` (คำ) เป็นตัวอย่างของการดำเนินการตัวอักษร `g@j` (หนึ่งบรรทัดด้านล่าง) เป็นตัวอย่างของการดำเนินการบรรทัด การดำเนินการบล็อกนั้นหายาก แต่โดยทั่วไปเมื่อคุณทำการดำเนินการ `Ctrl-V` (บล็อกวิชวล) มันจะถูกนับเป็นการดำเนินการบล็อก การดำเนินการที่มุ่งเป้าไปที่ตัวอักษรไม่กี่ตัวไปข้างหน้า / ถอยหลังจะถือว่าเป็นการดำเนินการตัวอักษร (`b`, `e`, `w`, `ge`, ฯลฯ) การดำเนินการที่มุ่งเป้าไปที่บรรทัดไม่กี่บรรทัดไปข้างล่าง / ขึ้นจะถือว่าเป็นการดำเนินการบรรทัด (`j`, `k`) การดำเนินการที่มุ่งเป้าไปที่คอลัมน์ไปข้างหน้า, ถอยหลัง, ขึ้น, หรือลงจะถือว่าเป็นการดำเนินการบล็อก (โดยทั่วไปจะเป็นการเคลื่อนไหวแบบคอลัมน์ที่บังคับหรือโหมดวิชวลบล็อก; สำหรับข้อมูลเพิ่มเติม: `:h forced-motion`)

นี่หมายความว่า ถ้าคุณกด `g@w` `g@` จะส่งสตริงตัวอักษร `"char"` เป็นอาร์กิวเมนต์ให้กับ `ToTitle()` ถ้าคุณทำ `g@j` `g@` จะส่งสตริงตัวอักษร `"line"` เป็นอาร์กิวเมนต์ให้กับ `ToTitle()` สตริงนี้คือสิ่งที่จะถูกส่งเข้าไปในฟังก์ชัน `ToTitle` เป็นอาร์กิวเมนต์ `type`

## การสร้างฟังก์ชันโอเปอเรเตอร์ที่กำหนดเองของคุณเอง

ให้เราหยุดและเล่นกับ `g@` โดยการเขียนฟังก์ชันตัวอย่าง:

```shell
function! Test(some_arg)
  echom a:some_arg 
endfunction
```

ตอนนี้กำหนดฟังก์ชันนั้นให้กับ `opfunc` โดยการรัน:

```shell
:set opfunc=Test
```

โอเปอเรเตอร์ `g@` จะเรียกใช้ `Test(some_arg)` และส่งมันด้วย `"char"`, `"line"`, หรือ `"block"` ขึ้นอยู่กับว่าคุณทำการดำเนินการอะไร รันการดำเนินการต่างๆ เช่น `g@iw` (คำภายใน), `g@j` (หนึ่งบรรทัดด้านล่าง), `g@$` (จนถึงจุดสิ้นสุดของบรรทัด) เป็นต้น ดูค่าที่แตกต่างกันที่ถูกแสดงออกมา เพื่อทดสอบการดำเนินการบล็อก คุณสามารถใช้การเคลื่อนไหวที่บังคับของ Vim สำหรับการดำเนินการบล็อก: `g@Ctrl-Vj` (การดำเนินการบล็อกหนึ่งคอลัมน์ด้านล่าง)

คุณยังสามารถใช้มันกับโหมดวิชวล ใช้การไฮไลต์วิชวลต่างๆ เช่น `v`, `V`, และ `Ctrl-V` แล้วกด `g@` (โปรดระวัง มันจะแสดงผลลัพธ์อย่างรวดเร็ว ดังนั้นคุณต้องมีสายตาที่รวดเร็ว - แต่ผลลัพธ์นั้นอยู่ที่นั่นแน่นอน นอกจากนี้ เนื่องจากคุณใช้ `echom` คุณสามารถตรวจสอบข้อความที่บันทึกด้วย `:messages`)

เจ๋งมากใช่ไหม? สิ่งที่คุณสามารถโปรแกรมด้วย Vim! ทำไมพวกเขาไม่สอนสิ่งนี้ในโรงเรียน? มาต่อกันที่ปลั๊กอินของเรา

## ToTitle เป็นฟังก์ชัน

ไปที่บรรทัดถัดไป:

```shell
if a:type != 'block' && a:type != 'line' && a:type != 'char'
  let l:words = a:type
  let l:wordsArr = trim(l:words)->split('\s\+')
  call map(l:wordsArr, 's:capitalize(v:val)')
  return l:wordsArr->join(' ')
endif
```

บรรทัดนี้จริงๆ แล้วไม่มีอะไรเกี่ยวข้องกับพฤติกรรมของ `ToTitle()` ในฐานะโอเปอเรเตอร์ แต่เพื่อเปิดใช้งานให้เป็นฟังก์ชัน TitleCase ที่เรียกใช้ได้ (ใช่ ผมรู้ว่าผมกำลังละเมิดหลักการความรับผิดชอบเดียว) แรงจูงใจคือ Vim มีฟังก์ชัน `toupper()` และ `tolower()` ที่จะเปลี่ยนข้อความใดๆ ให้เป็นตัวพิมพ์ใหญ่และตัวพิมพ์เล็ก ตัวอย่างเช่น `:echo toupper('hello')` คืนค่า `'HELLO'` และ `:echo tolower('HELLO')` คืนค่า `'hello'` ผมต้องการให้ปลั๊กอินนี้มีความสามารถในการรัน `ToTitle` ดังนั้นคุณสามารถทำ `:echo ToTitle('once upon a time')` และได้รับค่าคืนเป็น `'Once Upon a Time'`

ตอนนี้คุณรู้แล้วว่าเมื่อคุณเรียกใช้ `ToTitle(type)` ด้วย `g@` อาร์กิวเมนต์ `type` จะมีค่าเป็น `'block'`, `'line'`, หรือ `'char'` ถ้าอาร์กิวเมนต์ไม่ใช่ `'block'` หรือ `'line'` หรือ `'char'` คุณสามารถสันนิษฐานได้อย่างปลอดภัยว่า `ToTitle()` ถูกเรียกใช้จากภายนอก `g@` ในกรณีนั้น คุณจะแยกมันตามช่องว่าง (`\s\+`) ด้วย:

```shell
let l:wordsArr = trim(l:words)->split('\s\+')
```

จากนั้นทำให้แต่ละองค์ประกอบเป็นตัวพิมพ์ใหญ่:

```shell
call map(l:wordsArr, 's:capitalize(v:val)')
```

ก่อนที่จะรวมมันกลับเข้าด้วยกัน:

```shell
l:wordsArr->join(' ')
```

ฟังก์ชัน `capitalize()` จะถูกกล่าวถึงในภายหลัง

## ตัวแปรชั่วคราว

บรรทัดถัดไป:

```shell
let l:sel_save = &selection
let l:reg_save = getreginfo('"')
let l:cb_save = &clipboard
let l:visual_marks_save = [getpos("'<"), getpos("'>")]
```

บรรทัดเหล่านี้จะเก็บสถานะปัจจุบันต่างๆ ลงในตัวแปรชั่วคราว ในภายหลังคุณจะใช้โหมดวิชวล, มาร์ค, และรีจิสเตอร์ การทำเช่นนี้จะทำให้สถานะบางอย่างเปลี่ยนแปลง เนื่องจากคุณไม่ต้องการแก้ไขประวัติ คุณจึงต้องบันทึกสถานะเหล่านี้ลงในตัวแปรชั่วคราวเพื่อให้คุณสามารถคืนสถานะได้ในภายหลัง
## การใช้ตัวเลือกให้เป็นตัวพิมพ์ใหญ่

บรรทัดถัดไปนี้มีความสำคัญ:

```shell
try
  set clipboard= selection=inclusive
  let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}

  silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
  let l:selected_phrase = getreg('"')
  let l:WORD_PATTERN = '\<\k*\>'
  let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'

  let l:startLine = line("'<")
  let l:startCol = virtcol(".")
```
มาดูทีละน้อยกัน บรรทัดนี้:

```shell
set clipboard= selection=inclusive
```

คุณตั้งค่าตัวเลือก `selection` ให้เป็น inclusive และ `clipboard` ให้ว่าง ตัวเลือกการเลือกมักใช้กับโหมดวิชวลและมีค่าที่เป็นไปได้สามค่า: `old`, `inclusive`, และ `exclusive` การตั้งค่าให้เป็น inclusive หมายความว่าตัวอักษรสุดท้ายของการเลือกจะรวมอยู่ด้วย โดยปกติ Vim จะตั้งค่าให้เป็น inclusive แต่คุณตั้งค่าไว้ที่นี่เพื่อความแน่ใจในกรณีที่ปลั๊กอินของคุณตั้งค่าเป็นค่าที่แตกต่างออกไป ตรวจสอบ `:h 'clipboard'` และ `:h 'selection'` หากคุณสงสัยว่ามันทำอะไรจริงๆ

ถัดไปคุณมีแฮชที่ดูแปลกๆ ตามด้วยคำสั่ง execute:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
silent exe 'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')
```

ก่อนอื่น ไวยากรณ์ `#{}` เป็นประเภทข้อมูลดิกชันนารีของ Vim ตัวแปรท้องถิ่น `l:commands` เป็นแฮชที่มี 'lines', 'char', และ 'block' เป็นคีย์ คำสั่ง `silent exe '...'` จะดำเนินการคำสั่งใดๆ ภายในสตริงอย่างเงียบๆ (มิฉะนั้นจะมีการแสดงการแจ้งเตือนที่ด้านล่างของหน้าจอคุณ)

ประการที่สอง คำสั่งที่ดำเนินการคือ `'noautocmd keepjumps normal! ' .. get(l:commands, a:type, '')` คำสั่งแรก `noautocmd` จะดำเนินการคำสั่งถัดไปโดยไม่กระตุ้นคำสั่งอัตโนมัติใดๆ คำสั่งที่สอง `keepjumps` คือการไม่บันทึกการเคลื่อนไหวของเคอร์เซอร์ในขณะที่เคลื่อนที่ ใน Vim การเคลื่อนไหวบางอย่างจะถูกบันทึกโดยอัตโนมัติในรายการการเปลี่ยนแปลง รายการกระโดด และรายการเครื่องหมาย สิ่งนี้จะป้องกันไม่ให้เกิดขึ้น จุดประสงค์ของการมี `noautocmd` และ `keepjumps` คือเพื่อป้องกันผลข้างเคียง สุดท้าย คำสั่ง `normal` จะดำเนินการสตริงเป็นคำสั่งปกติ `..` เป็นไวยากรณ์การแทรกสตริงของ Vim `get()` เป็นวิธีการ getter ที่รับรายการ บล็อค หรือดิกชันนารี ในกรณีนี้ คุณกำลังส่งดิกชันนารี `l:commands` คีย์คือ `a:type` คุณได้เรียนรู้ก่อนหน้านี้ว่า `a:type` เป็นหนึ่งในสามค่าของสตริง: 'char', 'line', หรือ 'block' ดังนั้นหาก `a:type` เป็น 'line' คุณจะดำเนินการ `"noautocmd keepjumps normal! '[V']y"` (สำหรับข้อมูลเพิ่มเติม ตรวจสอบ `:h silent`, `:h :exe`, `:h :noautocmd`, `:h :keepjumps`, `:h :normal`, และ `:h get()`)

มาดูว่า `'[V']y` ทำอะไร สมมติว่าคุณมีเนื้อหานี้:

```shell
the second breakfast
is better than the first breakfast
```
สมมติว่าเคอร์เซอร์ของคุณอยู่ในบรรทัดแรก จากนั้นคุณกด `g@j` (เรียกใช้ฟังก์ชันตัวดำเนินการ `g@` หนึ่งบรรทัดด้านล่างด้วย `j`) `'[` จะเคลื่อนที่เคอร์เซอร์ไปยังจุดเริ่มต้นของข้อความที่ถูกเปลี่ยนแปลงหรือยกขึ้นก่อนหน้านี้ แม้ว่าคุณจะไม่ได้เปลี่ยนแปลงหรือยกข้อความใดๆ ด้วย `g@j` แต่ Vim จะจดจำตำแหน่งของการเคลื่อนไหวเริ่มต้นและสิ้นสุดของคำสั่ง `g@` ด้วย `'[` และ `']` (สำหรับข้อมูลเพิ่มเติม ตรวจสอบ `:h g@`) ในกรณีของคุณ การกด `'[` จะเคลื่อนที่เคอร์เซอร์ไปยังบรรทัดแรกเพราะนั่นคือจุดที่คุณเริ่มเมื่อคุณเรียกใช้ `g@` `V` เป็นคำสั่งโหมดวิชวลแบบบรรทัด สุดท้าย `']` จะเคลื่อนที่เคอร์เซอร์ไปยังจุดสิ้นสุดของข้อความที่ถูกเปลี่ยนแปลงหรือยกขึ้นก่อนหน้านี้ แต่ในกรณีนี้ มันจะเคลื่อนที่เคอร์เซอร์ไปยังจุดสิ้นสุดของการดำเนินการ `g@` ล่าสุดของคุณ สุดท้าย `y` จะยกข้อความที่เลือก

สิ่งที่คุณทำคือการยกข้อความเดียวกันที่คุณดำเนินการ `g@` ไป

หากคุณดูคำสั่งอีกสองคำสั่งในที่นี้:

```shell
let l:commands = #{line: "'[V']y", char: "`[v`]y", block: "`[\<c-v>`]y"}
```

พวกเขาทั้งหมดทำการกระทำที่คล้ายกัน ยกเว้นแทนที่จะใช้การกระทำแบบบรรทัด คุณจะใช้การกระทำแบบตัวอักษรหรือแบบบล็อก ฉันจะฟังดูซ้ำซาก แต่ในทั้งสามกรณี คุณกำลังยกข้อความเดียวกันที่คุณดำเนินการ `g@` ไป

มาดูบรรทัดถัดไป:

```shell
let l:selected_phrase = getreg('"')
```

บรรทัดนี้จะดึงเนื้อหาของรีจิสเตอร์ที่ไม่มีชื่อ (`"`) และเก็บไว้ในตัวแปร `l:selected_phrase` รอสักครู่... คุณไม่ได้ยกข้อความไว้หรือ? รีจิสเตอร์ที่ไม่มีชื่อในขณะนี้มีข้อความที่คุณเพิ่งยกขึ้น นี่คือวิธีที่ปลั๊กอินนี้สามารถดึงสำเนาของข้อความได้

บรรทัดถัดไปคือรูปแบบของการแสดงออกปกติ:

```shell
let l:WORD_PATTERN = '\<\k*\>'
```

`\<` และ `\>` เป็นรูปแบบขอบเขตของคำ ตัวอักษรที่ตามหลัง `\<` จะตรงกับจุดเริ่มต้นของคำและตัวอักษรที่อยู่ก่อน `\>` จะตรงกับจุดสิ้นสุดของคำ `\k` เป็นรูปแบบคำสำคัญ คุณสามารถตรวจสอบตัวอักษรที่ Vim ยอมรับเป็นคำสำคัญได้ที่ `:set iskeyword?` จำไว้ว่าการเคลื่อนไหว `w` ใน Vim จะเคลื่อนที่เคอร์เซอร์ของคุณตามคำ Vim มาพร้อมกับแนวคิดที่กำหนดไว้ล่วงหน้าเกี่ยวกับสิ่งที่เป็น "คำสำคัญ" (คุณสามารถแก้ไขพวกเขาได้โดยการเปลี่ยนแปลงตัวเลือก `iskeyword`) ตรวจสอบ `:h /\<`, `:h /\>`, และ `:h /\k`, และ `:h 'iskeyword'` สำหรับข้อมูลเพิ่มเติม สุดท้าย `*` หมายถึงศูนย์หรือมากกว่าของรูปแบบถัดไป

ในภาพรวม `'\<\k*\>'` จะตรงกับคำ หากคุณมีสตริง:

```shell
one two three
```

การจับคู่กับรูปแบบจะให้ผลลัพธ์สามรายการ: "one", "two", และ "three"

สุดท้าย คุณมีรูปแบบอีกหนึ่ง:

```shell
let l:UPCASE_REPLACEMENT = '\=s:capitalize(submatch(0))'
```

จำไว้ว่าคำสั่งแทนที่ของ Vim สามารถใช้กับการแสดงออกด้วย `\={your-expression}` ตัวอย่างเช่น หากคุณต้องการให้ตัวพิมพ์ใหญ่สตริง "donut" ในบรรทัดปัจจุบัน คุณสามารถใช้ฟังก์ชัน `toupper()` ของ Vim ได้ คุณสามารถทำได้โดยการรัน `:%s/donut/\=toupper(submatch(0))/g` `submatch(0)` เป็นการแสดงออกพิเศษที่ใช้ในคำสั่งแทนที่ มันจะส่งคืนข้อความที่ตรงกันทั้งหมด

สองบรรทัดถัดไป:

```shell
let l:startLine = line("'<")
let l:startCol = virtcol(".")
```

การแสดงออก `line()` จะส่งคืนหมายเลขบรรทัด ที่นี่คุณส่งไปพร้อมกับเครื่องหมาย `'<` ซึ่งแสดงถึงบรรทัดแรกของพื้นที่วิชวลที่เลือกล่าสุด จำไว้ว่าคุณใช้โหมดวิชวลเพื่อยกข้อความ `'<` จะส่งคืนหมายเลขบรรทัดของจุดเริ่มต้นของการเลือกพื้นที่วิชวลนั้น การแสดงออก `virtcol()` จะส่งคืนหมายเลขคอลัมน์ของเคอร์เซอร์ปัจจุบัน คุณจะเคลื่อนที่เคอร์เซอร์ไปทั่วในอีกสักครู่ ดังนั้นคุณจำเป็นต้องเก็บตำแหน่งเคอร์เซอร์ของคุณไว้เพื่อให้คุณสามารถกลับมาที่นี่ได้ในภายหลัง

พักสักครู่และทบทวนทุกอย่างจนถึงตอนนี้ ให้แน่ใจว่าคุณยังตามทัน เมื่อคุณพร้อมแล้ว มาต่อกันเถอะ
## การจัดการการดำเนินการแบบบล็อก

มาดูส่วนนี้กัน:

```shell
if a:type ==# "block"
  sil! keepj norm! gv"ad
  keepj $
  keepj pu_

  let l:lastLine = line("$")

  sil! keepj norm "ap

  let l:curLine = line(".")

  sil! keepj norm! VGg@
  exe "keepj norm! 0\<c-v>G$h\"ad" 
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
  exe "keepj " . l:lastLine
  sil! keepj norm! "_dG
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

ถึงเวลาที่จะทำให้ข้อความของคุณเป็นตัวพิมพ์ใหญ่แล้ว จำไว้ว่า `a:type` จะเป็น 'char', 'line', หรือ 'block' ในกรณีส่วนใหญ่ คุณอาจจะได้รับ 'char' และ 'line' แต่บางครั้งคุณอาจจะได้รับบล็อก ซึ่งเป็นเรื่องที่เกิดขึ้นไม่บ่อยนัก แต่ก็ต้องจัดการกับมันให้ได้ น่าเสียดายว่าการจัดการบล็อกนั้นไม่ตรงไปตรงมาเหมือนการจัดการตัวอักษรและบรรทัด มันจะใช้ความพยายามเพิ่มเติมเล็กน้อย แต่ก็ทำได้

ก่อนที่คุณจะเริ่ม มาดูตัวอย่างว่าคุณอาจจะได้รับบล็อกอย่างไร สมมติว่าคุณมีข้อความนี้:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner
```

สมมติว่าตัวชี้ของคุณอยู่ที่ "c" ใน "pancake" บนบรรทัดแรก จากนั้นคุณใช้บล็อกวิชวล (`Ctrl-V`) เพื่อเลือกลงและไปข้างหน้าเพื่อเลือก "cake" ในทั้งสามบรรทัด:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner
```

เมื่อคุณกด `gt` คุณต้องการให้ได้:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner

```
นี่คือสมมติฐานพื้นฐานของคุณ: เมื่อคุณเน้น "cake" สามคำใน "pancakes" คุณกำลังบอก Vim ว่าคุณมีสามบรรทัดของคำที่คุณต้องการเน้น คำเหล่านี้คือ "cake", "cake", และ "cake" คุณคาดหวังว่าจะได้ "Cake", "Cake", และ "Cake"

มาดูรายละเอียดการนำไปใช้กันต่อไป บรรทัดถัดไปมี:

```shell
sil! keepj norm! gv"ad
keepj $
keepj pu_
let l:lastLine = line("$")
sil! keepj norm "ap
let l:curLine = line(".")
```

บรรทัดแรก:

```shell
sil! keepj norm! gv"ad
```

จำไว้ว่า `sil!` ทำงานแบบเงียบและ `keepj` จะเก็บประวัติการกระโดดเมื่อเคลื่อนที่ จากนั้นคุณจะเรียกใช้คำสั่งปกติ `gv"ad` `gv` จะเลือกข้อความที่ถูกเน้นล่าสุด (ในตัวอย่างแพนเค้ก มันจะเน้น "cake" ทั้งสามครั้งอีกครั้ง) `"ad` จะลบข้อความที่ถูกเน้นและเก็บไว้ในรีจิสเตอร์ a ผลลัพธ์ที่ได้คือ:

```shell
pan for breakfast
pan for lunch
pan for dinner
```

ตอนนี้คุณมี 3 *บล็อก* (ไม่ใช่บรรทัด) ของ 'cake' ที่เก็บไว้ในรีจิสเตอร์ a ความแตกต่างนี้สำคัญมาก การดึงข้อความด้วยโหมดวิชวลแบบบรรทัดแตกต่างจากการดึงข้อความด้วยโหมดวิชวลแบบบล็อก จำสิ่งนี้ไว้เพราะคุณจะเห็นมันอีกครั้งในภายหลัง

ถัดไปคุณมี:

```shell
keepj $
keepj pu_
```

`$` จะย้ายคุณไปยังบรรทัดสุดท้ายในไฟล์ของคุณ `pu_` จะแทรกหนึ่งบรรทัดด้านล่างที่ตัวชี้ของคุณอยู่ คุณต้องการเรียกใช้พวกเขาด้วย `keepj` เพื่อไม่ให้เปลี่ยนแปลงประวัติการกระโดด

จากนั้นคุณจะเก็บหมายเลขบรรทัดของบรรทัดสุดท้ายของคุณ (`line("$")`) ในตัวแปรท้องถิ่น `lastLine`

```shell
let l:lastLine = line("$")
```

จากนั้นวางเนื้อหาจากรีจิสเตอร์ด้วย `norm "ap`

```shell
sil! keepj norm "ap
```

จำไว้ว่าเหตุการณ์นี้เกิดขึ้นในบรรทัดใหม่ที่คุณสร้างขึ้นด้านล่างบรรทัดสุดท้ายของไฟล์ - คุณอยู่ที่ด้านล่างของไฟล์ การวางจะให้ข้อความ *บล็อก* เหล่านี้:

```shell
cake
cake
cake
```

ถัดไป คุณจะเก็บตำแหน่งของบรรทัดปัจจุบันที่ตัวชี้ของคุณอยู่

```shell
let l:curLine = line(".")
```

ตอนนี้มาดูบรรทัดถัดไป:

```shell
sil! keepj norm! VGg@
exe "keepj norm! 0\<c-v>G$h\"ad"
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

บรรทัดนี้:

```shell
sil! keepj norm! VGg@
```

`VG` จะเน้นข้อความด้วยโหมดวิชวลแบบบรรทัดจากบรรทัดปัจจุบันไปยังจุดสิ้นสุดของไฟล์ ดังนั้นที่นี่คุณกำลังเน้นบล็อกข้อความ 'cake' สามบล็อกด้วยการเน้นแบบบรรทัด (จำความแตกต่างระหว่างบล็อกกับบรรทัด) สังเกตว่าครั้งแรกที่คุณวางข้อความ "cake" สามครั้ง คุณได้วางเป็นบล็อก ตอนนี้คุณกำลังเน้นเป็นบรรทัด พวกมันอาจดูเหมือนกันจากภายนอก แต่ภายใน Vim รู้ความแตกต่างระหว่างการวางบล็อกข้อความและการวางบรรทัดข้อความ

```shell
cake
cake
cake
```

`g@` เป็นฟังก์ชันโอเปอเรเตอร์ ดังนั้นคุณจึงทำการเรียกซ้ำไปยังตัวมันเอง แต่ทำไม? สิ่งนี้ทำให้เกิดอะไรขึ้น?

คุณกำลังทำการเรียกซ้ำไปยัง `g@` และส่งต่อด้วยบรรทัดทั้งหมด 3 บรรทัด (หลังจากเรียกใช้ด้วย `V` ตอนนี้คุณมีบรรทัด ไม่ใช่บล็อก) ของข้อความ 'cake' ดังนั้นมันจะถูกจัดการโดยส่วนอื่นของโค้ด (คุณจะไปผ่านเรื่องนี้ในภายหลัง) ผลลัพธ์ของการเรียกใช้ `g@` คือบรรทัดสามบรรทัดของข้อความที่ถูกจัดรูปแบบอย่างถูกต้อง:

```shell
Cake
Cake
Cake
```

บรรทัดถัดไป:

```shell
exe "keepj norm! 0\<c-v>G$h\"ad"
```

บรรทัดนี้จะเรียกใช้คำสั่งโหมดปกติเพื่อไปยังจุดเริ่มต้นของบรรทัด (`0`), ใช้การเน้นวิชวลแบบบล็อกเพื่อไปยังบรรทัดสุดท้ายและตัวอักษรสุดท้ายในบรรทัดนั้น (`<c-v>G$`). `h` ใช้เพื่อปรับตัวชี้ (เมื่อทำ `$` Vim จะเคลื่อนที่ไปยังบรรทัดถัดไปทางขวา) สุดท้ายคุณจะลบข้อความที่ถูกเน้นและเก็บไว้ในรีจิสเตอร์ a (`"ad`).

บรรทัดถัดไป:

```shell
exe "keepj " . l:startLine
```

คุณจะย้ายตัวชี้กลับไปยังตำแหน่ง `startLine` ที่เคยอยู่

ถัดไป:

```shell
exe "sil! keepj norm! " . l:startCol . "\<bar>\"aP"
```

เมื่ออยู่ในตำแหน่ง `startLine` ตอนนี้คุณจะกระโดดไปยังคอลัมน์ที่ทำเครื่องหมายโดย `startCol` `\<bar>\` คือการเคลื่อนที่ไปยังบาร์ `|`. การเคลื่อนที่บาร์ใน Vim จะย้ายตัวชี้ของคุณไปยังคอลัมน์ที่ n (สมมติว่า `startCol` คือ 4 การเรียกใช้ `4|` จะทำให้ตัวชี้ของคุณกระโดดไปยังตำแหน่งคอลัมน์ 4) จำไว้ว่า `startCol` คือที่ที่คุณเก็บตำแหน่งคอลัมน์ของข้อความที่คุณต้องการทำให้เป็นตัวพิมพ์ใหญ่ สุดท้าย `"aP` จะวางข้อความที่เก็บไว้ในรีจิสเตอร์ a นี่จะทำให้ข้อความกลับไปยังที่ที่มันถูกลบออกก่อนหน้านี้

มาดูบรรทัดถัดไป 4 บรรทัด:

```shell
exe "keepj " . l:lastLine
sil! keepj norm! "_dG
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

`exe "keepj " . l:lastLine` จะย้ายตัวชี้ของคุณกลับไปยังตำแหน่ง `lastLine` จากก่อนหน้านี้ `sil! keepj norm! "_dG` จะลบช่องว่างเพิ่มเติมที่ถูกสร้างขึ้นโดยใช้รีจิสเตอร์แบล็คโฮล (`"_dG`) ดังนั้นรีจิสเตอร์ที่ไม่มีชื่อของคุณจะสะอาด `exe "keepj " . l:startLine` จะย้ายตัวชี้ของคุณกลับไปยัง `startLine`. สุดท้าย `exe "sil! keepj norm! " . l:startCol . "\<bar>"` จะย้ายตัวชี้ของคุณไปยังคอลัมน์ `startCol`.

นี่คือการกระทำทั้งหมดที่คุณสามารถทำได้ด้วยตนเองใน Vim อย่างไรก็ตาม ข้อดีของการเปลี่ยนการกระทำเหล่านี้ให้เป็นฟังก์ชันที่สามารถนำกลับมาใช้ใหม่ได้คือมันจะช่วยให้คุณไม่ต้องทำตามคำสั่ง 30+ บรรทัดทุกครั้งที่คุณต้องการทำให้ข้อความเป็นตัวพิมพ์ใหญ่ ข้อความที่ต้องจดจำคือ ทุกอย่างที่คุณทำได้ด้วยตนเองใน Vim คุณสามารถเปลี่ยนให้เป็นฟังก์ชันที่สามารถนำกลับมาใช้ใหม่ได้ ดังนั้นจึงเป็นปลั๊กอิน!

นี่คือสิ่งที่มันจะดูเหมือน

เมื่อมีข้อความบางอย่าง:

```shell
pancake for breakfast
pancake for lunch
pancake for dinner

... ข้อความบางส่วน
```

ก่อนอื่น คุณจะเน้นมันด้วยวิธีบล็อก:

```shell
pan[cake] for breakfast
pan[cake] for lunch
pan[cake] for dinner

... ข้อความบางส่วน
```

จากนั้นคุณจะลบและเก็บข้อความนั้นไว้ในรีจิสเตอร์ a:

```shell
pan for breakfast
pan for lunch
pan for dinner

... ข้อความบางส่วน
```

จากนั้นคุณจะวางมันที่ด้านล่างของไฟล์:

```shell
pan for breakfast
pan for lunch
pan for dinner

... ข้อความบางส่วน
cake
cake
cake
```

จากนั้นคุณจะทำให้มันเป็นตัวพิมพ์ใหญ่:

```shell
pan for breakfast
pan for lunch
pan for dinner

... ข้อความบางส่วน
Cake
Cake
Cake
```

สุดท้าย คุณจะนำข้อความที่เป็นตัวพิมพ์ใหญ่กลับไป:

```shell
panCake for breakfast
panCake for lunch
panCake for dinner

... ข้อความบางส่วน
```

## การจัดการการดำเนินการแบบบรรทัดและตัวอักษร

คุณยังไม่เสร็จสิ้น คุณเพิ่งจัดการกับกรณีขอบเมื่อคุณเรียกใช้ `gt` บนข้อความบล็อก คุณยังต้องจัดการกับการดำเนินการ 'line' และ 'char' มาดูโค้ด `else` เพื่อดูว่ามันทำอย่างไร

นี่คือโค้ด:

```shell
if a:type ==# "block"
  # ... 
else
  let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
  let l:titlecased = s:capitalizeFirstWord(l:titlecased)
  call setreg('"', l:titlecased)
  let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
  silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
  exe "keepj " . l:startLine
  exe "sil! keepj norm! " . l:startCol . "\<bar>"
endif
```

มาดูพวกเขาทีละบรรทัด ซอสลับของปลั๊กอินนี้อยู่ที่บรรทัดนี้:

```shell
let l:titlecased = substitute(@@, l:WORD_PATTERN, l:UPCASE_REPLACEMENT, 'g')
```

`@@` จะเก็บข้อความจากรีจิสเตอร์ที่ไม่มีชื่อที่จะทำให้เป็นตัวพิมพ์ใหญ่ `l:WORD_PATTERN` คือการจับคู่คำแต่ละคำ `l:UPCASE_REPLACEMENT` คือการเรียกใช้คำสั่ง `capitalize()` (ซึ่งคุณจะเห็นในภายหลัง) `'g'` คือธงทั่วไประบุให้คำสั่งแทนที่แทนที่คำทั้งหมดที่กำหนด ไม่ใช่แค่คำแรก

บรรทัดถัดไป:

```shell
let l:titlecased = s:capitalizeFirstWord(l:titlecased)
```

นี่จะรับประกันว่าคำแรกจะถูกทำให้เป็นตัวพิมพ์ใหญ่เสมอ หากคุณมีวลีเช่น "an apple a day keeps the doctor away" เนื่องจากคำแรก "an" เป็นคำพิเศษ คำสั่งแทนที่จะไม่ทำให้มันเป็นตัวพิมพ์ใหญ่ คุณต้องมีวิธีที่ทำให้ตัวอักษรแรกเป็นตัวพิมพ์ใหญ่เสมอ ฟังก์ชันนี้ทำเช่นนั้น (คุณจะเห็นรายละเอียดฟังก์ชันนี้ในภายหลัง) ผลลัพธ์ของวิธีการทำให้เป็นตัวพิมพ์ใหญ่เหล่านี้จะถูกเก็บไว้ในตัวแปรท้องถิ่น `l:titlecased`

บรรทัดถัดไป:

```shell
call setreg('"', l:titlecased)
```

นี่จะใส่สตริงที่ทำให้เป็นตัวพิมพ์ใหญ่ลงในรีจิสเตอร์ที่ไม่มีชื่อ (`"`)

ถัดไป บรรทัดสองบรรทัดถัดไป:

```shell
let l:subcommands = #{line: "'[V']p", char: "`[v`]p", block: "`[\<c-v>`]p"}
silent execute "noautocmd keepjumps normal! " .. get(l:subcommands, a:type, "")
```

เฮ้ นั่นดูคุ้นเคย! คุณเคยเห็นรูปแบบที่คล้ายกันมาก่อนกับ `l:commands` แทนที่จะเป็นการดึง ที่นี่คุณใช้การวาง (`p`) ตรวจสอบส่วนก่อนหน้าที่ฉันได้พูดถึง `l:commands` เพื่อให้คุณได้ความสดชื่น

สุดท้าย บรรทัดสองบรรทัดถัดไป:

```shell
exe "keepj " . l:startLine
exe "sil! keepj norm! " . l:startCol . "\<bar>"
```

คุณกำลังย้ายตัวชี้ของคุณกลับไปยังบรรทัดและคอลัมน์ที่คุณเริ่มต้น นั่นคือทั้งหมด!

มาสรุปกันอีกครั้ง วิธีการแทนที่ข้างต้นนั้นชาญฉลาดพอที่จะทำให้ข้อความที่กำหนดเป็นตัวพิมพ์ใหญ่และข้ามคำพิเศษ (รายละเอียดเพิ่มเติมในภายหลัง) หลังจากที่คุณมีสตริงที่ทำให้เป็นตัวพิมพ์ใหญ่ คุณจะเก็บมันในรีจิสเตอร์ที่ไม่มีชื่อ จากนั้นคุณจะเน้นข้อความเดียวกันที่คุณดำเนินการ `g@` ก่อนหน้านี้ จากนั้นวางจากรีจิสเตอร์ที่ไม่มีชื่อ (นี่จะทำให้แทนที่ข้อความที่ไม่เป็นตัวพิมพ์ใหญ่ด้วยเวอร์ชันที่ทำให้เป็นตัวพิมพ์ใหญ่ สุดท้าย คุณจะย้ายตัวชี้ของคุณกลับไปยังที่ที่คุณเริ่มต้น
## การทำความสะอาด

คุณทำงานเสร็จเรียบร้อยแล้ว ข้อความทั้งหมดถูกจัดรูปแบบเป็นตัวพิมพ์ใหญ่แล้ว สิ่งที่เหลืออยู่คือการคืนค่าลงทะเบียนและการตั้งค่า

```shell
call setreg('"', l:reg_save)
call setpos("'<", l:visual_marks_save[0])
call setpos("'>", l:visual_marks_save[1])
let &clipboard = l:cb_save
let &selection = l:sel_save
```

สิ่งเหล่านี้จะคืนค่า:
- ลงทะเบียนที่ไม่มีชื่อ
- เครื่องหมาย `<` และ `>`
- ตัวเลือก `'clipboard'` และ `'selection'`

อู้ว คุณทำเสร็จแล้ว นั่นเป็นฟังก์ชันที่ยาวมาก ฉันสามารถทำให้ฟังก์ชันสั้นลงได้โดยการแยกมันออกเป็นฟังก์ชันที่เล็กลง แต่ตอนนี้ก็ต้องพอเพียงแล้ว ตอนนี้เรามาทบทวนฟังก์ชันการจัดรูปแบบตัวพิมพ์ใหญ่กันสั้นๆ

## ฟังก์ชันการจัดรูปแบบตัวพิมพ์ใหญ่

ในส่วนนี้ เราจะมาทบทวนฟังก์ชัน `s:capitalize()` ฟังก์ชันนี้มีลักษณะดังนี้:

```shell
function! s:capitalize(string)
    if(toupper(a:string) ==# a:string && a:string != 'A')
        return a:string
    endif

    let l:str = tolower(a:string)
    let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
    if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
      return l:str
    endif

    return toupper(l:str[0]) . l:str[1:]
endfunction
```

จำได้ไหมว่าอาร์กิวเมนต์สำหรับฟังก์ชัน `capitalize()` `a:string` คือคำแต่ละคำที่ส่งโดยตัวดำเนินการ `g@` ดังนั้นถ้าฉันรัน `gt` บนข้อความ "pancake for breakfast" ฟังก์ชัน `ToTitle` จะเรียก `capitalize(string)` *สาม* ครั้ง ครั้งหนึ่งสำหรับ "pancake" ครั้งหนึ่งสำหรับ "for" และครั้งหนึ่งสำหรับ "breakfast"

ส่วนแรกของฟังก์ชันคือ:

```shell
if(toupper(a:string) ==# a:string && a:string != 'A')
  return a:string
endif
```

เงื่อนไขแรก (`toupper(a:string) ==# a:string`) ตรวจสอบว่าเวอร์ชันที่เป็นตัวพิมพ์ใหญ่ของอาร์กิวเมนต์นั้นเหมือนกับสตริงและว่าสตริงนั้นไม่ใช่ "A" หากเป็นจริง ให้คืนค่าสตริงนั้น นี่อิงจากสมมติฐานว่าหากคำใดคำหนึ่งถูกพิมพ์เป็นตัวพิมพ์ใหญ่ทั้งหมดแล้ว มันคือคำย่อ ตัวอย่างเช่น คำว่า "CEO" จะถูกแปลงเป็น "Ceo" อืม ซีอีโอของคุณคงไม่พอใจ ดังนั้นจึงดีที่สุดที่จะปล่อยให้คำที่เป็นตัวพิมพ์ใหญ่ทั้งหมดอยู่เฉยๆ เงื่อนไขที่สอง `a:string != 'A'` จัดการกับกรณีขอบสำหรับตัวอักษร "A" ที่เป็นตัวพิมพ์ใหญ่ หาก `a:string` เป็น "A" ที่เป็นตัวพิมพ์ใหญ่แล้ว มันจะผ่านการทดสอบ `toupper(a:string) ==# a:string` โดยบังเอิญ เพราะ "a" เป็นบทความไม่แน่นอนในภาษาอังกฤษ มันจึงต้องถูกแปลงเป็นตัวพิมพ์เล็ก

ส่วนถัดไปบังคับให้สตริงถูกแปลงเป็นตัวพิมพ์เล็ก:

```shell
let l:str = tolower(a:string)
```

ส่วนถัดไปคือ regex ของรายการคำที่ไม่ต้องจัดรูปแบบ ฉันได้มาจาก https://titlecaseconverter.com/rules/ :

```shell
let l:exclusions = '^\(a\|an\|and\|at\|but\|by\|en\|for\|in\|nor\|of\|off\|on\|or\|out\|per\|so\|the\|to\|up\|yet\|v\.?\|vs\.?\|via\)$'
```

ส่วนถัดไป:

```shell
if (match(l:str, l:exclusions) >= 0) || (index(s:local_exclusion_list, l:str) >= 0)
  return l:str
endif
```

ก่อนอื่น ตรวจสอบว่าสตริงของคุณเป็นส่วนหนึ่งของรายการคำที่ไม่ต้องจัดรูปแบบ (`l:exclusions`) หากเป็นเช่นนั้น อย่าจัดรูปแบบมัน จากนั้นตรวจสอบว่าสตริงของคุณเป็นส่วนหนึ่งของรายการการยกเว้นในท้องถิ่น (`s:local_exclusion_list`) รายการการยกเว้นนี้เป็นรายการที่ผู้ใช้สามารถเพิ่มใน vimrc (ในกรณีที่ผู้ใช้มีความต้องการเพิ่มเติมสำหรับคำพิเศษ)

ส่วนสุดท้ายคืนค่ารูปแบบตัวพิมพ์ใหญ่ของคำ ตัวอักษรตัวแรกจะถูกพิมพ์ใหญ่ในขณะที่ส่วนที่เหลือยังคงเหมือนเดิม

```shell
return toupper(l:str[0]) . l:str[1:]
```

มาทบทวนฟังก์ชันการจัดรูปแบบตัวพิมพ์ใหญ่ครั้งที่สอง ฟังก์ชันมีลักษณะดังนี้:

```shell
function! s:capitalizeFirstWord(string)
  if (a:string =~ "\n")
    let l:lineArr = trim(a:string)->split('\n')
    let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
    return l:lineArr->join("\n")
  endif
  return toupper(a:string[0]) . a:string[1:]
endfunction
```

ฟังก์ชันนี้ถูกสร้างขึ้นเพื่อจัดการกับกรณีขอบหากคุณมีประโยคที่เริ่มต้นด้วยคำที่ไม่ต้องจัดรูปแบบ เช่น "an apple a day keeps the doctor away" ตามกฎการจัดรูปแบบตัวพิมพ์ใหญ่ของภาษาอังกฤษ คำแรกในประโยคทั้งหมด ไม่ว่าจะเป็นคำพิเศษหรือไม่ จะต้องถูกจัดรูปแบบเป็นตัวพิมพ์ใหญ่ ด้วยคำสั่ง `substitute()` ของคุณเพียงอย่างเดียว "an" ในประโยคของคุณจะถูกแปลงเป็นตัวพิมพ์เล็ก คุณต้องบังคับให้ตัวอักษรตัวแรกเป็นตัวพิมพ์ใหญ่

ในฟังก์ชัน `capitalizeFirstWord` อาร์กิวเมนต์ `a:string` ไม่ใช่คำแต่ละคำเหมือน `a:string` ภายในฟังก์ชัน `capitalize` แต่เป็นข้อความทั้งหมด ดังนั้นหากคุณมี "pancake for breakfast" ค่าของ `a:string` คือ "pancake for breakfast" มันจะเรียกใช้ `capitalizeFirstWord` เพียงครั้งเดียวสำหรับข้อความทั้งหมด

หนึ่งในสถานการณ์ที่คุณต้องระวังคือหากคุณมีสตริงหลายบรรทัด เช่น `"an apple a day\nkeeps the doctor away"` คุณต้องการให้ตัวอักษรตัวแรกของทุกบรรทัดถูกพิมพ์ใหญ่ หากคุณไม่มีการขึ้นบรรทัดใหม่ ก็ให้พิมพ์ตัวอักษรตัวแรกเป็นตัวพิมพ์ใหญ่

```shell
return toupper(a:string[0]) . a:string[1:]
```

หากคุณมีการขึ้นบรรทัดใหม่ คุณต้องจัดรูปแบบตัวอักษรตัวแรกในแต่ละบรรทัด ดังนั้นคุณจึงแยกพวกมันออกเป็นอาร์เรย์ที่แยกตามการขึ้นบรรทัด:

```shell
let l:lineArr = trim(a:string)->split('\n')
```

จากนั้นคุณทำการแมพแต่ละองค์ประกอบในอาร์เรย์และจัดรูปแบบคำแรกของแต่ละองค์ประกอบ:

```shell
let l:lineArr = map(l:lineArr, 'toupper(v:val[0]) . v:val[1:]')
```

ในที่สุด คุณรวมองค์ประกอบของอาร์เรย์เข้าด้วยกัน:

```shell
return l:lineArr->join("\n")
```

และคุณก็เสร็จเรียบร้อย!

## เอกสาร

ไดเรกทอรีที่สองในที่เก็บคือไดเรกทอรี `docs/` การจัดทำเอกสารให้กับปลั๊กอินเป็นสิ่งที่ดี ในส่วนนี้ ฉันจะพูดคุยเกี่ยวกับวิธีการทำเอกสารสำหรับปลั๊กอินของคุณเองอย่างสั้นๆ

ไดเรกทอรี `docs/` เป็นหนึ่งในเส้นทางการทำงานพิเศษของ Vim Vim จะอ่านไฟล์ทั้งหมดภายใน `docs/` ดังนั้นเมื่อคุณค้นหาคำสำคัญพิเศษและคำสำคัญนั้นถูกพบในหนึ่งในไฟล์ในไดเรกทอรี `docs/` มันจะแสดงในหน้าความช่วยเหลือ ที่นี่คุณมี `totitle.txt` ฉันตั้งชื่อมันแบบนั้นเพราะนั่นคือชื่อปลั๊กอิน แต่คุณสามารถตั้งชื่ออะไรก็ได้ที่คุณต้องการ

ไฟล์เอกสาร Vim เป็นไฟล์ txt โดยพื้นฐาน ความแตกต่างระหว่างไฟล์ txt ปกติกับไฟล์ช่วยเหลือ Vim คือไฟล์หลังนี้ใช้ไวยากรณ์ "ช่วยเหลือ" พิเศษ แต่ก่อนอื่น คุณต้องบอก Vim ให้ถือว่าไม่ใช่ประเภทไฟล์ข้อความ แต่เป็นประเภทไฟล์ `help` เพื่อบอก Vim ให้ตีความ `totitle.txt` นี้เป็นไฟล์ *ช่วยเหลือ* ให้รัน `:set ft=help` (`:h 'filetype'` สำหรับข้อมูลเพิ่มเติม) โดยบังเอิญ หากคุณต้องการบอก Vim ให้ตีความ `totitle.txt` นี้เป็นไฟล์ txt *ปกติ* ให้รัน `:set ft=txt`

### ไวยากรณ์พิเศษของไฟล์ช่วยเหลือ

เพื่อทำให้คำสำคัญค้นหาได้ ให้ล้อมรอบคำสำคัญนั้นด้วยเครื่องหมายดอกจัน เพื่อทำให้คำสำคัญ `totitle` ค้นหาได้เมื่อผู้ใช้ค้นหาคำว่า `:h totitle` ให้เขียนเป็น `*totitle*` ในไฟล์ช่วยเหลือ

ตัวอย่างเช่น ฉันมีบรรทัดเหล่านี้อยู่ด้านบนของสารบัญ:

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

// ข้อมูล TOC เพิ่มเติม
```

โปรดทราบว่าฉันใช้คำสำคัญสองคำ: `*totitle*` และ `*totitle-toc*` เพื่อทำเครื่องหมายส่วนสารบัญ คุณสามารถใช้คำสำคัญได้มากเท่าที่คุณต้องการ นี่หมายความว่าเมื่อใดก็ตามที่คุณค้นหาคำว่า `:h totitle` หรือ `:h totitle-toc` Vim จะพาคุณไปยังตำแหน่งนี้

นี่คือตัวอย่างอีกหนึ่งตัวอย่างที่อยู่ในไฟล์:

```shell
2. Usage                                                       *totitle-usage*

// การใช้งาน
```

หากคุณค้นหาคำว่า `:h totitle-usage` Vim จะพาคุณไปยังส่วนนี้

คุณยังสามารถใช้ลิงก์ภายในเพื่ออ้างอิงไปยังส่วนอื่นในไฟล์ช่วยเหลือโดยการล้อมรอบคำสำคัญด้วยไวยากรณ์บาร์ `|` ในส่วน TOC คุณจะเห็นคำสำคัญที่ล้อมรอบด้วยบาร์ เช่น `|totitle-intro|`, `|totitle-usage|` เป็นต้น

```shell
TABLE OF CONTENTS                                     *totitle*  *totitle-toc*

    1. Intro ........................... |totitle-intro|
    2. Usage ........................... |totitle-usage|
    3. Words to capitalize ............. |totitle-words|
    4. Operator ........................ |totitle-operator|
    5. Key-binding ..................... |totitle-keybinding|
    6. Bugs ............................ |totitle-bug-report|
    7. Contributing .................... |totitle-contributing|
    8. Credits ......................... |totitle-credits|

```
สิ่งนี้ช่วยให้คุณกระโดดไปยังคำจำกัดความ หากคุณวางเคอร์เซอร์ไว้ที่ไหนสักแห่งบน `|totitle-intro|` และกด `Ctrl-]` Vim จะกระโดดไปยังคำจำกัดความของคำนั้น ในกรณีนี้ มันจะกระโดดไปยังตำแหน่ง `*totitle-intro*` นี่คือวิธีที่คุณสามารถเชื่อมโยงไปยังคำสำคัญต่างๆ ในเอกสารช่วยเหลือ

ไม่มีวิธีที่ถูกหรือผิดในการเขียนไฟล์เอกสารใน Vim หากคุณดูปลั๊กอินต่างๆ โดยผู้เขียนต่างๆ หลายคนใช้รูปแบบที่แตกต่างกัน จุดประสงค์คือการทำเอกสารช่วยเหลือที่เข้าใจง่ายสำหรับผู้ใช้ของคุณ

สุดท้าย หากคุณกำลังเขียนปลั๊กอินของคุณเองในเครื่องในตอนแรกและคุณต้องการทดสอบหน้าเอกสาร คุณเพียงแค่เพิ่มไฟล์ txt ลงใน `~/.vim/docs/` จะไม่ทำให้คำสำคัญของคุณสามารถค้นหาได้โดยอัตโนมัติ คุณต้องสั่งให้ Vim เพิ่มหน้าเอกสารของคุณ รันคำสั่ง helptags: `:helptags ~/.vim/doc` เพื่อสร้างไฟล์แท็กใหม่ ตอนนี้คุณสามารถเริ่มค้นหาคำสำคัญของคุณได้แล้ว

## สรุป

คุณทำมันเสร็จเรียบร้อยแล้ว! บทนี้เป็นการรวมกันของบททั้งหมดเกี่ยวกับ Vimscript ที่นี่คุณได้ใช้สิ่งที่คุณได้เรียนรู้จนถึงตอนนี้ในทางปฏิบัติ หวังว่าหลังจากอ่านสิ่งนี้ คุณจะเข้าใจไม่เพียงแค่การสร้างปลั๊กอิน Vim แต่ยังได้รับแรงบันดาลใจให้เขียนปลั๊กอินของคุณเอง

เมื่อใดก็ตามที่คุณพบว่าตัวเองทำซ้ำชุดของการกระทำเดียวกันหลายครั้ง คุณควรลองสร้างของคุณเอง! มีคนบอกว่าอย่าประดิษฐ์ล้อใหม่ อย่างไรก็ตาม ฉันคิดว่ามันสามารถเป็นประโยชน์ในการประดิษฐ์ล้อใหม่เพื่อการเรียนรู้ อ่านปลั๊กอินของคนอื่น สร้างมันขึ้นมา เรียนรู้จากพวกเขา เขียนของคุณเอง! ใครจะรู้ บางทีคุณอาจจะเขียนปลั๊กอินที่ยอดเยี่ยมและได้รับความนิยมอย่างมากหลังจากอ่านสิ่งนี้ บางทีคุณอาจจะเป็นตำนานคนถัดไปอย่าง Tim Pope เมื่อถึงตอนนั้น บอกให้ฉันรู้ด้วย!