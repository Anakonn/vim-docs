---
description: 이 문서는 Vim에서 검색 및 치환 기능을 활용하는 방법과 정규 표현식을 사용하는 기법을 다룹니다.
title: Ch12. Search and Substitute
---

이 장에서는 두 가지 별개의 그러나 관련된 개념인 검색과 치환을 다룹니다. 편집할 때, 종종 최소 공배수 패턴에 따라 여러 텍스트를 검색해야 합니다. 리터럴 문자열 대신 정규 표현식을 검색 및 치환에서 사용하는 방법을 배우면 어떤 텍스트든 신속하게 타겟팅할 수 있습니다.

부가적으로, 이 장에서는 검색에 대해 이야기할 때 `/`를 사용할 것입니다. `/`로 할 수 있는 모든 것은 `?`로도 할 수 있습니다.

## 스마트 대소문자 구분

검색어의 대소문자를 일치시키는 것은 까다로울 수 있습니다. "Learn Vim"이라는 텍스트를 검색하는 경우, 한 글자의 대소문자를 잘못 입력하여 잘못된 검색 결과를 얻을 수 있습니다. 모든 대소문자를 일치시킬 수 있다면 더 쉽고 안전하지 않을까요? 이때 `ignorecase` 옵션이 빛을 발합니다. vimrc에 `set ignorecase`를 추가하면 모든 검색어가 대소문자 구분 없이 작동합니다. 이제 더 이상 `/Learn Vim`을 입력할 필요 없이 `/learn vim`이 작동합니다.

그러나 대소문자가 특정한 구문을 검색해야 할 때가 있습니다. 이를 위해 `ignorecase` 옵션을 끄고 `set noignorecase`를 실행할 수 있지만, 대소문자 구분이 필요한 구문을 검색할 때마다 켜고 끄는 것은 번거롭습니다.

`ignorecase`를 전환하는 대신, Vim은 검색 패턴에 *최소한 하나의 대문자*가 포함되어 있는 경우 대소문자 구분 없는 문자열을 검색하는 `smartcase` 옵션을 제공합니다. 모든 소문자 문자를 입력할 때는 대소문자 구분 없는 검색을 수행하고, 하나 이상의 대문자를 입력할 때는 대소문자 구분 검색을 수행하도록 `ignorecase`와 `smartcase`를 결합할 수 있습니다.

vimrc에 다음을 추가하세요:

```shell
set ignorecase smartcase
```

다음과 같은 텍스트가 있을 때:

```shell
hello
HELLO
Hello
```

- `/hello`는 "hello", "HELLO", "Hello"와 일치합니다.
- `/HELLO`는 "HELLO"와만 일치합니다.
- `/Hello`는 "Hello"와만 일치합니다.

하나의 단점이 있습니다. 소문자 문자열만 검색해야 할 경우는 어떻게 할까요? `/hello`를 입력하면 Vim은 이제 대소문자 구분 없는 검색을 수행합니다. 검색어 어디에서든 `\C` 패턴을 사용하여 Vim에게 이후의 검색어가 대소문자 구분을 해야 한다고 알릴 수 있습니다. `/\Chello`를 입력하면 "hello"와 엄격히 일치하며, "HELLO"나 "Hello"와는 일치하지 않습니다.

## 줄의 첫 번째 및 마지막 문자

`^`를 사용하여 줄의 첫 번째 문자를 일치시키고 `$`를 사용하여 줄의 마지막 문자를 일치시킬 수 있습니다.

이 텍스트가 있을 때:

```shell
hello hello
```

첫 번째 "hello"를 타겟팅하려면 `/^hello`를 실행하세요. `^` 다음의 문자는 줄의 첫 번째 문자여야 합니다. 마지막 "hello"를 타겟팅하려면 `/hello$`를 실행하세요. `$` 앞의 문자는 줄의 마지막 문자여야 합니다.

이 텍스트가 있을 때:

```shell
hello hello friend
```

`/hello$`를 실행하면 "friend"가 그 줄의 마지막 용어이므로 아무것도 일치하지 않습니다.

## 반복 검색

이전 검색을 `//`로 반복할 수 있습니다. `/hello`를 방금 검색했다면, `//`를 실행하는 것은 `/hello`를 실행하는 것과 같습니다. 이 단축키는 긴 문자열을 검색한 경우 특히 몇 번의 키 입력을 절약할 수 있습니다. 또한 `n`과 `N`을 사용하여 마지막 검색을 같은 방향과 반대 방향으로 반복할 수 있음을 기억하세요.

* n개의 마지막 검색어를 빠르게 기억하고 싶다면? 먼저 `/`를 누른 다음, 필요한 검색어를 찾을 때까지 `위쪽`/`아래쪽` 화살표 키(또는 `Ctrl-N`/`Ctrl-P`)를 누르면 검색 기록을 빠르게 탐색할 수 있습니다. 모든 검색 기록을 보려면 `:history /`를 실행하세요.

검색 중 파일의 끝에 도달하면 Vim은 오류를 발생시킵니다: `"Search hit the BOTTOM without match for: {your-search}"`. 때때로 이는 과도한 검색을 방지하는 좋은 안전 장치가 될 수 있지만, 다른 경우에는 검색을 다시 맨 위로 순환하고 싶을 수 있습니다. `set wrapscan` 옵션을 사용하여 파일의 끝에 도달했을 때 Vim이 파일의 맨 위에서 다시 검색하도록 할 수 있습니다. 이 기능을 끄려면 `set nowrapscan`을 실행하세요.

## 대체 단어 검색

한 번에 여러 단어를 검색하는 것은 일반적입니다. "hello vim" 또는 "hola vim" 중 하나를 검색해야 하지만 "salve vim"이나 "bonjour vim"은 검색하고 싶지 않다면 `|` 패턴을 사용할 수 있습니다.

다음 텍스트가 있을 때:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

"hello"와 "hola" 모두와 일치시키려면 `/hello\|hola`를 사용할 수 있습니다. 또는(`|`) 연산자를 이스케이프(`\`)해야 하며, 그렇지 않으면 Vim은 문자열 "|"를 문자 그대로 검색합니다.

매번 `\|`를 입력하고 싶지 않다면, 검색 시작 부분에 `magic` 구문(`\v`)을 사용할 수 있습니다: `/\vhello|hola`. 이 가이드에서는 `magic`에 대해 다루지 않지만, `\v`를 사용하면 더 이상 특수 문자를 이스케이프할 필요가 없습니다. `\v`에 대해 더 알고 싶다면 `:h \v`를 확인하세요.

## 일치의 시작과 끝 설정

복합 단어의 일부인 텍스트를 검색해야 할 수도 있습니다. 다음과 같은 텍스트가 있을 때:

```shell
11vim22
vim22
11vim
vim
```

"11"로 시작하고 "22"로 끝나는 "vim"을 선택해야 한다면, `\zs` (시작 일치)와 `\ze` (끝 일치) 연산자를 사용할 수 있습니다. 다음을 실행하세요:

```shell
/11\zsvim\ze22
```

Vim은 여전히 전체 패턴 "11vim22"와 일치해야 하지만, `\zs`와 `\ze` 사이의 패턴만 강조 표시됩니다. 또 다른 예:

```shell
foobar
foobaz
```

"foobar"에서 "foo"를 일치시키고 싶지만 "foobaz"에서는 일치시키고 싶지 않다면, 다음을 실행하세요:

```shell
/foo\zebaz
```

## 문자 범위 검색

지금까지의 모든 검색어는 리터럴 단어 검색이었습니다. 실제로는 텍스트를 찾기 위해 일반 패턴을 사용해야 할 수 있습니다. 가장 기본적인 패턴은 문자 범위 `[ ]`입니다.

어떤 숫자를 검색해야 한다면, 매번 `/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0`를 입력하고 싶지 않을 것입니다. 대신 `/[0-9]`를 사용하여 한 자리 숫자와 일치시킬 수 있습니다. `0-9` 표현식은 Vim이 일치시키려고 시도하는 숫자 범위 0-9를 나타내므로, 1에서 5 사이의 숫자를 찾고 싶다면 `/[1-5]`를 사용하세요.

숫자만 Vim이 찾을 수 있는 데이터 유형은 아닙니다. 소문자 알파벳을 검색하려면 `/[a-z]`를 사용하고, 대문자 알파벳을 검색하려면 `/[A-Z]`를 사용할 수 있습니다.

이러한 범위를 함께 결합할 수 있습니다. "a"에서 "f"까지의 숫자 0-9와 소문자 및 대문자를 검색해야 한다면 `/[0-9a-fA-F]`를 사용할 수 있습니다.

부정 검색을 하려면 문자 범위 괄호 안에 `^`를 추가할 수 있습니다. 비숫자를 검색하려면 `/[^0-9]`를 실행하세요. Vim은 숫자가 아닌 모든 문자와 일치합니다. 주의할 점은 괄호 안의 캐럿(`^`)은 줄의 시작 캐럿과 다르다는 것입니다(예: `/^hello`). 캐럿이 괄호 쌍 밖에 있고 검색어의 첫 번째 문자일 경우 "줄의 첫 번째 문자"를 의미합니다. 괄호 쌍 안의 캐럿이 첫 번째 문자일 경우 부정 검색 연산자를 의미합니다. `/^abc`는 줄의 첫 번째 "abc"와 일치하고 `/[^abc]`는 "a", "b" 또는 "c"가 아닌 모든 문자와 일치합니다.

## 반복 문자 검색

이 텍스트에서 두 자리 숫자를 검색해야 한다면:

```shell
1aa
11a
111
```

`/[0-9][0-9]`를 사용하여 두 자리 문자를 일치시킬 수 있지만, 이 방법은 확장성이 없습니다. 스무 자리 숫자를 일치시켜야 한다면 `[0-9]`를 스무 번 입력하는 것은 즐거운 경험이 아닙니다. 그래서 `count` 인수가 필요합니다.

검색에 `count`를 전달할 수 있습니다. 다음 구문을 가집니다:

```shell
{n,m}
```

참고로, 이 `count` 중괄호는 Vim에서 사용할 때 이스케이프해야 합니다. `count` 연산자는 증가시키고자 하는 단일 문자 뒤에 배치됩니다.

다음은 `count` 구문에 대한 네 가지 다른 변형입니다:
- `{n}`는 정확한 일치입니다. `/[0-9]\{2\}`는 두 자리 숫자 "11"과 "111"의 "11"을 일치시킵니다.
- `{n,m}`은 범위 일치입니다. `/[0-9]\{2,3\}`는 2자리와 3자리 숫자: "11"과 "111"을 일치시킵니다.
- `{,m}`은 최대 일치입니다. `/[0-9]\{,3\}`는 최대 3자리 숫자: "1", "11", "111"을 일치시킵니다.
- `{n,}`는 최소 일치입니다. `/[0-9]\{2,\}`는 최소 2자리 이상의 숫자: "11"과 "111"을 일치시킵니다.

`count` 인수 `\{0,\}` (0개 이상) 및 `\{1,\}` (1개 이상)은 일반적인 검색 패턴이며 Vim에는 이를 위한 특별한 연산자가 있습니다: `*` 및 `+` (`+`는 이스케이프해야 하며 `*`는 이스케이프 없이 잘 작동합니다). `/[0-9]*`를 입력하면 `/[0-9]\{0,\}`와 동일합니다. 이는 0개 이상의 숫자를 검색합니다. "", "1", "123"과 일치합니다. 참고로, "a"라는 글자에는 기술적으로 0개의 숫자가 있기 때문에 비숫자와도 일치합니다. `*`를 사용할 때는 신중하게 생각하세요. `/[0-9]\+`를 입력하면 `/[0-9]\{1,\}`와 동일합니다. 이는 1개 이상의 숫자를 검색합니다. "1"과 "12"와 일치합니다.

## 미리 정의된 문자 범위

Vim은 숫자 및 알파와 같은 일반 문자를 위한 미리 정의된 범위를 가지고 있습니다. 여기서 모든 것을 다루지는 않겠지만, `:h /character-classes`에서 전체 목록을 찾을 수 있습니다. 유용한 것들은 다음과 같습니다:

```shell
\d    숫자 [0-9]
\D    비숫자 [^0-9]
\s    공백 문자 (공백 및 탭)
\S    비공백 문자 (공백 및 탭을 제외한 모든 것)
\w    단어 문자 [0-9A-Za-z_]
\l    소문자 알파벳 [a-z]
\u    대문자 문자 [A-Z]
```

이들을 문자 범위처럼 사용할 수 있습니다. 한 자리 숫자를 검색하려면 `/[0-9]` 대신 `/\d`를 사용하여 더 간결한 구문을 사용할 수 있습니다.

## 검색 예제: 유사한 문자 쌍 사이의 텍스트 캡처

쌍의 큰따옴표로 둘러싸인 구문을 검색하려면:

```shell
"Vim is awesome!"
```

다음과 같이 실행하세요:

```shell
/"[^"]\+"
```

세부 사항을 살펴보면:
- `"`는 리터럴 큰따옴표입니다. 첫 번째 큰따옴표와 일치합니다.
- `[^"]`는 큰따옴표를 제외한 모든 문자입니다. 큰따옴표가 아닌 모든 알파벳 및 공백 문자를 일치시킵니다.
- `\+`는 하나 이상의 문자를 의미합니다. `[^"]` 앞에 있기 때문에 Vim은 큰따옴표가 아닌 하나 이상의 문자를 찾습니다.
- `"`는 리터럴 큰따옴표입니다. 닫는 큰따옴표와 일치합니다.

Vim이 첫 번째 `"`를 발견하면 패턴 캡처를 시작합니다. 두 번째 큰따옴표를 발견하는 순간, 두 번째 `"` 패턴과 일치하고 패턴 캡처를 중지합니다. 이 사이의 모든 비큰따옴표 문자는 `[^"]\+` 패턴에 의해 캡처되며, 이 경우 구문은 `Vim is awesome!`입니다. 이는 쌍의 유사한 구분 기호로 둘러싸인 구문을 캡처하는 일반적인 패턴입니다.

- 쌍의 작은따옴표로 둘러싸인 구문을 캡처하려면 `/'[^']\+'`를 사용할 수 있습니다.
- 제로로 둘러싸인 구문을 캡처하려면 `/0[^0]\+0`을 사용할 수 있습니다.

## 검색 예제: 전화번호 캡처

하이픈(`-`)으로 구분된 미국 전화번호를 일치시키려면 `123-456-7890`과 같이 다음을 사용할 수 있습니다:

```shell
/\d\{3\}-\d\{3\}-\d\{4\}
```

미국 전화번호는 세 자리 숫자 세트, 그 뒤에 또 다른 세 자리 숫자, 마지막으로 네 자리 숫자로 구성됩니다. 세부 사항을 살펴보면:
- `\d\{3\}`는 숫자가 정확히 세 번 반복되는 것과 일치합니다.
- `-`는 리터럴 하이픈입니다.

이스케이프를 입력하지 않고 `\v`를 사용하여 입력할 수 있습니다:

```shell
/\v\d{3}-\d{3}-\d{4}
```

이 패턴은 IP 주소 및 우편번호와 같은 반복 숫자를 캡처하는 데에도 유용합니다.

이 장의 검색 부분은 여기까지입니다. 이제 치환으로 넘어가겠습니다.

## 기본 치환

Vim의 치환 명령은 패턴을 신속하게 찾고 교체하는 유용한 명령입니다. 치환 구문은 다음과 같습니다:

```shell
:s/{old-pattern}/{new-pattern}/
```

기본 사용법부터 시작하겠습니다. 다음과 같은 텍스트가 있을 때:

```shell
vim is good
```

"good"을 "awesome"으로 치환해 보겠습니다. `:s/good/awesome/`을 실행하세요. 다음과 같은 결과를 볼 수 있습니다:

```shell
vim is awesome
```
## 마지막 치환 반복하기

마지막 치환 명령을 일반 명령 `&` 또는 `:s`를 사용하여 반복할 수 있습니다. `:s/good/awesome/`을 실행한 후 `&` 또는 `:s`를 실행하면 이를 반복합니다.

또한, 이 장의 앞부분에서 이전 검색 패턴을 반복하기 위해 `//`를 사용할 수 있다고 언급했습니다. 이 트릭은 치환 명령에서도 작동합니다. 만약 `/good`이 최근에 실행되었고 첫 번째 치환 패턴 인수를 비워두면, `:s//awesome/`처럼 사용하면 `:s/good/awesome/`을 실행하는 것과 동일하게 작동합니다.

## 치환 범위

많은 Ex 명령과 마찬가지로, 치환 명령에 범위 인수를 전달할 수 있습니다. 구문은 다음과 같습니다:

```shell
:[range]s/old/new/
```

다음과 같은 표현식이 있을 때:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

3번에서 5번 줄까지 "let"을 "const"로 치환하려면 다음과 같이 할 수 있습니다:

```shell
:3,5s/let/const/
```

다음은 전달할 수 있는 몇 가지 범위 변형입니다:

- `:,3s/let/const/` - 쉼표 앞에 아무것도 주어지지 않으면 현재 줄을 나타냅니다. 현재 줄에서 3번 줄까지 치환합니다.
- `:1,s/let/const/` - 쉼표 뒤에 아무것도 주어지지 않으면 현재 줄을 나타냅니다. 1번 줄에서 현재 줄까지 치환합니다.
- `:3s/let/const/` - 범위로 하나의 값만 주어지면(쉼표 없음) 해당 줄에서만 치환합니다.

Vim에서 `%`는 일반적으로 전체 파일을 의미합니다. `:%s/let/const/`를 실행하면 모든 줄에서 치환이 이루어집니다. 이 범위 구문을 염두에 두세요. 앞으로 배울 많은 명령줄 명령들이 이 형식을 따를 것입니다.

## 패턴 매칭

다음 몇 섹션에서는 기본 정규 표현식을 다룰 것입니다. 강력한 패턴 지식은 치환 명령을 마스터하는 데 필수적입니다.

다음과 같은 표현식이 있을 때:

```shell
let one = 1;
let two = 2;
let three = 3;
let four = 4;
let five = 5;
```

숫자 주위에 쌍따옴표를 추가하려면:

```shell
:%s/\d/"\0"/
```

결과는 다음과 같습니다:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

명령을 분석해 보겠습니다:
- `:%s`는 전체 파일을 대상으로 치환을 수행합니다.
- `\d`는 숫자에 대한 Vim의 미리 정의된 범위입니다( `[0-9]` 사용과 유사).
- `"\0"` 여기서 쌍따옴표는 리터럴 쌍따옴표입니다. `\0`는 "전체 일치 패턴"을 나타내는 특수 문자입니다. 여기서 일치 패턴은 단일 숫자입니다, `\d`.

또한, `&`도 `\0`처럼 전체 일치 패턴을 나타냅니다. `:s/\d/"&"/`도 작동했을 것입니다.

또 다른 예를 고려해 보겠습니다. 다음 표현식이 있고 모든 "let"을 변수 이름으로 바꿔야 합니다.

```shell
one let = "1";
two let = "2";
three let = "3";
four let = "4";
five let = "5";
```

이를 수행하려면 다음을 실행합니다:

```shell
:%s/\(\w\+\) \(\w\+\)/\2 \1/
```

위 명령은 너무 많은 백슬래시를 포함하고 있어 읽기 어렵습니다. 이 경우 `\v` 연산자를 사용하는 것이 더 편리합니다:

```shell
:%s/\v(\w+) (\w+)/\2 \1/
```

결과는 다음과 같습니다:

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

좋습니다! 그 명령을 분석해 보겠습니다:
- `:%s`는 파일의 모든 줄을 대상으로 치환을 수행합니다.
- `(\w+) (\w+)`는 그룹 매치입니다. `\w`는 Vim의 미리 정의된 범위 중 하나로 단어 문자를 나타냅니다(` [0-9A-Za-z_]`). `( )`로 둘러싸인 부분은 단어 문자 매치를 그룹으로 캡처합니다. 두 그룹 사이의 공백에 주목하세요. `(\w+) (\w+)`는 두 그룹을 캡처합니다. 첫 번째 그룹은 "one"을 캡처하고 두 번째 그룹은 "two"를 캡처합니다.
- `\2 \1`은 캡처된 그룹을 역순으로 반환합니다. `\2`는 캡처된 문자열 "let"을 포함하고 `\1`은 문자열 "one"을 포함합니다. `\2 \1`은 문자열 "let one"을 반환합니다.

`\0`는 전체 일치 패턴을 나타냅니다. 일치하는 문자열을 더 작은 그룹으로 나눌 수 있습니다. 각 그룹은 `\1`, `\2`, `\3` 등으로 표현됩니다.

이 그룹 매치 개념을 확고히 하기 위해 또 다른 예를 들어 보겠습니다. 다음 숫자가 있을 때:

```shell
123
456
789
```

순서를 반대로 하려면 다음을 실행합니다:

```shell
:%s/\v(\d)(\d)(\d)/\3\2\1/
```

결과는 다음과 같습니다:

```shell
321
654
987
```

각 `(\d)`는 각 숫자와 일치하고 그룹을 생성합니다. 첫 번째 줄에서 첫 번째 `(\d)`는 1의 값을 가지고, 두 번째 `(\d)`는 2의 값을 가지고, 세 번째 `(\d)`는 3의 값을 가집니다. 이 값들은 각각 `\1`, `\2`, `\3`에 저장됩니다. 치환의 후반부에서 새로운 패턴 `\3\2\1`은 첫 번째 줄에서 "321" 값을 생성합니다.

대신 다음을 실행했다면:

```shell
:%s/\v(\d\d)(\d)/\2\1/
```
다른 결과를 얻었을 것입니다:

```shell
312
645
978
```

이는 이제 두 개의 그룹만 있기 때문입니다. 첫 번째 그룹은 `(\d\d)`로 캡처되어 `\1`에 저장되고 값은 12입니다. 두 번째 그룹은 `(\d)`로 캡처되어 `\2`에 저장되고 값은 3입니다. 그러면 `\2\1`은 312를 반환합니다.

## 치환 플래그

다음과 같은 문장이 있을 때:

```shell
chocolate pancake, strawberry pancake, blueberry pancake
```

모든 팬케이크를 도넛으로 치환하려면 다음과 같이 실행할 수 없습니다:

```shell
:s/pancake/donut
```

위 명령은 첫 번째 일치 항목만 치환하여 다음과 같은 결과를 줍니다:

```shell
chocolate donut, strawberry pancake, blueberry pancake
```

이를 해결하는 두 가지 방법이 있습니다. 치환 명령을 두 번 더 실행하거나, 글로벌(`g`) 플래그를 전달하여 한 줄의 모든 일치를 치환할 수 있습니다.

글로벌 플래그에 대해 이야기해 보겠습니다. 다음을 실행하세요:

```shell
:s/pancake/donut/g
```

Vim은 한 번의 명령으로 모든 팬케이크를 도넛으로 치환합니다. 글로벌 명령은 치환 명령이 수용하는 여러 플래그 중 하나입니다. 플래그는 치환 명령의 끝에 전달합니다. 유용한 플래그 목록은 다음과 같습니다:

```shell
&    이전 치환 명령의 플래그를 재사용합니다.
g    줄의 모든 일치를 교체합니다.
c    치환 확인을 요청합니다.
e    치환 실패 시 오류 메시지 표시를 방지합니다.
i    대소문자를 구분하지 않고 치환합니다.
I    대소문자를 구분하여 치환합니다.
```

위에 나열하지 않은 더 많은 플래그가 있습니다. 모든 플래그에 대해 읽으려면 `:h s_flags`를 확인하세요.

참고로, 반복 치환 명령(`&` 및 `:s`)은 플래그를 유지하지 않습니다. `&`를 실행하면 `:s/pancake/donut/`를 `g` 없이 반복합니다. 모든 플래그와 함께 마지막 치환 명령을 빠르게 반복하려면 `:&&`를 실행하세요.

## 구분자 변경

URL을 긴 경로로 교체해야 하는 경우:

```shell
https://mysite.com/a/b/c/d/e
```

이를 "hello"로 치환하려면 다음을 실행합니다:

```shell
:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/
```

그러나 어떤 슬래시(`/`)가 치환 패턴의 일부이고 어떤 것이 구분자인지 구분하기 어렵습니다. 구분자는 알파벳, 숫자 또는 `"`, `|`, `\`를 제외한 모든 단일 바이트 문자로 변경할 수 있습니다. 이를 `+`로 교체해 보겠습니다. 위의 치환 명령은 다음과 같이 다시 작성할 수 있습니다:

```shell
:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+
```

이제 구분자가 어디에 있는지 더 쉽게 확인할 수 있습니다.

## 특수 치환

치환하는 텍스트의 대소문자를 수정할 수도 있습니다. 다음 표현식이 주어졌고 변수 "one", "two", "three" 등을 대문자로 바꾸는 작업을 수행해야 합니다.

```shell
let one = "1";
let two = "2";
let three = "3";
let four = "4";
let five = "5";
```

다음과 같이 실행합니다:

```shell
:%s/\v(\w+) (\w+)/\1 \U\2/
```

결과는 다음과 같습니다:

```shell
let ONE = "1";
let TWO = "2";
let THREE = "3";
let FOUR = "4";
let FIVE = "5";
```

분석:
- `(\w+) (\w+)`는 첫 번째 두 개의 일치 그룹을 캡처합니다, 예를 들어 "let"과 "one".
- `\1`은 첫 번째 그룹의 값을 반환합니다, "let".
- `\U\2`는 두 번째 그룹(`\2`)을 대문자로 변환합니다.

이 명령의 요령은 표현식 `\U\2`입니다. `\U`는 다음 문자를 대문자로 변환하도록 지시합니다.

또 다른 예를 들어 보겠습니다. Vim 가이드를 작성하고 있고 각 단어의 첫 글자를 대문자로 바꿔야 한다고 가정해 보겠습니다.

```shell
vim is the greatest text editor in the whole galaxy
```

다음과 같이 실행할 수 있습니다:

```shell
:s/\<./\U&/g
```

결과는 다음과 같습니다:

```shell
Vim Is The Greatest Text Editor In The Whole Galaxy
```

분석:
- `:s`는 현재 줄을 치환합니다.
- `\<.`는 두 부분으로 구성됩니다: `\<`는 단어의 시작과 일치하고 `.`는 어떤 문자와도 일치합니다. `\<` 연산자는 다음 문자가 단어의 첫 번째 문자임을 만듭니다. `.`는 다음 문자이므로 어떤 단어의 첫 번째 문자와 일치합니다.
- `\U&`는 후속 기호 `&`를 대문자로 변환합니다. `&`(또는 `\0`)는 전체 일치를 나타냅니다. 이는 어떤 단어의 첫 번째 문자와 일치합니다.
- `g`는 글로벌 플래그입니다. 이 플래그가 없으면 이 명령은 첫 번째 일치 항목만 치환합니다. 이 줄의 모든 일치를 치환해야 합니다.

특수 치환 기호인 `\U`에 대해 더 알고 싶다면 `:h sub-replace-special`을 확인하세요.

## 대체 패턴

때때로 여러 패턴을 동시에 일치시켜야 합니다. 다음과 같은 인사말이 있을 때:

```shell
hello vim
hola vim
salve vim
bonjour vim
```

"vim"을 "friend"로 치환해야 하지만 "hello" 또는 "hola"라는 단어가 포함된 줄에서만 치환해야 합니다. 이 장의 앞부분에서 `|`를 사용하여 여러 대체 패턴을 사용할 수 있다고 기억하세요.

```shell
:%s/\v(hello|hola) vim/\1 friend/g
```

결과는 다음과 같습니다:

```shell
hello friend
hola friend
salve vim
bonjour vim
```

분석:
- `%s`는 파일의 각 줄에서 치환 명령을 실행합니다.
- `(hello|hola)`는 "hello" 또는 "hola" 중 하나와 일치하고 그룹으로 간주합니다.
- `vim`은 리터럴 단어 "vim"입니다.
- `\1`은 첫 번째 그룹으로, "hello" 또는 "hola"입니다.
- `friend`는 리터럴 단어 "friend"입니다.

## 패턴의 시작과 끝 치환

`\zs`와 `\ze`를 사용하여 일치의 시작과 끝을 정의할 수 있다는 것을 기억하세요. 이 기술은 치환에서도 작동합니다. 다음과 같은 경우:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotcake
```

"hotcake"의 "cake"를 "dog"로 치환하여 "hotdog"를 얻으려면:

```shell
:%s/hot\zscake/dog/g
```

결과:

```shell
chocolate pancake
strawberry sweetcake
blueberry hotdog
```
## 탐욕적 및 비탐욕적

한 줄에서 n번째 일치를 이 트릭으로 대체할 수 있습니다:

```shell
One Mississippi, two Mississippi, three Mississippi, four Mississippi, five Mississippi.
```

세 번째 "Mississippi"를 "Arkansas"로 대체하려면 다음을 실행합니다:

```shell
:s/\v(.{-}\zsMississippi){3}/Arkansas/g
```

분해:
- `:s/` 대체 명령어입니다.
- `\v`는 특수 키워드를 이스케이프할 필요가 없도록 하는 매직 키워드입니다.
- `.`는 모든 단일 문자를 일치시킵니다.
- `{-}`는 앞의 원자의 0개 이상을 비탐욕적으로 일치시킵니다.
- `\zsMississippi`는 "Mississippi"를 일치의 시작으로 만듭니다.
- `(...){3}`는 세 번째 일치를 찾습니다.

이 장에서 `{3}` 구문을 이미 보았습니다. 이 경우 `{3}`는 정확히 세 번째 일치와 일치합니다. 여기서 새로운 트릭은 `{-}`입니다. 이것은 비탐욕적 일치입니다. 주어진 패턴의 가장 짧은 일치를 찾습니다. 이 경우 `(.{-}Mississippi)`는 어떤 문자로 앞서 있는 "Mississippi"의 최소량과 일치합니다. 이것을 `(.*Mississippi)`와 대조하면 주어진 패턴의 가장 긴 일치를 찾습니다.

`(.{-}Mississippi)`를 사용하면 다섯 개의 일치를 얻습니다: "One Mississippi", "Two Mississippi" 등. `(.*Mississippi)`를 사용하면 하나의 일치를 얻습니다: 마지막 "Mississippi". `*`는 탐욕적 일치자이고 `{-}`는 비탐욕적 일치자입니다. 더 알아보려면 `:h /\{-` 및 `:h non-greedy`를 확인하세요.

더 간단한 예를 들어봅시다. 문자열이 다음과 같다면:

```shell
abc1de1
```

"abc1de1" (탐욕적)을 다음과 같이 일치시킬 수 있습니다:

```shell
/a.*1
```

"abc1" (비탐욕적)을 다음과 같이 일치시킬 수 있습니다:

```shell
/a.\{-}1
```

따라서 가장 긴 일치(탐욕적)를 대문자로 바꾸려면 다음을 실행합니다:

```shell
:s/a.*1/\U&/g
```

결과는 다음과 같습니다:

```shell
ABC1DEFG1
```

가장 짧은 일치(비탐욕적)를 대문자로 바꾸려면 다음을 실행합니다:

```shell
:s/a.\{-}1/\U&/g
```

결과는 다음과 같습니다:

```shell
ABC1defg1
```

탐욕적 대 비탐욕적 개념에 익숙하지 않다면 이해하기 어려울 수 있습니다. 이해할 때까지 다양한 조합으로 실험해 보세요.

## 여러 파일에서 대체하기

마지막으로, 여러 파일에서 구문을 대체하는 방법을 배워봅시다. 이 섹션에서는 `food.txt`와 `animal.txt` 두 개의 파일이 있다고 가정합니다.

`food.txt` 내부:

```shell
corndog
hotdog
chilidog
```

`animal.txt` 내부:

```shell
large dog
medium dog
small dog
```

디렉토리 구조는 다음과 같다고 가정합니다:

```shell
- food.txt
- animal.txt
```

먼저 `:args` 안에 `food.txt`와 `animal.txt`를 모두 캡처합니다. 이전 장에서 `:args`를 사용하여 파일 이름 목록을 만들 수 있다는 것을 기억하세요. Vim 내부에서 이를 수행하는 여러 방법 중 하나는 다음을 실행하는 것입니다:

```shell
:args *.txt                  현재 위치의 모든 txt 파일을 캡처합니다.
```

테스트를 위해 `:args`를 실행하면 다음과 같이 표시되어야 합니다:

```shell
[food.txt] animal.txt
```

모든 관련 파일이 인수 목록에 저장되었으므로 `:argdo` 명령을 사용하여 다중 파일 대체를 수행할 수 있습니다. 다음을 실행하세요:

```shell
:argdo %s/dog/chicken/
```

이것은 `:args` 목록에 있는 모든 파일에 대해 대체를 수행합니다. 마지막으로 변경된 파일을 저장하려면:

```shell
:argdo update
```

`:args`와 `:argdo`는 여러 파일에 명령줄 명령을 적용하는 데 유용한 도구입니다. 다른 명령으로 시도해 보세요!

## 매크로로 여러 파일에서 대체하기

또한 매크로를 사용하여 여러 파일에서 대체 명령을 실행할 수 있습니다. 다음을 실행하세요:

```shell
:args *.txt
qq
:%s/dog/chicken/g
:wnext
q
99@q
```

분해:
- `:args *.txt`는 모든 텍스트 파일을 `:args` 목록에 추가합니다.
- `qq`는 "q" 레지스터에서 매크로를 시작합니다.
- `:%s/dog/chicken/g`는 현재 파일의 모든 줄에서 "dog"를 "chicken"으로 대체합니다.
- `:wnext`는 파일을 저장한 후 `args` 목록의 다음 파일로 이동합니다.
- `q`는 매크로 녹음을 중지합니다.
- `99@q`는 매크로를 아흔아홉 번 실행합니다. Vim은 첫 번째 오류를 만나면 매크로 실행을 중지하므로 실제로 매크로를 아흔아홉 번 실행하지는 않습니다.

## 스마트한 방법으로 검색 및 대체 배우기

검색을 잘하는 능력은 편집에서 필요한 기술입니다. 검색을 마스터하면 정규 표현식의 유연성을 활용하여 파일에서 어떤 패턴이든 검색할 수 있습니다. 이러한 것들을 배우는 데 시간을 투자하세요. 정규 표현식에 더 익숙해지려면 정규 표현식을 적극적으로 사용해야 합니다. 나는 한 번 정규 표현식에 관한 책을 읽었지만 실제로 사용하지 않아서 읽은 내용을 거의 잊어버렸습니다. 능동적인 코딩이 어떤 기술을 마스터하는 가장 좋은 방법입니다.

패턴 매칭 기술을 향상시키는 좋은 방법은 패턴을 검색해야 할 때(예: "hello 123"), 문자 그대로의 검색어(`/hello 123`)를 쿼리하는 대신 패턴을 생각해 내는 것입니다(예: `/\v(\l+) (\d+)`). 이러한 정규 표현식 개념 중 많은 부분이 일반 프로그래밍에서도 적용 가능하며, Vim을 사용할 때만 해당되는 것은 아닙니다.

이제 Vim에서 고급 검색 및 대체에 대해 배웠으니, 가장 다재다능한 명령 중 하나인 전역 명령에 대해 배워봅시다.