---
description: Vim에서 효율적으로 파일을 탐색하는 기본적인 이동 방법을 배우고, 마우스보다 빠르게 작업할 수 있는 팁을 제공합니다.
title: Ch05. Moving in a File
---

시작할 때, 키보드로 이동하는 것은 느리고 어색하게 느껴질 수 있지만 포기하지 마세요! 일단 익숙해지면, 마우스를 사용하는 것보다 파일 내에서 더 빠르게 이동할 수 있습니다.

이 장에서는 필수적인 이동 방법과 이를 효율적으로 사용하는 방법을 배울 것입니다. 이것이 Vim의 전체적인 이동 방법이 **아님**을 명심하세요. 여기서의 목표는 생산성을 빠르게 높이기 위해 유용한 이동 방법을 소개하는 것입니다. 더 배우고 싶다면 `:h motion.txt`를 확인하세요.

## 문자 탐색

가장 기본적인 이동 단위는 한 문자씩 왼쪽, 아래, 위, 오른쪽으로 이동하는 것입니다.

```shell
h   왼쪽
j   아래
k   위
l   오른쪽
gj  소프트 래핑된 줄에서 아래로
gk  소프트 래핑된 줄에서 위로
```

방향 화살표를 사용하여 이동할 수도 있습니다. 처음 시작하는 경우, 가장 편한 방법을 사용하세요.

저는 `hjkl`을 선호하는데, 이는 오른손이 홈 행에 머물 수 있기 때문입니다. 이렇게 하면 주변 키에 더 짧게 손을 뻗을 수 있습니다. `hjkl`에 익숙해지기 위해, 실제로 시작할 때 화살표 버튼을 비활성화했습니다. `~/.vimrc`에 다음을 추가했습니다:

```shell
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>
```

이 나쁜 습관을 깨는 데 도움을 주는 플러그인도 있습니다. 그 중 하나는 [vim-hardtime](https://github.com/takac/vim-hardtime)입니다. 놀랍게도, `hjkl`에 익숙해지는 데 일주일도 걸리지 않았습니다.

Vim이 `hjkl`을 사용하는 이유가 궁금하다면, 이는 Bill Joy가 Vi를 작성한 Lear-Siegler ADM-3A 터미널에 화살표 키가 없었기 때문입니다. 그래서 `hjkl`을 사용했습니다.*

## 상대 번호 매기기

`number`와 `relativenumber`를 설정하는 것이 유용하다고 생각합니다. `.vimrc`에 다음을 추가하여 설정할 수 있습니다:

```shell
set relativenumber number
```

이렇게 하면 현재 줄 번호와 상대 줄 번호가 표시됩니다.

왼쪽 열에 번호가 있는 것이 유용한 이유는 쉽게 이해할 수 있지만, 상대 번호가 왼쪽 열에 있는 것이 어떻게 유용할 수 있는지 궁금할 수 있습니다. 상대 번호가 있으면 커서가 목표 텍스트와 몇 줄 떨어져 있는지를 빠르게 확인할 수 있습니다. 이를 통해 목표 텍스트가 제 아래 12줄에 있다는 것을 쉽게 알 수 있으므로 `d12j`로 삭제할 수 있습니다. 그렇지 않으면 제가 69줄에 있고 목표가 81줄에 있다면, 정신적으로 계산해야 합니다 (81 - 69 = 12). 편집 중에 수학을 하는 것은 너무 많은 정신 자원을 소모합니다. 가야 할 곳에 대해 생각할 필요가 적을수록 좋습니다.

이것은 100% 개인적인 취향입니다. `relativenumber` / `norelativenumber`, `number` / `nonumber`를 실험해보고 가장 유용한 것을 사용하세요!

## 이동 수 세기

"수" 인자에 대해 이야기해봅시다. Vim의 이동 명령은 앞에 숫자 인자를 받을 수 있습니다. 위에서 언급했듯이 `12j`로 12줄 아래로 이동할 수 있습니다. `12j`의 12가 수입니다.

이동에 수를 사용하는 구문은 다음과 같습니다:

```shell
[count] + motion
```

이것은 모든 이동에 적용할 수 있습니다. 오른쪽으로 9문자를 이동하고 싶다면, `l`을 9번 누르는 대신 `9l`을 입력하면 됩니다.

## 단어 탐색

더 큰 이동 단위인 *단어*로 이동해봅시다. 다음 단어의 시작으로 이동하려면 (`w`), 다음 단어의 끝으로 이동하려면 (`e`), 이전 단어의 시작으로 이동하려면 (`b`), 이전 단어의 끝으로 이동하려면 (`ge`)를 사용합니다.

또한, *WORD*가 있습니다. 이는 단어와 구별됩니다. 다음 WORD의 시작으로 이동하려면 (`W`), 다음 WORD의 끝으로 이동하려면 (`E`), 이전 WORD의 시작으로 이동하려면 (`B`), 이전 WORD의 끝으로 이동하려면 (`gE`)를 사용합니다. 기억하기 쉽게, WORD는 단어와 같은 글자를 사용하지만 대문자로 되어 있습니다.

```shell
w     다음 단어의 시작으로 앞으로 이동
W     다음 WORD의 시작으로 앞으로 이동
e     다음 단어의 끝으로 한 단어 앞으로 이동
E     다음 WORD의 끝으로 한 단어 앞으로 이동
b     이전 단어의 시작으로 뒤로 이동
B     이전 WORD의 시작으로 뒤로 이동
ge    이전 단어의 끝으로 뒤로 이동
gE    이전 WORD의 끝으로 뒤로 이동
```

단어와 WORD의 유사점과 차이점은 무엇일까요? 단어와 WORD는 모두 공백 문자로 구분됩니다. 단어는 *오직* `a-zA-Z0-9_`로 이루어진 문자 시퀀스입니다. WORD는 공백을 제외한 모든 문자로 이루어진 시퀀스입니다 (공백은 공백, 탭, EOL을 의미합니다). 더 알고 싶다면 `:h word`와 `:h WORD`를 확인하세요.

예를 들어, 다음과 같은 코드가 있다고 가정해봅시다:

```shell
const hello = "world";
```

줄의 시작에 커서가 있을 때, `l`을 사용하여 줄의 끝으로 가려면 21번의 키 입력이 필요합니다. `w`를 사용하면 6번, `W`를 사용하면 4번만에 가능합니다. 단어와 WORD 모두 짧은 거리 이동에 좋은 옵션입니다.

하지만 현재 줄 탐색을 통해 "c"에서 ";"로 한 번의 키 입력으로 이동할 수 있습니다.

## 현재 줄 탐색

편집할 때, 종종 줄 내에서 수평으로 탐색해야 합니다. 현재 줄의 첫 번째 문자로 점프하려면 `0`을 사용하고, 현재 줄의 마지막 문자로 가려면 `$`를 사용합니다. 또한, 현재 줄의 첫 번째 비어 있지 않은 문자로 가려면 `^`를 사용하고, 현재 줄의 마지막 비어 있지 않은 문자로 가려면 `g_`를 사용합니다. 현재 줄의 `n` 열로 가고 싶다면 `n|`를 사용할 수 있습니다.

```shell
0     현재 줄의 첫 번째 문자로 이동
^     현재 줄의 첫 번째 비어 있지 않은 문자로 이동
g_    현재 줄의 마지막 비어 있지 않은 문자로 이동
$     현재 줄의 마지막 문자로 이동
n|    현재 줄의 n 열로 이동
```

현재 줄 검색은 `f`와 `t`를 사용하여 수행할 수 있습니다. `f`와 `t`의 차이는 `f`는 일치하는 첫 번째 문자로 이동하고, `t`는 일치하는 첫 번째 문자 바로 앞까지 이동합니다. 따라서 "h"를 검색하고 "h"에 도달하고 싶다면 `fh`를 사용하세요. 첫 번째 "h"를 검색하고 일치하기 바로 전에 도달하고 싶다면 `th`를 사용하세요. 마지막 현재 줄 검색의 *다음* 발생으로 가려면 `;`를 사용하고, 마지막 현재 줄 일치의 이전 발생으로 가려면 `,`를 사용하세요.

`F`와 `T`는 `f`와 `t`의 역방향 대응입니다. "h"를 역방향으로 검색하려면 `Fh`를 실행하세요. 같은 방향으로 "h"를 계속 검색하려면 `;`를 사용하세요. `Fh` 뒤의 `;`는 역방향으로 검색하고, `Fh` 뒤의 `,`는 정방향으로 검색합니다.

```shell
f    현재 줄에서 일치하는 항목을 앞으로 검색
F    현재 줄에서 일치하는 항목을 뒤로 검색
t    현재 줄에서 일치하는 항목을 앞으로 검색하되, 일치하기 전에 멈춤
T    현재 줄에서 일치하는 항목을 뒤로 검색하되, 일치하기 전에 멈춤
;    같은 방향으로 마지막 검색을 반복
,    반대 방향으로 마지막 검색을 반복
```

이전 예제로 돌아가서:

```shell
const hello = "world";
```

줄의 시작에 커서가 있을 때, 현재 줄의 마지막 문자 (";")로 한 번의 키 입력으로 이동할 수 있습니다: `$`. "world"의 "w"로 가고 싶다면 `fw`를 사용할 수 있습니다. 줄 내에서 어디로든 가는 좋은 팁은 목표 근처에 있는 덜 일반적인 문자 ("j", "x", "z")를 찾는 것입니다.

## 문장 및 단락 탐색

다음 두 탐색 단위는 문장과 단락입니다.

먼저 문장이 무엇인지 이야기해봅시다. 문장은 `. ! ?`로 끝나며, 그 뒤에 EOL, 공백 또는 탭이 옵니다. 다음 문장으로 점프하려면 `)`를 사용하고, 이전 문장으로 점프하려면 `(`를 사용합니다.

```shell
(    이전 문장으로 점프
)    다음 문장으로 점프
```

몇 가지 예를 살펴봅시다. 어떤 구문이 문장이고 어떤 구문이 문장이 아닌지 생각해보세요. Vim에서 `(`와 `)`로 탐색해보세요!

```shell
나는 문장입니다. 나는 마침표로 끝나는 또 다른 문장입니다. 나는 느낌표로 끝날 때도 여전히 문장입니다! 물음표는 어떨까요? 나는 하이픈 - 때문에 문장이 아닙니다 - 세미콜론 ;이나 콜론 :도 마찬가지입니다.

내 위에 빈 줄이 있습니다.
```

그런데, 문장이 `.`로 구분된 구문을 세지 않는 문제가 발생한다면, `'compatible'` 모드에 있을 수 있습니다. vimrc에 `set nocompatible`을 추가하세요. Vi에서는 문장이 `.` 뒤에 **두 개**의 공백이 필요합니다. 항상 `nocompatible`을 설정해야 합니다.

단락이 무엇인지 이야기해봅시다. 단락은 각 빈 줄 이후에 시작하며, 단락 옵션에서 지정된 문자 쌍에 의해 설정된 각 단락 매크로에서도 시작합니다.

```shell
{    이전 단락으로 점프
}    다음 단락으로 점프
```

단락 매크로가 무엇인지 잘 모르겠다면 걱정하지 마세요. 중요한 것은 단락이 빈 줄 이후에 시작하고 끝난다는 것입니다. 이는 대부분의 경우에 해당합니다.

이 예제를 살펴봅시다. `}`와 `{`로 탐색해보세요 (또한, 문장 탐색 `( )`으로도 이동해보세요!)

```shell
안녕하세요. 어떻게 지내세요? 저는 잘 지내고 있습니다, 감사합니다!
Vim은 훌륭합니다.
처음에는 배우기 쉽지 않을 수 있습니다...- 하지만 우리는 함께하고 있습니다. 행운을 빕니다!

다시 안녕하세요.

), (, }, {로 이동해보세요. 어떻게 작동하는지 느껴보세요.
당신은 할 수 있습니다.
```

더 알고 싶다면 `:h sentence`와 `:h paragraph`를 확인하세요.

## 일치 탐색

프로그래머는 코드를 작성하고 편집합니다. 코드는 일반적으로 괄호, 중괄호 및 대괄호를 사용합니다. 이들 사이에서 쉽게 길을 잃을 수 있습니다. 하나의 괄호 안에 있을 때, 다른 쌍으로 점프하려면 `%`를 사용하세요. 이를 통해 괄호, 중괄호 및 대괄호가 일치하는지 확인할 수 있습니다.

```shell
%    다른 일치 항목으로 탐색, 일반적으로 (), [], {}에 작동
```

부모heses를 광범위하게 사용하는 Scheme 코드 예제를 살펴봅시다. 다양한 괄호 안에서 `%`로 이동해보세요.

```shell
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else
          (+ (fib (- n 1)) (fib (- n 2)))
        )))
```

저는 개인적으로 `%`를 [vim-rainbow](https://github.com/frazrepo/vim-rainbow)와 같은 시각적 표시 플러그인과 함께 사용하는 것을 좋아합니다. 더 알고 싶다면 `:h %`를 확인하세요.

## 줄 번호 탐색

줄 번호 `n`으로 점프하려면 `nG`를 사용하세요. 예를 들어, 7줄로 점프하려면 `7G`를 사용하세요. 첫 번째 줄로 점프하려면 `1G` 또는 `gg`를 사용하세요. 마지막 줄로 점프하려면 `G`를 사용하세요.

종종 목표가 정확히 어떤 줄 번호인지 모르지만, 전체 파일의 약 70%에 있다는 것을 알고 있습니다. 이 경우 `70%`를 사용할 수 있습니다. 파일의 중간으로 점프하려면 `50%`를 사용할 수 있습니다.

```shell
gg    첫 번째 줄로 이동
G     마지막 줄로 이동
nG    n줄로 이동
n%    파일의 n%로 이동
```

그런데, 파일의 총 줄 수를 보려면 `Ctrl-g`를 사용할 수 있습니다.

## 창 탐색

빠르게 *창*의 맨 위, 중간 또는 맨 아래로 가려면 `H`, `M`, `L`을 사용할 수 있습니다.

`H`와 `L`에 수를 전달할 수도 있습니다. `10H`를 사용하면 창의 맨 위에서 10줄 아래로 이동합니다. `3L`을 사용하면 창의 마지막 줄에서 3줄 위로 이동합니다.

```shell
H     화면의 맨 위로 이동
M     화면의 중간으로 이동
L     화면의 맨 아래로 이동
nH    위에서 n줄 이동
nL    아래에서 n줄 이동
```

## 스크롤

스크롤하려면 3가지 속도 증가가 있습니다: 전체 화면 (`Ctrl-F/Ctrl-B`), 반 화면 (`Ctrl-D/Ctrl-U`), 및 줄 (`Ctrl-E/Ctrl-Y`).

```shell
Ctrl-E    한 줄 아래로 스크롤
Ctrl-D    반 화면 아래로 스크롤
Ctrl-F    전체 화면 아래로 스크롤
Ctrl-Y    한 줄 위로 스크롤
Ctrl-U    반 화면 위로 스크롤
Ctrl-B    전체 화면 위로 스크롤
```

현재 줄에 상대적으로 스크롤할 수도 있습니다 (화면 시각 확대):

```shell
zt    현재 줄을 화면의 맨 위로 가져오기
zz    현재 줄을 화면의 중간으로 가져오기
zb    현재 줄을 화면의 맨 아래로 가져오기
```
## 검색 탐색

종종 파일 안에 구문이 존재한다는 것을 알고 있습니다. 검색 탐색을 사용하여 매우 빠르게 목표에 도달할 수 있습니다. 구문을 검색하려면 `/`를 사용하여 앞으로 검색하고 `?`를 사용하여 뒤로 검색할 수 있습니다. 마지막 검색을 반복하려면 `n`을 사용할 수 있습니다. 마지막 검색을 반대 방향으로 반복하려면 `N`을 사용할 수 있습니다.

```shell
/    일치하는 항목을 앞으로 검색
?    일치하는 항목을 뒤로 검색
n    이전 검색 방향으로 마지막 검색 반복
N    이전 검색의 반대 방향으로 마지막 검색 반복
```

다음과 같은 텍스트가 있다고 가정해 보겠습니다:

```shell
let one = 1;
let two = 2;
one = "01";
one = "one";
let onetwo = 12;
```

"let"을 검색하려면 `/let`을 실행합니다. "let"을 다시 빠르게 검색하려면 `n`만 입력하면 됩니다. 반대 방향으로 "let"을 다시 검색하려면 `N`을 실행합니다. `?let`을 실행하면 "let"을 뒤로 검색합니다. `n`을 사용하면 이제 "let"을 뒤로 검색하게 되고 (`N`은 이제 "let"을 앞으로 검색합니다).

`set hlsearch`로 검색 하이라이트를 활성화할 수 있습니다. 이제 `/let`을 검색하면 파일 내의 *모든* 일치하는 구문이 강조 표시됩니다. 또한 `set incsearch`로 점진적 검색을 설정할 수 있습니다. 이렇게 하면 입력하는 동안 패턴이 강조 표시됩니다. 기본적으로 일치하는 구문은 다른 구문을 검색할 때까지 강조 표시된 상태로 유지됩니다. 이는 빠르게 성가실 수 있습니다. 강조 표시를 비활성화하려면 `:nohlsearch` 또는 간단히 `:noh`를 실행할 수 있습니다. 저는 이 하이라이트 비활성화 기능을 자주 사용하기 때문에 vimrc에 매핑을 만들었습니다:

```shell
nnoremap <esc><esc> :noh<return><esc>
```

커서 아래의 텍스트를 `*`로 앞으로 검색하고 `#`로 뒤로 검색할 수 있습니다. 커서가 문자열 "one"에 있을 경우, `*`를 누르면 `/\<one\>`를 실행한 것과 같습니다.

`\<`와 `\>`는 `/\<one\>`에서 전체 단어 검색을 의미합니다. 더 큰 단어의 일부인 "one"과는 일치하지 않습니다. "one"이라는 단어와는 일치하지만 "onetwo"와는 일치하지 않습니다. 커서가 "one" 위에 있고 "one"과 "onetwo"와 같은 전체 또는 부분 단어를 일치시키기 위해 앞으로 검색하려면 `*` 대신 `g*`를 사용해야 합니다.

```shell
*     커서 아래의 전체 단어를 앞으로 검색
#     커서 아래의 전체 단어를 뒤로 검색
g*    커서 아래의 단어를 앞으로 검색
g#    커서 아래의 단어를 뒤로 검색
```

## 위치 표시

마크를 사용하여 현재 위치를 저장하고 나중에 이 위치로 돌아갈 수 있습니다. 텍스트 편집을 위한 북마크와 같습니다. `mx`로 마크를 설정할 수 있으며, 여기서 `x`는 알파벳 대문자 또는 소문자 `a-zA-Z`가 될 수 있습니다. 마크로 돌아가는 방법은 두 가지가 있습니다: 정확한 위치(행과 열)로 ` `x`와 행 단위(`'x`)입니다.

```shell
ma    "a" 마크로 위치 표시
`a    "a"의 행과 열로 점프
'a    "a"의 행으로 점프
```

소문자(a-z)로 마킹하는 것과 대문자(A-Z)로 마킹하는 것 사이에는 차이가 있습니다. 소문자는 로컬 마크이고 대문자는 글로벌 마크(때때로 파일 마크라고도 함)입니다.

로컬 마크에 대해 이야기해 보겠습니다. 각 버퍼는 고유한 로컬 마크 세트를 가질 수 있습니다. 두 개의 파일이 열려 있는 경우 첫 번째 파일에서 마크 "a"(`ma`)를 설정하고 두 번째 파일에서 다른 마크 "a"(`ma`)를 설정할 수 있습니다.

각 버퍼에 마크 세트를 가질 수 있는 로컬 마크와 달리, 글로벌 마크는 하나의 세트만 가질 수 있습니다. `myFile.txt` 안에서 `mA`를 설정하면, 다음에 다른 파일에서 `mA`를 실행할 때 첫 번째 "A" 마크를 덮어씁니다. 글로벌 마크의 장점 중 하나는 완전히 다른 프로젝트 안에 있어도 어떤 글로벌 마크로든 점프할 수 있다는 것입니다. 글로벌 마크는 파일 간에 이동할 수 있습니다.

모든 마크를 보려면 `:marks`를 사용하세요. 마크 목록에서 `a-zA-Z` 외에 더 많은 마크가 있다는 것을 알 수 있습니다. 그 중 일부는 다음과 같습니다:

```shell
''    점프 전 현재 버퍼의 마지막 행으로 돌아가기
``    점프 전 현재 버퍼의 마지막 위치로 돌아가기
`[    이전에 변경된 / 복사된 텍스트의 시작으로 점프
`]    이전에 변경된 / 복사된 텍스트의 끝으로 점프
`<    마지막 시각적 선택의 시작으로 점프
`>    마지막 시각적 선택의 끝으로 점프
`0    vim을 종료할 때 마지막으로 편집한 파일로 돌아가기
```

위에 나열된 것보다 더 많은 마크가 있습니다. 저는 그것들이 드물게 사용된다고 생각하기 때문에 여기서는 다루지 않겠지만, 궁금하다면 `:h marks`를 확인하세요.

## 점프

Vim에서 "점프"를 사용하여 다른 파일이나 파일의 다른 부분으로 이동할 수 있습니다. 그러나 모든 동작이 점프로 간주되는 것은 아닙니다. `j`로 아래로 가는 것은 점프로 간주되지 않습니다. `10G`로 10행으로 가는 것은 점프로 간주됩니다.

Vim이 "점프" 명령으로 간주하는 명령은 다음과 같습니다:

```shell
'       마크된 행으로 이동
`       마크된 위치로 이동
G       행으로 이동
/       앞으로 검색
?       뒤로 검색
n       마지막 검색 반복, 같은 방향
N       마지막 검색 반복, 반대 방향
%       일치하는 항목 찾기
(       마지막 문장으로 이동
)       다음 문장으로 이동
{       마지막 단락으로 이동
}       다음 단락으로 이동
L       표시된 창의 마지막 행으로 이동
M       표시된 창의 중간 행으로 이동
H       표시된 창의 첫 번째 행으로 이동
[[      이전 섹션으로 이동
]]      다음 섹션으로 이동
:s      치환
:tag    태그 정의로 점프
```

이 목록을 외우는 것을 추천하지 않습니다. 좋은 규칙은 단어와 현재 행 탐색보다 더 멀리 이동하는 모든 동작은 아마도 점프일 것입니다. Vim은 이동할 때 어디에 있었는지를 추적하며, `:jumps`에서 이 목록을 볼 수 있습니다.

자세한 내용은 `:h jump-motions`를 확인하세요.

점프가 유용한 이유는 무엇일까요? 점프 목록을 탐색할 수 있기 때문입니다. `Ctrl-O`로 점프 목록을 위로 이동하고 `Ctrl-I`로 아래로 이동할 수 있습니다. `hjkl`은 "점프" 명령이 아니지만, 이동하기 전에 현재 위치를 점프 목록에 수동으로 추가할 수 있습니다. 예를 들어, `m'5j`는 현재 위치를 점프 목록에 추가하고 5행 아래로 이동하며, `Ctrl-O`로 돌아올 수 있습니다. 다른 파일 간에도 점프할 수 있으며, 이에 대해서는 다음 부분에서 더 자세히 설명하겠습니다.

## 스마트한 방법으로 탐색 배우기

Vim이 처음이라면 배울 것이 많습니다. 누구도 즉시 모든 것을 기억하기를 기대하지 않습니다. 생각 없이 실행할 수 있기까지는 시간이 걸립니다.

시작하는 가장 좋은 방법은 몇 가지 필수 동작을 암기하는 것입니다. 저는 다음 10가지 동작을 추천합니다: `h, j, k, l, w, b, G, /, ?, n`. 이들을 충분히 반복하여 생각 없이 사용할 수 있을 때까지 연습하세요.

탐색 기술을 향상시키기 위한 제 제안은 다음과 같습니다:
1. 반복되는 동작을 주의하세요. `l`을 반복해서 사용하고 있다면, 더 빠르게 앞으로 이동할 수 있는 동작을 찾아보세요. `w`를 사용할 수 있다는 것을 알게 될 것입니다. `w`를 반복해서 사용하고 있다면, 현재 행을 빠르게 가로지를 수 있는 동작이 있는지 확인하세요. `f`를 사용할 수 있다는 것을 알게 될 것입니다. 필요를 간결하게 설명할 수 있다면, Vim에는 이를 수행할 방법이 있을 가능성이 높습니다.
2. 새로운 동작을 배울 때마다 생각 없이 할 수 있을 때까지 시간을 할애하세요.

마지막으로, 생산성을 위해 모든 Vim 명령을 알 필요는 없다는 것을 깨닫는 것이 중요합니다. 대부분의 Vim 사용자는 그렇지 않습니다. 저도 그렇습니다. 그 순간에 작업을 수행하는 데 도움이 되는 명령을 배우세요.

천천히 하세요. 탐색 기술은 Vim에서 매우 중요한 기술입니다. 매일 작은 것을 배우고 잘 익히세요.